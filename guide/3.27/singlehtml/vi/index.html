<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tài liệu Xitrum Scala Web Framework Guide 3.27.0</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.27.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="None" href="index.html#document-index" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Điều hướng</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">Tài liệu Xitrum Scala Web Framework Guide 3.27.0</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="huong-dan-su-dung-xitrum">
<h1>Hướng dẫn sử dụng Xitrum<a class="headerlink" href="#huong-dan-su-dung-xitrum" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="http://xitrum-framework.github.io/guide.html">Có cả bản tiếng Anh, Nhật, Hàn Quốc và Nga.</a></p>
<div class="toctree-wrapper compound">
<span id="document-intro"></span><div class="section" id="gioi-thieu">
<h2>Giới thiệu<a class="headerlink" href="#gioi-thieu" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre>+--------------------+
|      Clients       |
+--------------------+
          |
+--------------------+
|       Netty        |
+--------------------+
|       Xitrum       |
| +----------------+ |
| | HTTP(S) Server | |
| |----------------| |
| | Web framework  | |  &lt;- Akka, Hazelcast -&gt; Other instances
| +----------------+ |
+--------------------+
|      Your app      |
+--------------------+
</pre></div>
</div>
<p>Xitrum là một Scala web framework bất đồng bộ, <cite>clustered</cite> và cũng là một HTTPS(server) trên nền của
<a class="reference external" href="http://netty.io/">Netty</a> và <a class="reference external" href="http://akka.io/">Akka</a>.</p>
<p><a class="reference external" href="https://groups.google.com/group/xitrum-framework/msg/d6de4865a8576d39">Một người dùng Xiturm</a> đã nói rằng:</p>
<blockquote>
<div><p>Wow, đây thực sự là một sản phẩm tuyệt vời, có thể coi như một Scala framework
hoàn chỉnh tới mức có thể so sánh với Lift (nhưng dễ sử dụng hơn nhiều).</p>
<p><a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> một web framework <cite>full-stack</cite> đúng nghĩa, đáp ứng tất cả các
chức năng cơ bản của một web framework, ngoài ra còn có những phần mở rộng như ETags, file cache tĩnh, công cụ nén
Gzip tự động. Tích hợp công cụ chuyển đổi JSON, before/around/after interceptors, request/session/cookie/flash scopes,
các bộ chuẩn hóa input tích hợp ở cả server và client, tích hợp cả tính năng cache (<a class="reference external" href="http://www.hazelcast.org/">Hazelcast</a>),
tính năng đa ngôn ngữ i18n theo phong cách GNU gettext, Netty (nhanh không kém Nginx), v.v . Và bạn có thể sử dụng nhiều tính năng khác nữa.</p>
</div></blockquote>
<div class="section" id="tinh-nang">
<h3>Tính năng<a class="headerlink" href="#tinh-nang" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Typesafe, dựa trên tinh thần của Scala. Tất cả các APIs đều được thiết kế an toàn nhất có thể</li>
<li>Bất đồng bộ, theo tinh thần của Netty. Việc xử lý các yêu cầu (request) không cần phải đáp ứng (respond) ngay lập lức.
Long polling, chunked response (streaming), WebSocket, và SockJS.</li>
<li>Tích hợp sẵn HTTP và HTTPS server có tốc độ nhanh dựa trên <a class="reference external" href="http://netty.io/">Netty</a>
(HTTPS có thể sử dụng công nghệ Java hoặc công nghệ mã OpenSSL tự nhiên).
Tốc độ phục vụ tập tin tĩnh của Xitrum có thể đạt mức <a class="reference external" href="https://gist.github.com/3293596">tương đương Nginx</a>.</li>
<li>Tối ưu hóa cache cả ở phía máy chủ (server) và máy khách (client) để tăng tốc độ đáp ứng.
Ở tầng máy chủ web, các tập tin nhỏ được cache vào bộ nhớ, đối với các tập tin lớn thì sử dụng kỹ thuật
zero copy của NIO.
Ở tầng web framework bạn có thể khai báo cache ở các mức page, action và object theo phong cách <a class="reference external" href="https://github.com/rails/rails">Rails framework</a>.
<a class="reference external" href="http://code.google.com/speed/page-speed/docs/rules_intro.html">Tất cả thủ thuật mà Google khuyên nên dùng để tăng tốc trang web</a>
như method GET có điều kiện được áp dụng để cache phía client.
Bạn cũng có thể buộc các trình duyệt để luôn gửi yêu cầu đến máy chủ để kiểm tra lại cache trước khi sử dụng.</li>
<li>Tính năng <a class="reference external" href="http://en.wikipedia.org/wiki/Byte_serving">range request</a> hỗ trợ các tập tin tĩnh.
Tính năng này cần cho việc cung cấp dịch vụ video cho điện thoại thông minh.
Bạn có thể tạm dừng/tiếp tục việc tải tập tin video.</li>
<li>Hỗ trợ <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>.</li>
<li>Tính năng định tuyến được thực hiện tự động trên tinh thần của JAX-RS và Rails Engines.
Bạn không cần phải được khai báo ở tất cả các tuyến kết nối tại cùng một điểm mà có thể tại nhiều điểm khác nhau.
Tính năng này có thể hiểu như định tuyến một cách phân tán. Bạn có thể cài cắm ứng dụng này vào ứng dụng khác.
Nếu bạn có một blog engine, bạn có thể đóng gói nó thành một tập tin JAR và đặt tập tin JAR đó trong một
ứng dụng khác, với cách làm như vậy ứng dụng đó sẽ có thêm tính năng blog.
Việc định tuyến thì bao gồm 2 chiều: bạn có thể tái tạo đường dẫn URL (reverse routing) một cách an toàn từ action.
Bạn có thể tạo tài liệu về các định tuyến bằng cách sử dụng <a class="reference external" href="http://swagger.wordnik.com/">Swagger Doc</a>.</li>
<li>Các lớp và các đường định tuyến được tải lại một cách tự động trong chế độ phát triển (development mode).</li>
<li>Các View có thể viết bằng các tập tin mẫu <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a>
một các riêng biệt hoặc bằng Scala inline XML. Cả hai cách đều an toàn.</li>
<li>Phiên làm việc(Sessions) có thể lưu trữ ngay trong cookies(đáp ứng đuợc nhiều user cùng lúc hơn) hoặc lưu trữ bằng <a class="reference external" href="http://www.hazelcast.org/">Hazelcast</a> (tính bảo mật cao hơn).
Hazelcast cũng chạy ngay trong cùng process với việc sử dụng cache phân tán(do đó nhanh hơn và dễ sử dụng hơn) ,
vì vậy bạn không cần phải có một máy chủ cache riêng biệt. Điều này cũng đúng trong chức năng pubsub của Akka.</li>
<li><a class="reference external" href="http://jqueryvalidation.org/">jQuery Validation</a> được tích hợp trong việc chuẩn hóa dữ liệu ở cả máy chủ(server) và máy khách
(client)</li>
<li>i18n theo phong cách <a class="reference external" href="http://en.wikipedia.org/wiki/GNU_gettext">GNU gettext</a>.
Việc trích các chuổi văn bản ra ngoài để thực hiện dịch được thực hiện tự động, bạn sẽ không cần làm thủ công với properties file.
Bạn cũng có thể sử dụng các công cụ mạnh như <a class="reference external" href="http://www.poedit.net/screenshots.php">Poedit</a> để dịch và hợp nhất các bản dịch.
gettext, không giống như hầu hết các giải pháp khác, hỗ trợ các định dạng của cả số ít và số nhiều.</li>
</ul>
<p>Xitrum cố gắng khắc phục các nhược điểm của <a class="reference external" href="https://github.com/scalatra/scalatra">Scalatra</a>
và <a class="reference external" href="http://liftweb.net/">Lift</a>: mạnh hơn Scalatra và dễ sử dụng hơn Lift. Bạn có thể dễ dàng tạo cả RESTful APIs và postbacks.
<a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> là hệ thống controller-first như Scalatra, không phải là
<a class="reference external" href="http://www.assembla.com/wiki/show/liftweb/View_First">view-first</a> như Lift.
Đa số mọi người đã quen thuộc với phong cách controller-first.</p>
<p>Hãy xem <a class="reference internal" href="index.html#document-deps"><em>các dự án liên quan</em></a> để có được danh sách các bản demos, plugins v.v.</p>
</div>
<div class="section" id="dong-gop">
<h3>Đóng góp<a class="headerlink" href="#dong-gop" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> là một framework mã nguồn mở, mã nguồn của Xitrum có thể tìm thấy
<a class="reference external" href="https://github.com/xitrum-framework/xitrum">tại đây</a>,
bạn có thể tham gia vào <a class="reference external" href="http://groups.google.com/group/xitrum-framework">Google group</a> của chúng tôi.</p>
<p>Những người đóng góp dưới đây được xếp theo thứ tự
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/graphs/contributors">đóng góp đầu tiên của họ</a>.</p>
<p>(*): Hiện tại là thành viên hoạt động chính.</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/ngocdaothanh">Ngoc Dao (*)</a></li>
<li><a class="reference external" href="https://github.com/alide">Linh Tran</a></li>
<li><a class="reference external" href="https://github.com/earldouglas">James Earl Douglas</a></li>
<li><a class="reference external" href="https://github.com/caiiiycuk">Aleksander Guryanov</a></li>
<li><a class="reference external" href="https://github.com/georgeOsdDev">Takeharu Oshida (*)</a></li>
<li><a class="reference external" href="https://github.com/kimkha">Nguyen Kim Kha</a></li>
<li><a class="reference external" href="https://github.com/murz">Michael Murray</a></li>
</ul>
</div>
</div>
<span id="document-tutorial"></span><div class="section" id="huong-dan">
<h2>Hướng dẫn<a class="headerlink" href="#huong-dan" title="Permalink to this headline">¶</a></h2>
<p>Chương này giới thiệu ngắn gọn cách tạo và chạy một project Xitrum.
<strong>Việc tạo project được thực hiện với giả định bạn sử dụng Linux và đã cài Java.</strong></p>
<div class="section" id="tao-mot-project-xitrum-moi">
<h3>Tạo một project Xitrum mới<a class="headerlink" href="#tao-mot-project-xitrum-moi" title="Permalink to this headline">¶</a></h3>
<p>Để tạo mới một project Xitrum bạn chỉ cần tải về tập tin
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/archive/master.zip">xitrum-new.zip</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>wget -O xitrum-new.zip https://github.com/xitrum-framework/xitrum-new/archive/master.zip
</pre></div>
</div>
<p>Hoặc:</p>
<div class="highlight-python"><div class="highlight"><pre>curl -L -o xitrum-new.zip https://github.com/xitrum-framework/xitrum-new/archive/master.zip
</pre></div>
</div>
</div>
<div class="section" id="khoi-dong-project-xitrum">
<h3>Khởi động project Xitrum<a class="headerlink" href="#khoi-dong-project-xitrum" title="Permalink to this headline">¶</a></h3>
<p>Cách chuẩn nhất để build một project Scala là sử dụng
<a class="reference external" href="https://github.com/harrah/xsbt/wiki/Setup">SBT</a>. Các project mới được tạo đã có sẵn SBT 0.13 trong thư mục <code class="docutils literal"><span class="pre">sbt</span></code>. Nếu bạn muốn tự cài đặt SBT, bạn có thể xem <a class="reference external" href="https://github.com/harrah/xsbt/wiki/Setup">hướng dẫn cài đặt</a>.</p>
<p>Sử dụng terminal, chuyển đến thư mục của project mới tạo và chạy lệnh <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">run</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>unzip xitrum-new.zip
cd xitrum-new
sbt/sbt run
</pre></div>
</div>
<p>Câu lệnh này sẽ download tất cả <a class="reference internal" href="index.html#document-deps"><em>dependencies</em></a>, biên dịch toàn bộ project,
và khởi động web server qua class <code class="docutils literal"><span class="pre">quickstart.Boot</span></code>. Trong cửa sổ dòng lệnh Terminal,
bạn sẽ thấy tất cả các định tuyến:</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] Load routes.cache or recollect routes...
[INFO] Normal routes:
GET  /  quickstart.action.SiteIndex
[INFO] SockJS routes:
xitrum/metrics/channel  xitrum.metrics.XitrumMetricsChannel  websocket: true, cookie_needed: false
[INFO] Error routes:
404  quickstart.action.NotFoundError
500  quickstart.action.ServerError
[INFO] Xitrum routes:
GET        /webjars/swagger-ui/2.0.17/index                            xitrum.routing.SwaggerUiVersioned
GET        /xitrum/xitrum.js                                           xitrum.js
GET        /xitrum/metrics/channel                                     xitrum.sockjs.Greeting
GET        /xitrum/metrics/channel/:serverId/:sessionId/eventsource    xitrum.sockjs.EventSourceReceive
GET        /xitrum/metrics/channel/:serverId/:sessionId/htmlfile       xitrum.sockjs.HtmlFileReceive
GET        /xitrum/metrics/channel/:serverId/:sessionId/jsonp          xitrum.sockjs.JsonPPollingReceive
POST       /xitrum/metrics/channel/:serverId/:sessionId/jsonp_send     xitrum.sockjs.JsonPPollingSend
WEBSOCKET  /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocket
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr            xitrum.sockjs.XhrPollingReceive
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr_send       xitrum.sockjs.XhrSend
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr_streaming  xitrum.sockjs.XhrStreamingReceive
GET        /xitrum/metrics/channel/info                                xitrum.sockjs.InfoGET
WEBSOCKET  /xitrum/metrics/channel/websocket                           xitrum.sockjs.RawWebSocket
GET        /xitrum/metrics/viewer                                      xitrum.metrics.XitrumMetricsViewer
GET        /xitrum/metrics/channel/:iframe                             xitrum.sockjs.Iframe
GET        /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocketGET
POST       /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocketPOST
[INFO] HTTP server started on port 8000
[INFO] HTTPS server started on port 4430
[INFO] Xitrum started in development mode
</pre></div>
</div>
<p>Khi khởi động, tất cả các định tuyến (routers) sẽ được kiểm tra và lưu vào log. Bạn đã có luôn danh
sách các định tuyến (routers), điều này rất thuận tiện với bạn để viết tài liệu về RESTful APIs của ứng dụng web
cho bên thứ 3.</p>
<p>Truy cập đến đường dẫn <a class="reference external" href="http://localhost:8000/">http://localhost:8000/</a> hoặc <a class="reference external" href="https://localhost:4430/">https://localhost:4430/</a> bằng trình duyệt web. Trong cửa sổ
dòng lệnh bạn sẽ thấy thông tin của các yêu cầu (request):</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] GET quickstart.action.SiteIndex, 1 [ms]
</pre></div>
</div>
</div>
<div class="section" id="import-mot-project-xitrum-vao-eclipse">
<h3>Import một project Xitrum vào Eclipse<a class="headerlink" href="#import-mot-project-xitrum-vao-eclipse" title="Permalink to this headline">¶</a></h3>
<p>Bạn có thể <a class="reference external" href="http://scala-ide.org/">sử dụng Eclipse để viết code Scala</a>.</p>
<p>Sử dụng cửa sổ dòng lệnh và từ thư mục của project Xitrum chạy lệnh sau:</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt eclipse
</pre></div>
</div>
<p>file <code class="docutils literal"><span class="pre">.project</span></code> cho Eclipse sẽ được tạo với thông tin trong file <code class="docutils literal"><span class="pre">build.sbt</span></code>.
Sau đó chạy Eclipse và import project.</p>
</div>
<div class="section" id="import-mot-project-xitrum-vao-intellij">
<h3>Import một project Xitrum vào IntelliJ<a class="headerlink" href="#import-mot-project-xitrum-vao-intellij" title="Permalink to this headline">¶</a></h3>
<p>Bạn cũng có thể sử dụng <a class="reference external" href="http://www.jetbrains.com/idea/">IntelliJ</a> như Eclipse để viết code.</p>
<p>IntelliJ có Scala plugin rất tốt, chỉ cần mở project SBT là xong, không cần tạo trước
project file như trường hợp Eclipse ở trên.</p>
</div>
<div class="section" id="nap-lai-tu-dong-autoreload">
<h3>Nạp lại tự động (Autoreload)<a class="headerlink" href="#nap-lai-tu-dong-autoreload" title="Permalink to this headline">¶</a></h3>
<p>Bạn có thể thiết lập nạp lại tự động các tập tin .class (hot swap) mà không cần phải khởi động lại chương trình. Tuy nhiên, để tránh gặp phải các vấn đề về hiệu suất cũng như tính ổn định của chương
trình, bạn chỉ nên thiết lập nạp lại tự động các tập tin .class trong quá trình phát triển (development mode).</p>
<div class="section" id="chay-project-voi-ides">
<h4>Chạy project với IDEs<a class="headerlink" href="#chay-project-voi-ides" title="Permalink to this headline">¶</a></h4>
<p>Trong quá trình phát triển, khi chạy project với các IDE cấp cao như Eclipse hoặc IntelliJ,
code sẽ được tự động nạp lại bởi thiết lập mặc định của IDE.</p>
</div>
<div class="section" id="chay-project-voi-sbt">
<h4>Chạy project với SBT<a class="headerlink" href="#chay-project-voi-sbt" title="Permalink to this headline">¶</a></h4>
<p>Khi bạn chạy project với SBT, bạn cần phải mở 2 cửa sổ dòng lệnh:</p>
<ul class="simple">
<li>Một để chạy <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">run</span></code>. Câu lệnh này để chạy chương trình và tải lại các tập .class khi chúng được thay đổi.</li>
<li>Một để chạy <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">~compile</span></code>. Mỗi khi bạn thay đổi các file mã nguồn, câu lệnh này sẽ biên dịch mã nguồn thành các file .class.</li>
</ul>
<p>Thư mục sbt có chứa một tập tin là <a class="reference external" href="https://github.com/xitrum-framework/agent7">agent7.jar</a>.
Tập tin này chịu trách nhiệm tải lại các tập tin .class trong thư mục hiện hành (và các thư mục con).
Nếu nhìn vào đoạn mã <code class="docutils literal"><span class="pre">sbt/sbt</span></code>, bạn sẽ thấy tùy chọn <code class="docutils literal"><span class="pre">-javaagent:agent7.jar</span></code>.</p>
</div>
<div class="section" id="dcevm">
<h4>DCEVM<a class="headerlink" href="#dcevm" title="Permalink to this headline">¶</a></h4>
<p>Thông thường JVM chỉ cho phép thay đổi nội dung của một method. Bạn có thể sử dụng
<a class="reference external" href="https://github.com/dcevm/dcevm">DCEVM</a>, một biến thể mã nguồn mở của máy ảo Java HotSpot
VM cho phép bạn định nghĩa lại không hạn chế các class đã được tải.</p>
<p>Bạn có thể cài DCEVM bằng 2 cách:</p>
<ul class="simple">
<li>Sử dụng bản <a class="reference external" href="https://github.com/dcevm/dcevm/releases">Patch</a> với bản Java đã được cài đặt sẵn trên máy của bạn.</li>
<li>Cài đặt một bản <a class="reference external" href="http://dcevm.nentjes.com/">prebuilt</a> (cách dễ dàng hơn).</li>
</ul>
<p>Nếu bạn chọn cách sử dụng Patch:</p>
<ul class="simple">
<li>Bạn có thể kích hoạt DCEVM chạy vĩnh viễn.</li>
<li>Hoặc sử dụng JVM thay thế (&#8220;alternative&#8221; JVM). Trong trường hợp này, để chạy DCEVM bạn cần chạy câu lệnh <code class="docutils literal"><span class="pre">java</span></code> với tùy chọn <code class="docutils literal"><span class="pre">-XXaltjvm=dcevm</span></code>.
Ví dụ, bạn cần thêm tùy chọn <code class="docutils literal"><span class="pre">-XXaltjvm=dcevm</span></code> vào câu lệnh <code class="docutils literal"><span class="pre">sbt/sbt</span></code>.</li>
</ul>
<p>Nếu bạn sử dụng IDE như Eclipse hoặc IntelliJ, bạn cần thiết lập IDE để sử dụng DCEVM (mà không phải JVM mặc định) để chạy project.</p>
<p>Nếu bạn sử dụng SBT, bạn cần cài đặt biến môi trường <code class="docutils literal"><span class="pre">PATH</span></code> với đường dẫn câu lệnh <code class="docutils literal"><span class="pre">java</span></code> từ DCEVM (không phải bản JVM mặc định). Bạn vẫn có thể cần đến <code class="docutils literal"><span class="pre">javaagent</span></code> trên đây, bởi vì mặc dù DCEVM hỗ trợ các tiện ích khi sửa đổi class, bản thân nó không thể tự tải lại các class.</p>
<p>Để có thêm thông tin chi tiết bạn có thể tham khảo <a class="reference external" href="http://javainformed.blogspot.jp/2014/01/jrebel-free-alternative.html">DCEVM - A JRebel free alternative</a>.</p>
</div>
</div>
<div class="section" id="danh-sach-cac-tap-tin-bi-bo-qua">
<h3>Danh sách các tập tin bị bỏ qua<a class="headerlink" href="#danh-sach-cac-tap-tin-bi-bo-qua" title="Permalink to this headline">¶</a></h3>
<p>Thông thường, những những tập tin này nên được <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/.gitignore">bỏ qua</a>
(không commit lên SVN hoặc Git repository):</p>
<div class="highlight-python"><div class="highlight"><pre>.*
log
project/project
project/target
target
tmp
</pre></div>
</div>
</div>
</div>
<span id="document-action_view"></span><div class="section" id="action-and-view">
<h2>Action and view<a class="headerlink" href="#action-and-view" title="Permalink to this headline">¶</a></h2>
<p>Để linh hoạt, Xitrum cung cấp 3 loại actions sau:
<code class="docutils literal"><span class="pre">Action</span></code> thông thường, <code class="docutils literal"><span class="pre">FutureAction</span></code>, và <code class="docutils literal"><span class="pre">ActorAction</span></code>.</p>
<div class="section" id="action-thong-thuong">
<h3>Action thông thường<a class="headerlink" href="#action-thong-thuong" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends Action {
  def execute() {
    respondText(&quot;Hello&quot;)
  }
}
</pre></div>
</div>
<p>Bởi vì các action sẽ chạy trực tiếp trên luồng (thread) IO của Netty nên các action không
nên tốn thời gian xử lý (block process), mặt khác nếu thời gian xử lý của thread IO của Netty
kéo dài, Netty sẽ không còn khả năng đáp ứng các yêu cầu từ phía client hoặc không thể tiếp nhận
các kết nối mới.</p>
</div>
<div class="section" id="futureaction">
<h3>FutureAction<a class="headerlink" href="#futureaction" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.FutureAction
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends FutureAction {
  def execute() {
    respondText(&quot;hi&quot;)
  }
}
</pre></div>
</div>
<p>FutureAction sẽ chạy trong cùng thread pool với <code class="docutils literal"><span class="pre">ActorAction</span></code> dưới đây, được tách
ra từ một phần của Netty thread pool.</p>
</div>
<div class="section" id="actor-action">
<h3>Actor action<a class="headerlink" href="#actor-action" title="Permalink to this headline">¶</a></h3>
<p>Nếu vạn muốn action của bạn hoạt động như một Akka actor, hãy kế thừa nó từ <code class="docutils literal"><span class="pre">ActorAction</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.concurrent.duration._

import xitrum.ActorAction
import xitrum.annotation.GET

@GET(&quot;actor&quot;)
class HelloAction extends ActorAction {
  def execute() {
    // See Akka doc about scheduler
    import context.dispatcher
    context.system.scheduler.scheduleOnce(3 seconds, self, System.currentTimeMillis())

    // See Akka doc about &quot;become&quot;
    context.become {
      case pastTime =&gt;
        respondInlineView(s&quot;It&#39;s $pastTime Unix ms 3s ago.&quot;)
    }
  }
}
</pre></div>
</div>
<p>Một actor instance sẽ được tạo khi có một yêu cầu (request), actor sẽ được dừng khi
đóng kết nối hoặc response được gửi bởi các method <code class="docutils literal"><span class="pre">respondText</span></code>, <code class="docutils literal"><span class="pre">respondView</span></code>, v.v.
Với chunked response, actor sẽ không dừng lại ngay lập tức mà dừng lại khi chunk cuối cùng
được gửi đi.</p>
<p>Actor này sẽ chạy trong thread pool của Akka actor có tên là &#8220;xitrum&#8221;</p>
</div>
<div class="section" id="gui-respond-cho-client">
<h3>Gửi Respond cho client<a class="headerlink" href="#gui-respond-cho-client" title="Permalink to this headline">¶</a></h3>
<p>Từ một action để trả về một respond cho phía client bạn có thể sử dụng những method sau:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondView</span></code>: trả về một tệp view  , có hoặc không có layout</li>
<li><code class="docutils literal"><span class="pre">respondInlineView</span></code>: trả về một      được nhúng (không phải một tệp          riêng lẻ), có hoặc không có layout</li>
<li><code class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></code>: trả về một chuỗi ký tự không có layout</li>
<li><code class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></code>: như trên, với content type là &#8220;text/html&#8221;</li>
<li><code class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>: chuyển đối tượng (object) Scala thành đối tượng JSON và trả về client.</li>
<li><code class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></code>: kết hợp của 2 loại trên.</li>
<li><code class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondBinary</span></code>: trả về một mảng byte</li>
<li><code class="docutils literal"><span class="pre">respondFile</span></code>: gửi file trực tiếp từ đĩa một cách nhanh chóng bằng kỹ thuật <a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a> (aka send-file)</li>
<li><code class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></code> gửi chunk respond</li>
</ul>
</div>
<div class="section" id="gui-tra-mot-view-file">
<h3>Gửi trả một      view file<a class="headerlink" href="#gui-tra-mot-view-file" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Mỗi action có thể liên kết với <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a></dt>
<dd>view file. Thay vì gửi tra trực tiếp ngay trong action với các method trên đây, bạn có</dd>
</dl>
<p>thể sử dụng một view file riêng biệt.</p>
<p>scr/main/scala/mypackage/MyAction.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends Action {
  def execute() {
    respondView()
  }

  def hello(what: String) = &quot;Hello %s&quot;.format(what)
}
</pre></div>
</div>
<p>scr/main/scalate/mypackage/MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage.MyAction

!!! 5
html
  head
    != antiCsrfMeta
    != xitrumCss
    != jsDefaults
    title Welcome to Xitrum

  body
    a(href={url}) Path to the current action
    p= currentAction.asInstanceOf[MyAction].hello(&quot;World&quot;)

    != jsForView
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xitrumCss</span></code> bao gồm các tệp CSS mặc định cho Xitrum. Bạn có thể xóa nó nếu bạn không muốn
sử dụng xitrum-framework.</li>
<li><code class="docutils literal"><span class="pre">jsDefaults</span></code> bao gồm các jQuery, jQuery Validate plugin, v.v, bạn nên đặt nó trong thẻ &lt;head&gt;</li>
<li><code class="docutils literal"><span class="pre">jsForView</span></code> bao gồm các đoạn mã JavaScript thêm bởi <code class="docutils literal"><span class="pre">jsAddToView</span></code>, nên đặt ở phần cuối.</li>
</ul>
<p>Trong    bạn có thể sử dụng các method của class <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Action.scala">xitrum.Action</a>.
Không những thế bạn có thể sử dụng các utility methods cung cấp bởi Scalate điển hình như <code class="docutils literal"><span class="pre">unescape</span></code>.</p>
<p>Xem thêm <a class="reference external" href="http://scalate.fusesource.org/documentation/index.html">Scalate doc</a>.</p>
<blockquote>
<div>mặc định của Scalate là <a class="reference external" href="http://scalate.fusesource.org/documentation/jade.html">Jade</a>.</div></blockquote>
<p>Bạn cũng có thể sử dụng <a class="reference external" href="http://scalate.fusesource.org/documentation/mustache.html">Mustache</a>,
<a class="reference external" href="http://scalate.fusesource.org/documentation/scaml-reference.html">Scaml</a>, hoặc <a class="reference external" href="http://scalate.fusesource.org/documentation/ssp-reference.html">Ssp</a>.</p>
<p>Để cấu hình cho          mặc định, bạn có thể xem xitrum.conf tại thư mục config trong ứng dụng Xitrum</p>
<p>Bạn cũng có thể override         mặc định bằng cách truyền các giá trị &#8220;jade&#8221;, &#8220;mustache&#8221;, &#8220;scaml&#8221;,hoặc &#8220;ssp&#8221; vào tham số &#8220;type&#8221; trong method <cite>respondView</cite>.</p>
<div class="highlight-python"><div class="highlight"><pre>val options = Map(&quot;type&quot; -&gt;&quot;mustache&quot;)
respondView(options)
</pre></div>
</div>
<div class="section" id="ep-kieu-cho-currentaction">
<h4>Ép kiểu cho currentAction<a class="headerlink" href="#ep-kieu-cho-currentaction" title="Permalink to this headline">¶</a></h4>
<p>Nếu bạn muốn có chính xác instance của action hiện thời, bạn có thể ép kiểu cho (casting) <code class="docutils literal"><span class="pre">currentAction</span></code> thành action mà bạn mong muốn.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span><span class="o">=</span> <span class="n">currentAction</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="p">[</span><span class="n">MyAction</span><span class="p">]</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Nếu bạn có có nhiều dòng code như dưới đây, bạn chỉ cần ép kiểu một lần duy nhất:</p>
<div class="highlight-python"><div class="highlight"><pre>- val myAction = currentAction.asInstanceOf[MyAction]; import myAction._

p= hello(&quot;World&quot;)
p= hello(&quot;Scala&quot;)
p= hello(&quot;Xitrum&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h4>Mustache<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Các tài liệu tham khảo cho Mustache:</p>
<ul class="simple">
<li><a class="reference external" href="http://mustache.github.com/mustache.5.html">Mustache syntax</a></li>
<li><a class="reference external" href="http://scalate.fusesource.org/documentation/mustache.html">Scalate implementation</a></li>
</ul>
<p>Bạn không thể làm một vài điều với Mustache như với Jade bởi vì cú pháp của Mustache khá cứng nhắc và cần tuân thủ nghiêm ngặt.</p>
<p>Để truyền tham số từ action vào          của Mustache bạn phải sử dụng method <code class="docutils literal"><span class="pre">at</span></code>:</p>
<p>Action:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">at</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;Jack&quot;</span>
<span class="n">at</span><span class="p">(</span><span class="s">&quot;xitrumCss&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">xitrumCss</span>
</pre></div>
</div>
<p>Mustache        :</p>
<div class="highlight-python"><div class="highlight"><pre>My name is {{name}}
{{xitrumCss}}
</pre></div>
</div>
<p>Ghi nhớ rằng bạn không thể sử dụng các từ khóa dưới đây cho method <code class="docutils literal"><span class="pre">at</span></code> để truyền tham số cho Scalate         , bởi vì chúng đã được sử dụng từ trước.</p>
<ul class="simple">
<li>&#8220;context&#8221;: dùng cho đối tượng (object) Sclate utility, đối tượng này đã bao gồm các method như <code class="docutils literal"><span class="pre">unescape</span></code></li>
<li>&#8220;helper&#8221;: sử dụng cho đối tượng current action</li>
</ul>
</div>
<div class="section" id="coffeescript">
<h4>CoffeeScript<a class="headerlink" href="#coffeescript" title="Permalink to this headline">¶</a></h4>
<p>Bạn có thể nhúng CoffeeScript trong Scalate      bằng cách sử dụng:
<a class="reference external" href="http://scalate.fusesource.org/documentation/jade-syntax.html#filters">:coffeescript filter</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>body
  :coffeescript
    alert &quot;Hello, Coffee!&quot;
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;body&gt;
  &lt;script type=&#39;text/javascript&#39;&gt;
    //&lt;![CDATA[
      (function() {
        alert(&quot;Hello, Coffee!&quot;);
      }).call(this);
    //]]&gt;
  &lt;/script&gt;
&lt;/body&gt;
</pre></div>
</div>
<p>Nhưng bạn cũng nhớ rằng việc sử dụng chúng <a class="reference external" href="http://groups.google.com/group/xitrum-framework/browse_thread/thread/6667a7608f0dc9c7">tốn thời gian</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>jade+javascript+1thread: 1-2ms for page
jade+coffesscript+1thread: 40-70ms for page
jade+javascript+100threads: ~40ms for page
jade+coffesscript+100threads: 400-700ms for page
</pre></div>
</div>
<p>Để tăng tốc độ bạn có thể generate CoffeeScript trước JavaScript.</p>
</div>
</div>
<div class="section" id="layout">
<h3>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h3>
<p>Khi bạn gửi trả một view với <code class="docutils literal"><span class="pre">respondView</span></code> hoặc <code class="docutils literal"><span class="pre">respondInlineView</span></code>, Xitrum sẽ chuyển nó thành một String, và đặt String đó trong biến <code class="docutils literal"><span class="pre">renderedView</span></code>. Xitrum sau đó sẽ gọi đến method <code class="docutils literal"><span class="pre">layout</span></code> của current action, cuối cùng Xitrum sẽ gửi trả kết quả của method này về trình duyệt web.</p>
<p>Mặc định, medthod <code class="docutils literal"><span class="pre">layout</span></code> sẽ tự trả về <code class="docutils literal"><span class="pre">renderedView</span></code>. Nếu bạn muốn trang trí cho view bạn cần override method này. Nếu bạn include <code class="docutils literal"><span class="pre">renderView</span></code> trong method này, view sẽ bao gồm các phần trong layout của bạn.</p>
<p>Điểm mấu chốt ở đây là <code class="docutils literal"><span class="pre">layout</span></code> được gọi sau khi action view của bạn hiện lên, và trong mọi trường hợp đều trả về trình duyệt một kết quả. Kỹ thuật này khá đơn giản và rõ ràng. Nói một cách dễ hiểu hơn, bạn có thể nghĩ rằng sẽ không có một layout nào trong Xitrum. Tất cả chỉ xoay quanh method <code class="docutils literal"><span class="pre">layout</span></code> và bạn có thể làm bất cứ điều gì với method này.</p>
<p>Thông thường, bạn tạo một class cha bao gồm các layout chung:</p>
<p>src/main/scala/mypackage/AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage
import xitrum.Action

trait AppAction extends Action {
  override def layout = renderViewNoLayout[AppAction]()
}
</pre></div>
</div>
<p>src/main/scalate/mypackage/AppAction.jade</p>
<div class="highlight-python"><div class="highlight"><pre>!!! 5
html
  head
    != antiCsrfMeta
    != xitrumCss
    != jsDefaults
    title Welcome to Xitrum

  body
    != renderedView
    != jsForView
</pre></div>
</div>
<p>src/main/scala/mypackage/MyAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends AppAction {
  def execute() {
    respondView()
  }

  def hello(what: String) = &quot;Hello %s&quot;.format(what)
}
</pre></div>
</div>
<p>scr/main/scalate/mypackage/MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage.MyAction

a(href={url}) Path to the current action
p= currentAction.asInstanceOf[MyAction].hello(&quot;World&quot;)
</pre></div>
</div>
<div class="section" id="su-dung-layout-khong-dung-tep-rieng-biet">
<h4>Sử dụng layout không dùng tệp riêng biệt:<a class="headerlink" href="#su-dung-layout-khong-dung-tep-rieng-biet" title="Permalink to this headline">¶</a></h4>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="truyen-truc-tiep-layout-den-method-respondview">
<h4>Truyền trực tiếp layout đến method respondView<a class="headerlink" href="#truyen-truc-tiep-layout-den-method-respondview" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>val specialLayout = () =&gt;
  DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )

respondView(specialLayout _)
</pre></div>
</div>
</div>
</div>
<div class="section" id="inline-view">
<h3>Inline view<a class="headerlink" href="#inline-view" title="Permalink to this headline">¶</a></h3>
<p>Thông thường, bạn viết view trong một tệp Scalate, ạn cũng có thể viết chúng trực tiếp như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends Action {
  def execute() {
    val s = &quot;World&quot;  // Will be automatically HTML-escaped
    respondInlineView(
      &lt;p&gt;Hello &lt;em&gt;{s}&lt;/em&gt;!&lt;/p&gt;
    )
  }
}
</pre></div>
</div>
</div>
<div class="section" id="render-fragment">
<h3>Render fragment<a class="headerlink" href="#render-fragment" title="Permalink to this headline">¶</a></h3>
<p>Giả sử tệp MyAction.jade có đường dẫn:
scr/main/scalate/mypackage/MyAction.jade</p>
<p>Nếu bạn muốn tạo tệp fragment trong cùng thư mục:
scr/main/scalate/mypackage/_MyFragment.jade</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">renderFragment</span><span class="p">[</span><span class="n">MyAction</span><span class="p">](</span><span class="s">&quot;MyFragment&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Nếu <code class="docutils literal"><span class="pre">MyAction</span></code> là current action, bạn có thể bỏ qua:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">renderFragment</span><span class="p">(</span><span class="s">&quot;MyFragment&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="tra-ve-view-cho-action-khac">
<h3>Trả về view cho action khác<a class="headerlink" href="#tra-ve-view-cho-action-khac" title="Permalink to this headline">¶</a></h3>
<p>Sử dụng cú pháp <code class="docutils literal"><span class="pre">respondView[ClassName]()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.{GET, POST}

@GET(&quot;login&quot;)
class LoginFormAction extends Action {
  def execute() {
    // Respond scr/main/scalate/mypackage/LoginFormAction.jade
    respondView()
  }
}

@POST(&quot;login&quot;)
class DoLoginAction extends Action {
  def execute() {
    val authenticated = ...
    if (authenticated)
      redirectTo[HomeAction]()
    else
      // Reuse the view of LoginFormAction
      respondView[LoginFormAction]()
  }
}
</pre></div>
</div>
<div class="section" id="mot-action-nhieu-view">
<h4>Một action - nhiều view<a class="headerlink" href="#mot-action-nhieu-view" title="Permalink to this headline">¶</a></h4>
<p>Nếu bạn muốn có nhiều view cho một action:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.GET

// These are non-routed actions, for mapping to view   files:
// scr/main/scalate/mypackage/HomeAction_NormalUser.jade
// scr/main/scalate/mypackage/HomeAction_Moderator.jade
// scr/main/scalate/mypackage/HomeAction_Admin.jade
trait HomeAction_NormalUser extends Action
trait HomeAction_Moderator  extends Action
trait HomeAction_Admin      extends Action

@GET(&quot;&quot;)
class HomeAction extends Action {
  def execute() {
    val userType = ...
    userType match {
      case NormalUser =&gt; respondView[HomeAction_NormalUser]()
      case Moderator  =&gt; respondView[HomeAction_Moderator]()
      case Admin      =&gt; respondView[HomeAction_Admin]()
    }
  }
}
</pre></div>
</div>
<p>Sử dụng các non-routed action như trên khá phức tạp, nhưng đó là cách typesafe.</p>
<p>Bạn cũng có thể sử dụng <a href="#id2"><span class="problematic" id="id3">``</span></a>String``để chỉ ra đường dẫn đến       :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_NormalUser&quot;</span><span class="p">)</span>
<span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_Moderator&quot;</span><span class="p">)</span>
<span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_Admin&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="component">
<h3>Component<a class="headerlink" href="#component" title="Permalink to this headline">¶</a></h3>
<p>Bạn có thể tạo và tái sử dụng các component của view.
Về cơ bản, một component gần giống với một action và có các tính chất sau:</p>
<ul class="simple">
<li>Component không có route, do đó không cần đến method <code class="docutils literal"><span class="pre">execute</span></code>.</li>
<li>Component không trả về một respond hoàn chỉnh, Component chỉ <code class="docutils literal"><span class="pre">render</span></code> ra các fragment của view. Do đó
trong một component, thay vì sử dụng <code class="docutils literal"><span class="pre">repondXXX</span></code>, bạn hãy sử dụng <code class="docutils literal"><span class="pre">renderXXX</span></code>.</li>
<li>Giống với một action, một component có thể không có, có một, hoặc có nhiều view liên kết với nhau.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.{FutureAction, Component}
import xitrum.annotation.GET

class CompoWithView extends Component {
  def render() = {
    // Render associated view         , e.g. CompoWithView.jade
    // Note that this is renderView, not respondView!
    renderView()
  }
}

class CompoWithoutView extends Component {
  def render() = {
    &quot;Hello World&quot;
  }
}

@GET(&quot;foo/bar&quot;)
class MyAction extends FutureAction {
  def execute() {
    respondView()
  }
}
</pre></div>
</div>
<p>MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage._

!= newComponent[CompoWithView]().render()
!= newComponent[CompoWithoutView]().render()
</pre></div>
</div>
</div>
</div>
<span id="document-restful"></span><div class="section" id="restful-apis">
<h2>RESTful APIs<a class="headerlink" href="#restful-apis" title="Permalink to this headline">¶</a></h2>
<p>Bạn có thể tạo RESTful APIs cho ứng dụng trên iPhone,Android v.v một cách rất dễ dàng.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;articles&quot;)
class ArticlesIndex extends Action {
  def execute() {...}
}

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends Action {
  def execute() {...}
}
</pre></div>
</div>
<p>Tương tự cho các method POST, PUT, PATCH, DELETE, và OPTIONS.
Xitrum tự động kiểm soát phần HEAD như như một method GET với phần response body rỗng.</p>
<p>Với các HTTP client như các trình duyệt web thông thường không hỗ trợ method PUT và DELETE, để mô phỏng PUT và DELETE, sử dụng thủ thuật gửi một method PÓST với <code class="docutils literal"><span class="pre">_method=put</span></code> hoặc <code class="docutils literal"><span class="pre">_method=delete</span></code> trong request body.</p>
<p>Khi các ứng dụng web được khởi chạy, Xitrum sẽ quét tất cả các annotation, xây dựng bảng định tuyến và ghi ra out put để thông báo cho bạn biết bạn có APIs nào:</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] Routes:
GET /articles     quickstart.action.ArticlesIndex
GET /articles/:id quickstart.action.ArticlesShow
</pre></div>
</div>
<p>Các Route được tự động gom lại theo tinh thần của JAX-RS và Rails Engines. Bạn không cần khai báo tất cả các route tại cùng một nơi. Hãy nghĩ về tính năng nay tương tự như distributed route. Bạn có thể sử dụng một ứng dụng trong một ứng dụng khác. Nếu bạn có một blog engine, bạn có thể đóng gói nó thành một tập tin JAR và đặt tập tin JAR đó trong một ứng dụng khác, với cách làm như vậy ứng dụng đó sẽ có thêm tính năng blog.
Việc định tuyến thì bao gồm 2 chiều: bạn có thể tái tạo đường dẫn URL (reverse routing) một cách an toàn từ action.
Bạn có thể tạo tài liệu về các định tuyến bằng cách sử dụng <a class="reference external" href="http://swagger.wordnik.com/">Swagger Doc</a>.</p>
<div class="section" id="route-cache">
<h3>Route cache<a class="headerlink" href="#route-cache" title="Permalink to this headline">¶</a></h3>
<p>Để khởi động nhanh hơn, route được cache trong file <code class="docutils literal"><span class="pre">routes.cache</span></code>.
Trong quá trình phát triển, các route trong các tệp <code class="docutils literal"><span class="pre">*.class</span></code> tại thư mục <code class="docutils literal"><span class="pre">target</span></code> sẽ không được cache. Nếu bạn thực hiện cập nhất các thư viện phụ thuộc có chứa route, bạn có thể cần phải xóa tệp <code class="docutils literal"><span class="pre">routes.cache</span></code>. Tệp này không nên được commit đến kho mã nguồn.</p>
</div>
<div class="section" id="muc-do-uu-tien-cua-cac-route-first-last">
<h3>Mức độ ưu tiên của các route (first, last)<a class="headerlink" href="#muc-do-uu-tien-cua-cac-route-first-last" title="Permalink to this headline">¶</a></h3>
<p>;
Nếu bạn muốn các route như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>/articles/:id --&gt; ArticlesShow
/articles/new --&gt; ArticlesNew
</pre></div>
</div>
<p>Bạn phải chắc chắn rằng route thứ 2 sẽ được kiểm tra trước.
Annotation <code class="docutils literal"><span class="pre">&#64;First</span></code> sẽ được thêm vào:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.{GET, First}

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends Action {
  def execute() {...}
}

@First  // This route has higher priority than &quot;ArticlesShow&quot; above
@GET(&quot;articles/new&quot;)
class ArticlesNew extends Action {
  def execute() {...}
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Last</span></code> is similar.</p>
</div>
<div class="section" id="nhieu-duong-dan-cho-mot-action">
<h3>Nhiều đường dẫn cho một action<a class="headerlink" href="#nhieu-duong-dan-cho-mot-action" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;image&quot;, &quot;image/:format&quot;)
class Image extends Action {
  def execute() {
    val format = paramo(&quot;format&quot;).getOrElse(&quot;png&quot;)
    // ...
  }
}
</pre></div>
</div>
</div>
<div class="section" id="dot-trong-route">
<h3>Dot trong route<a class="headerlink" href="#dot-trong-route" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;, &quot;articles/:id.:format&quot;)
class ArticlesShow extends Action {
  def execute() {
    val id     = param[Int](&quot;id&quot;)
    val format = paramo(&quot;format&quot;).getOrElse(&quot;html&quot;)
    // ...
  }
}
</pre></div>
</div>
</div>
<div class="section" id="regular-expression-trong-route">
<h3>Regular Expression trong route<a class="headerlink" href="#regular-expression-trong-route" title="Permalink to this headline">¶</a></h3>
<p>Regex có thể được sử dụng trong route:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">GET</span><span class="p">(</span><span class="s">&quot;articles/:id&lt;[0-9]+&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="xu-ly-cac-phan-con-lai-cua-route">
<h3>Xử lý các phần còn lại của route<a class="headerlink" href="#xu-ly-cac-phan-con-lai-cua-route" title="Permalink to this headline">¶</a></h3>
<p>Kí tự đặc biệt <code class="docutils literal"><span class="pre">/</span></code> không được phép có mặt trong tên của parameter. Nếu bạn muốn sử dụng kí tự này, parameter phải được đặt cuối cùng và bạn phải sử dụng nó như dưới đây:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">GET</span><span class="p">(</span><span class="s">&quot;service/:id/proxy/:*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Đường dẫn dưới đây sẽ xuất hiện:</p>
<div class="highlight-python"><div class="highlight"><pre>/service/123/proxy/http://foo.com/bar
</pre></div>
</div>
<p>để lấy ra phần <code class="docutils literal"><span class="pre">*</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>val url = param(&quot;*&quot;)  // Will be &quot;http://foo.com/bar&quot;
</pre></div>
</div>
</div>
<div class="section" id="lien-ket-den-mot-action">
<h3>Liên kết đến một action<a class="headerlink" href="#lien-ket-den-mot-action" title="Permalink to this headline">¶</a></h3>
<p>Để bảo toàn tính typesafe của Xitrum, bạn không nên sử dụng URL một cách thủ công, hãy sử dụng các dưới đây:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href={url[ArticlesShow](&quot;id&quot; -&gt; myArticle.id)}&gt;{myArticle.title}&lt;/a&gt;
</pre></div>
</div>
</div>
<div class="section" id="redirect-den-mot-action-khac">
<h3>Redirect đến một action khác<a class="headerlink" href="#redirect-den-mot-action-khac" title="Permalink to this headline">¶</a></h3>
<p>Đọc thêm để biết <a class="reference external" href="http://en.wikipedia.org/wiki/URL_redirection">redirection là gì</a>.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{GET, POST}

@GET(&quot;login&quot;)
class LoginInput extends Action {
  def execute() {...}
}

@POST(&quot;login&quot;)
class DoLogin extends Action {
  def execute() {
    ...
    // After login success
    redirectTo[AdminIndex]()
  }
}

GET(&quot;admin&quot;)
class AdminIndex extends Action {
  def execute() {
    ...
    // Check if the user has not logged in, redirect him to the login page
    redirectTo[LoginInput]()
  }
}
</pre></div>
</div>
<p>Bạn cũng có thể redirect đến action hiện tại (current action) với method <code class="docutils literal"><span class="pre">redirectToThis()</span></code>.</p>
</div>
<div class="section" id="forward-den-action-khac">
<h3>Forward đến action khác<a class="headerlink" href="#forward-den-action-khac" title="Permalink to this headline">¶</a></h3>
<p>Sử dụng method <code class="docutils literal"><span class="pre">forwardTo[AnotherAction]()</span></code>. Nếu bạn sử dụng method <code class="docutils literal"><span class="pre">redirectTo</span></code> ở trên đây, trình duyệt sẽ tạo một request khác, trong khi đó method <code class="docutils literal"><span class="pre">forwardTo</span></code> thì không.</p>
</div>
<div class="section" id="xac-dinh-ajax-request">
<h3>Xác định Ajax request<a class="headerlink" href="#xac-dinh-ajax-request" title="Permalink to this headline">¶</a></h3>
<p>Sử dụng method <code class="docutils literal"><span class="pre">isAjax</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>// In an action
val msg = &quot;A message&quot;
if (isAjax)
  jsRender(&quot;alert(&quot; + jsEscape(msg) + &quot;)&quot;)
else
  respondText(msg)
</pre></div>
</div>
</div>
<div class="section" id="anti-csrf">
<h3>Anti-CSRF<a class="headerlink" href="#anti-csrf" title="Permalink to this headline">¶</a></h3>
<p>Với các requests, Xitrum mặc định bảo vệ ứng dụng web của bạn khỏi kỹ thuật tấn công <a class="reference external" href="http://en.wikipedia.org/wiki/CSRF">Giả mạo Cross-site request</a>.</p>
<p>Khi bạn incluede <code class="docutils literal"><span class="pre">antiCsrfMeta</span></code> trong layout của bạn:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
<p>Thẻ <code class="docutils literal"><span class="pre">&lt;head&gt;</span></code> sẽ tưong tự như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    ...
    &lt;meta name=&quot;csrf-token&quot; content=&quot;5402330e-9916-40d8-a3f4-16b271d583be&quot; /&gt;
    ...
  &lt;/head&gt;
  ...
&lt;/html&gt;
</pre></div>
</div>
<p>Các token sẽ được tự động include trong tất cả các non-GET Ajax requests như <code class="docutils literal"><span class="pre">X-CSRF-Token</span></code> header gửi bởi jQuery nếu bạn include <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a> trong view template. <code class="docutils literal"><span class="pre">xitrum.js</span></code> được include trong <code class="docutils literal"><span class="pre">jsDefaults</span></code>. Nếu bạn không sử dụng <code class="docutils literal"><span class="pre">jsDefaults</span></code>, bạn có thể include <code class="docutils literal"><span class="pre">xitrum.js</span></code> trong template như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script type=&quot;text/javascript&quot; src={url[xitrum.js]}&gt;&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="anticsrfinput-va-anticsrftoken">
<h3>antiCsrfInput và antiCsrfToken<a class="headerlink" href="#anticsrfinput-va-anticsrftoken" title="Permalink to this headline">¶</a></h3>
<p>Xitrum lây CSRF token từ <code class="docutils literal"><span class="pre">X-CSRF-Token</span></code> request header. Nếu header không tồn tại, Xitrum sẽ lấy token từ parameter <code class="docutils literal"><span class="pre">csrf-token</span></code> tại request body (chú ý: không phải parameter trong URL).</p>
<p>Nếu bạn tự tạo form, và bạn không sử dụng thẻ meta và xitrum.js như đã trình bày ở trên, bạn cần sử dụng <code class="docutils literal"><span class="pre">antiCsrfInput</span></code> hoặc <code class="docutils literal"><span class="pre">antiCsrfToken</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[AdminAddGroup]})
  != antiCsrfInput
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[AdminAddGroup]})
  input(type=&quot;hidden&quot; name=&quot;csrf-token&quot; value={antiCsrfToken})
</pre></div>
</div>
</div>
<div class="section" id="skipcsrfcheck">
<h3>SkipCsrfCheck<a class="headerlink" href="#skipcsrfcheck" title="Permalink to this headline">¶</a></h3>
<p>Khi bạn tạo các APIs cho thiết bị, ví dụ điện thoại thông minh, bạn có thể muốn bỏ qua việc tự động kiểm tra CSRS. Thêm trait xitrum.SkipCsrfCheck vào action của bạn:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SkipCsrfCheck}
import xitrum.annotation.POST

trait Api extends Action with SkipCsrfCheck

@POST(&quot;api/positions&quot;)
class LogPositionAPI extends Api {
  def execute() {...}
}

@POST(&quot;api/todos&quot;)
class CreateTodoAPI extends Api {
  def execute() {...}
}
</pre></div>
</div>
</div>
<div class="section" id="kiem-soat-cac-route">
<h3>Kiểm soát các route<a class="headerlink" href="#kiem-soat-cac-route" title="Permalink to this headline">¶</a></h3>
<p>Khi khởi động Xitrum sẽ tự động gom các route lại. Nếu bạn muốn điều khiển các route, bạn có thể sử dụng <a class="reference external" href="http://xitrum-framework.github.io/api/3.17/index.html#xitrum.routing.RouteCollection">xitrum.Config.routes</a>.</p>
<p>Ví dụ:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Config, Server}

object Boot {
  def main(args: Array[String]) {
    // You can modify routes before starting the server
    val routes = Config.routes

    // Remove routes to an action by its class
    routes.removeByClass[MyClass]()

    if (demoVersion) {
      // Remove routes to actions by a prefix
      routes.removeByPrefix(&quot;premium/features&quot;)

      // This also works
      routes.removeByPrefix(&quot;/premium/features&quot;)
    }

    ...

    Server.start()
  }
}
</pre></div>
</div>
</div>
<div class="section" id="lay-tat-ca-cac-request-content">
<h3>Lấy tất cẩ các request content<a class="headerlink" href="#lay-tat-ca-cac-request-content" title="Permalink to this headline">¶</a></h3>
<p>Thông thường, nếu request content không phải là <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code>, bạn có thể cần phải lấy tất cả các request content (và tự phân tích chúng).</p>
<p>Để lấy ra một chuối ký tự (string):</p>
<div class="highlight-python"><div class="highlight"><pre>val body = requestContentString
</pre></div>
</div>
<p>Để lấy ra một string và phân tích chúng thành JSON:</p>
<div class="highlight-python"><div class="highlight"><pre>val myJValue = requestContentJValue  // =&gt; JSON4S (http://json4s.org) JValue
val myMap = xitrum.util.SeriDeseri.fromJValue[Map[String, Int]](myJValue)
</pre></div>
</div>
<p>Nếu bạn muốn kiểm soát toàn bộn, sử dụng <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/FullHttpRequest.html">request.getContent</a>. Nó sẽ trả về một <a class="reference external" href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html">ByteBuf</a>.</p>
</div>
<div class="section" id="viet-tai-lieu-api-voi-swagger">
<h3>Viết tài liệu API với Swagger<a class="headerlink" href="#viet-tai-lieu-api-voi-swagger" title="Permalink to this headline">¶</a></h3>
<p>Bạn có thể viết tài liệu cho API của bạn với <a class="reference external" href="https://developers.helloreverb.com/swagger/">Swagger</a>. Thêm annotation <code class="docutils literal"><span class="pre">&#64;Swagger</span></code> vào action cần được viết tài liệu.
Xitrum sẽ generate <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/API-Declaration">/xitrum/swagger.json</a>.
Tệp này có thể sử dụng với <a class="reference external" href="https://github.com/wordnik/swagger-ui">Swagger UI</a> để tạo giao diện cho tài liệu của API.</p>
<p>Xitrum đã bao gồm Swagger UI. Sử dụng chúng tại đường dẫn <a href="#id1"><span class="problematic" id="id2">``</span></a>/xitrum/swagger-ui` của chưong trình của bạn.
Ví dụ <a class="reference external" href="http://localhost:8000/xitrum/swagger-ui">http://localhost:8000/xitrum/swagger-ui</a>.</p>
<img alt="_images/swagger.png" src="_images/swagger.png" />
<p>Bạn có thể xem <a class="reference external" href="https://github.com/xitrum-framework/xitrum-placeholder">một ví dụ</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SkipCsrfCheck}
import xitrum.annotation.{GET, Swagger}

@Swagger(
  Swagger.Tags(&quot;image&quot;, &quot;APIs to create images&quot;),
  Swagger.Description(&quot;Dimensions should not be bigger than 2000 x 2000&quot;),
  Swagger.OptStringQuery(&quot;text&quot;, &quot;Text to render on the image, default: Placeholder&quot;),
  Swagger.Produces(&quot;image/png&quot;),
  Swagger.Response(200, &quot;PNG image&quot;),
  Swagger.Response(400, &quot;Width or height is invalid or too big&quot;)
)
trait ImageApi extends Action with SkipCsrfCheck {
  lazy val text = paramo(&quot;text&quot;).getOrElse(&quot;Placeholder&quot;)
}

@GET(&quot;image/:width/:height&quot;)
@Swagger(  // &lt;-- Inherits other info from ImageApi
  Swagger.Summary(&quot;Generate rectangle image&quot;),
  Swagger.IntPath(&quot;width&quot;),
  Swagger.IntPath(&quot;height&quot;)
)
class RectImageApi extends Api {
  def execute {
    val width  = param[Int](&quot;width&quot;)
    val height = param[Int](&quot;height&quot;)
    // ...
  }
}

@GET(&quot;image/:width&quot;)
@Swagger(  // &lt;-- Inherits other info from ImageApi
  Swagger.Summary(&quot;Generate square image&quot;),
  Swagger.IntPath(&quot;width&quot;)
)
class SquareImageApi extends Api {
  def execute {
    val width  = param[Int](&quot;width&quot;)
    // ...
  }
}
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/wordnik/swagger-spec/blob/master/versions/1.2.md">JSON cho Swagger</a> sẽ được tạo khi bạn sử dụng <code class="docutils literal"><span class="pre">/xitrum/swagger</span></code>.</p>
<p>Swagger UI sử dụng JSON dưới đây để tạo giao diện cho tài liệu API.</p>
<p>Ngoài các parameter như Swagger.IntPath và Swagger.OptStringQuery còn các tham số sau: BytePath, IntQuery, OptStringForm etc.
Chúng ta có thể tạo theo mẫu
They are in the form:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;Value</span> <span class="pre">type&gt;&lt;Param</span> <span class="pre">type&gt;</span></code> (required parameter)</li>
<li><code class="docutils literal"><span class="pre">Opt&lt;Value</span> <span class="pre">type&gt;&lt;Param</span> <span class="pre">type&gt;</span></code> (optional parameter)</li>
</ul>
<p>Kiểu dữ liệu: Byte, Int, Int32, Int64, Long, Number, Float, Double, String, Boolean, Date, DateTime</p>
<p>Kiểu tham số: Path, Query, Body, Header, Form</p>
<p>Đọc thêm về <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/Datatypes">kiểu dữ liệu</a> và  <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/Parameters">kiểu tham số</a>.</p>
</div>
</div>
<span id="document-template_engines"></span><div class="section" id="template-engines">
<h2>Template engines<a class="headerlink" href="#template-engines" title="Permalink to this headline">¶</a></h2>
<p>Template engine đã được cấu hình dẽ được gọi khi <a class="reference internal" href="index.html#document-action_view"><em>renderView, renderFragment,
hoặc respondView</em></a> được gọi tới.</p>
<div class="section" id="cau-hinh-template-engine">
<h3>Cấu hình template engine<a class="headerlink" href="#cau-hinh-template-engine" title="Permalink to this headline">¶</a></h3>
<p>Trong tệp <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>, template engine có thể cấu hình theo 2 mẫu dưới dây, phụ thuộc vào engine mà bạn sử dụng:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">template</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">template</span><span class="o">.</span><span class="n">EngineClassName</span>
</pre></div>
</div>
<p>Hoặc:</p>
<div class="highlight-python"><div class="highlight"><pre>template {
  &quot;my.template.EngineClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>Template engine mặc định là <a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a>.</p>
</div>
<div class="section" id="xoa-template-engine">
<h3>Xóa template engine<a class="headerlink" href="#xoa-template-engine" title="Permalink to this headline">¶</a></h3>
<p>Nếu bạn chỉ tạo RESTful APIs trong project, thông thường bạn không sử dụng method renderView, renderFragment, hoặc respondView. Trong trường hợp này, bạn còn có thể xóa template engine khỏi porject để project nhẹ hơn. Bạn chỉ cần xóa hoặc comment dòng <code class="docutils literal"><span class="pre">templateEngine</span></code> trong tệp config/xitrum.conf.</p>
<p>Sau đó bạn xóa các cấu hình template liên quan khỏi project của bạn.</p>
</div>
<div class="section" id="tu-tao-template-engine-cho-rieng-ban">
<h3>Tự tạo template engine cho riêng bạn<a class="headerlink" href="#tu-tao-template-engine-cho-rieng-ban" title="Permalink to this headline">¶</a></h3>
<p>Để tạo template engine cho riêng bạn, tạo một class kế thừa từ <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/view/TemplateEngine.scala">xitrum.view.TemplateEngine</a>.
Và đặt class này của bạn trong tệp config/xitrum.conf.</p>
<p>Ví dụ, xem <a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a>.</p>
</div>
</div>
<span id="document-postback"></span><div class="section" id="postbacks">
<h2>Postbacks<a class="headerlink" href="#postbacks" title="Permalink to this headline">¶</a></h2>
<p>Có 2 use case chính của ứng dụng web:</p>
<ul class="simple">
<li>Để phục vụ các thiết bị: bạn cần tạo các RESTful APIs cho smartphones, web service cho các web site khác.</li>
<li>Để phục vụ các người dùng cuối: bạn cần tạo giao diện web.</li>
</ul>
<p>Như một web framework thông thường, Xitrum hướng tới việc hỗ trợ giải quyết các use case một cách dễ dàng. Để giải quyết use case đầu tiền, bạn sử dụng <a class="reference internal" href="index.html#document-restful"><em>RESTful actions</em></a>. Để giải quyết use case thứ hai, bạn có thể sử dụng tính năng Ajax form postback của Xitrum.
Bạn có thể xem thêm các trang dưới đây để biết thêm về postback:</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Postback">http://en.wikipedia.org/wiki/Postback</a></li>
<li><a class="reference external" href="http://nitrogenproject.com/doc/tutorial.html">http://nitrogenproject.com/doc/tutorial.html</a></li>
</ul>
<p>Tính năng postback của Xitrum có liên hệ tới <a class="reference external" href="http://nitrogenproject.com/">Nitrogen</a>.</p>
<div class="section" id="layout">
<h3>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h3>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="form">
<h3>Form<a class="headerlink" href="#form" title="Permalink to this headline">¶</a></h3>
<p>Articles.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.{GET, POST, First}
import xitrum.validator._

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val id      = param(&quot;id&quot;)
    val article = Article.find(id)
    respondInlineView(
      &lt;h1&gt;{article.title}&lt;/h1&gt;
      &lt;div&gt;{article.body}&lt;/div&gt;
    )
  }
}

@First  // Force this route to be matched before &quot;show&quot;
@GET(&quot;articles/new&quot;)
class ArticlesNew extends AppAction {
  def execute() {
    respondInlineView(
      &lt;form data-postback=&quot;submit&quot; action={url[ArticlesCreate]}&gt;
        &lt;label&gt;Title&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;title&quot; class=&quot;required&quot; /&gt;&lt;br /&gt;

        &lt;label&gt;Body&lt;/label&gt;
        &lt;textarea name=&quot;body&quot; class=&quot;required&quot;&gt;&lt;/textarea&gt;&lt;br /&gt;

        &lt;input type=&quot;submit&quot; value=&quot;Save&quot; /&gt;
      &lt;/form&gt;
    )
  }
}

@POST(&quot;articles&quot;)
class ArticlesCreate extends AppAction {
  def execute() {
    val title   = param(&quot;title&quot;)
    val body    = param(&quot;body&quot;)
    val article = Article.save(title, body)

    flash(&quot;Article has been saved.&quot;)
    jsRedirectTo(show, &quot;id&quot; -&gt; article.id)
  }
}
</pre></div>
</div>
<p>Khi sự kiện <code class="docutils literal"><span class="pre">submit</span></code> của JavaScript trong form xảy ra, form sẽ postback về <code class="docutils literal"><span class="pre">ArticlesCreate</span></code>.</p>
<p>Thuộc tính <code class="docutils literal"><span class="pre">action</span></code> của <code class="docutils literal"><span class="pre">&lt;form&gt;</span></code> được tạo ra. URL được mã hóa hoạt động như một anti-CSRF token.</p>
</div>
<div class="section" id="non-form">
<h3>Non-form<a class="headerlink" href="#non-form" title="Permalink to this headline">¶</a></h3>
<p>Postback có thể được đặt trong bất kỳ phần tử nào, không chỉ là form.</p>
<p>Một ví dụ sử dụng link:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot; data-postback=&quot;click&quot; action={postbackUrl[LogoutAction]}&gt;Logout&lt;/a&gt;
</pre></div>
</div>
<p>Khi click vào link ở trên sẽ tạo ra postback đến LogoutAction.</p>
</div>
<div class="section" id="hop-thoai-xac-nhan">
<h3>Hộp thoại xác nhận<a class="headerlink" href="#hop-thoai-xac-nhan" title="Permalink to this headline">¶</a></h3>
<p>Nếu bạn muốn hiển thị một hộp thoại xác nhận:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot; data-postback=&quot;click&quot;
            action={url[LogoutAction]}
            data-confirm=&quot;Do you want to logout?&quot;&gt;Logout&lt;/a&gt;
</pre></div>
</div>
<p>Nếu người dùng click &#8220;Cancel&#8221;, postback sẽ không được gửi đi.</p>
</div>
<div class="section" id="them-parameter-khac">
<h3>Thêm parameter khác<a class="headerlink" href="#them-parameter-khac" title="Permalink to this headline">¶</a></h3>
<p>Với các form element, bạn có thể thêm <code class="docutils literal"><span class="pre">&lt;input</span> <span class="pre">type=&quot;hidden&quot;...</span></code> để gửi thêm các parameter khác với postback.</p>
<p>Với các element khác, bạn làm như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot;
   data-postback=&quot;click&quot;
   action={url[ArticlesDestroy](&quot;id&quot; -&gt; item.id)}
   data-params=&quot;_method=delete&quot;
   data-confirm={&quot;Do you want to delete %s?&quot;.format(item.name)}&gt;Delete&lt;/a&gt;
</pre></div>
</div>
<p>Bạn cũng có thể thêm các parameter trong một form riêng biệt:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;form id=&quot;myform&quot; data-postback=&quot;submit&quot; action={url[SiteSearch]}&gt;
  Search:
  &lt;input type=&quot;text&quot; name=&quot;keyword&quot; /&gt;

  &lt;a class=&quot;pagination&quot;
     href=&quot;#&quot;
     data-postback=&quot;click&quot;
     data-form=&quot;#myform&quot;
     action={url[SiteSearch](&quot;page&quot; -&gt; page)}&gt;{page}&lt;/a&gt;
&lt;/form&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">#myform</span></code> là một jQuery selector để chọn form có chứa các parameter được thêm vào.</p>
</div>
<div class="section" id="hien-thi-hinh-dong-khi-load-ajax">
<h3>Hiện thị hình động khi load Ajax<a class="headerlink" href="#hien-thi-hinh-dong-khi-load-ajax" title="Permalink to this headline">¶</a></h3>
<p>Nếu bạn muốn hiển thị hình ảnh như thế này khi load Ajax</p>
<img alt="_images/ajax_loading.gif" src="_images/ajax_loading.gif" />
<p>bạn có thể gọi JS snippet này sau khi đã include <code class="docutils literal"><span class="pre">jsDefaults</span></code> (đã include
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a>) trong view template của bạn:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">ajaxLoadingImg</span> <span class="o">=</span> <span class="s">&#39;path/to/your/image&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-xml"></span><div class="section" id="xml">
<h2>XML<a class="headerlink" href="#xml" title="Permalink to this headline">¶</a></h2>
<p>Scala cho phép viết literal XML. Xitrum sử dụng tính năng này như &#8220;template engine&#8221;:</p>
<ul class="simple">
<li>Scala check cú pháp XML khi compile: Các View là typesafe.</li>
<li>Scala tự động bỏ qua XML: Các view ngăn chặn <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a>.</li>
</ul>
<p>Dưới đây là một vài thủ thuật.</p>
<div class="section" id="unescape-xml">
<h3>Unescape XML<a class="headerlink" href="#unescape-xml" title="Permalink to this headline">¶</a></h3>
<p>Sử dụng <code class="docutils literal"><span class="pre">scala.xml.Unparsed</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.xml.Unparsed

&lt;script&gt;
  {Unparsed(&quot;if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);&quot;)}
&lt;/script&gt;
</pre></div>
</div>
<p>hoặc sử dụng <code class="docutils literal"><span class="pre">&lt;xml:unparsed&gt;</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  &lt;xml:unparsed&gt;
    if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);
  &lt;/xml:unparsed&gt;
&lt;/script&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:unparsed&gt;</span></code> sẽ được ẩn đi trong output.</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);
&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="cac-nhom-xml-element">
<h3>Các nhóm XML element<a class="headerlink" href="#cac-nhom-xml-element" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>&lt;div id=&quot;header&quot;&gt;
  {if (loggedIn)
    &lt;xml:group&gt;
      &lt;b&gt;{username}&lt;/b&gt;
      &lt;a href={url[LogoutAction]}&gt;Logout&lt;/a&gt;
    &lt;/xml:group&gt;
  else
    &lt;xml:group&gt;
      &lt;a href={url[LoginAction]}&gt;Login&lt;/a&gt;
      &lt;a href={url[RegisterAction]}&gt;Register&lt;/a&gt;
    &lt;/xml:group&gt;}
&lt;/div&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:group&gt;</span></code> sẽ được ẩn đi trong output, ví dụ khi người dùng thực hiện đăng nhập:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;div id=&quot;header&quot;&gt;
  &lt;b&gt;My username&lt;/b&gt;
  &lt;a href=&quot;/login&quot;&gt;Logout&lt;/a&gt;
&lt;/div&gt;
</pre></div>
</div>
</div>
<div class="section" id="render-xhtml">
<h3>Render XHTML<a class="headerlink" href="#render-xhtml" title="Permalink to this headline">¶</a></h3>
<p>Xitrum tự động render view và layout như XHTML.
Nếu bạn muốn tự render chúng (hiếm khi), chú ý đến các dòng code dưới đây.</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.xml.Xhtml

val br = &lt;br /&gt;
br.toString            // =&gt; &lt;br&gt;&lt;/br&gt;, một vài trình duyệt sẽ render dòng này như 2 thẻ &lt;br /&gt;
Xhtml.toXhtml(&lt;br /&gt;)  // =&gt; &quot;&lt;br /&gt;&quot;
</pre></div>
</div>
</div>
</div>
<span id="document-js"></span><div class="section" id="javascript-and-json">
<h2>JavaScript and JSON<a class="headerlink" href="#javascript-and-json" title="Permalink to this headline">¶</a></h2>
<div class="section" id="javascript">
<h3>JavaScript<a class="headerlink" href="#javascript" title="Permalink to this headline">¶</a></h3>
<p>Xitrum đã inlcude jQuery. Có một vài jsXXX helper.</p>
<div class="section" id="them-cac-doan-javascript-vao-mot-view">
<h4>Thêm các đoạn JavaScript vào một view<a class="headerlink" href="#them-cac-doan-javascript-vao-mot-view" title="Permalink to this headline">¶</a></h4>
<p>Trong action, gọi method <code class="docutils literal"><span class="pre">jsAddToView</span></code> (nhiều lần nếu cần):</p>
<div class="highlight-python"><div class="highlight"><pre>class MyAction extends AppAction {
  def execute() {
    ...
    jsAddToView(&quot;alert(&#39;Hello&#39;)&quot;)
    ...
    jsAddToView(&quot;alert(&#39;Hello again&#39;)&quot;)
    ...
    respondInlineView(&lt;p&gt;My view&lt;/p&gt;)
  }
}
</pre></div>
</div>
<p>Trong layout, gọi method <code class="docutils literal"><span class="pre">jsForView</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;flash&quot;&gt;{jsFlash}&lt;/div&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
</pre></div>
</div>
</div>
<div class="section" id="respond-javascript-truc-tiep-khong-su-dung-view">
<h4>Respond JavaScript trực tiếp không sử dụng view<a class="headerlink" href="#respond-javascript-truc-tiep-khong-su-dung-view" title="Permalink to this headline">¶</a></h4>
<p>Để respond JavaScript:</p>
<div class="highlight-python"><div class="highlight"><pre>jsRespond(&quot;$(&#39;#error&#39;).html(%s)&quot;.format(jsEscape(&lt;p class=&quot;error&quot;&gt;Could not login.&lt;/p&gt;)))
</pre></div>
</div>
<p>Một các trực tiếp:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">jsRedirectTo</span><span class="p">(</span><span class="s">&quot;http://cntt.tv/&quot;</span><span class="p">)</span>
<span class="n">jsRedirectTo</span><span class="p">[</span><span class="n">LoginAction</span><span class="p">]()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="json">
<h3>JSON<a class="headerlink" href="#json" title="Permalink to this headline">¶</a></h3>
<p>Xitrum đã include <a class="reference external" href="https://github.com/json4s/json4s">JSON4S</a>.
Bạn có thể đọc thêm để biết các parse và generate ra JSON.</p>
<p>Để convert từ Scala case object thành JSON string và ngược lại:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri

case class Person(name: String, age: Int, phone: Option[String])
val person1 = Person(&quot;Jack&quot;, 20, None)
val json    = SeriDeseri.toJson(person1)
val person2 = SeriDeseri.fromJson[Person](json)
</pre></div>
</div>
<p>Để respond JSON:</p>
<div class="highlight-python"><div class="highlight"><pre>val scalaData = List(1, 2, 3)  // An example
respondJson(scalaData)
</pre></div>
</div>
<p>JSON cũng thuận tiện cho các tệp cấu hình cần tới các cấu trúc lồng nhau:
Xem <a class="reference internal" href="index.html#document-howto"><em>Load config files</em></a>.</p>
</div>
<div class="section" id="plugin-cho-knockout-js">
<h3>Plugin cho Knockout.js<a class="headerlink" href="#plugin-cho-knockout-js" title="Permalink to this headline">¶</a></h3>
<p>Xem <a class="reference external" href="https://github.com/xitrum-framework/xitrum-ko">https://github.com/xitrum-framework/xitrum-ko</a></p>
</div>
</div>
<span id="document-async"></span><div class="section" id="async-response">
<h2>Async response<a class="headerlink" href="#async-response" title="Permalink to this headline">¶</a></h2>
<p>Danh sách các method responding thông thường:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondView</span></code>: respond tệp view, có hoặc không có layout.</li>
<li><code class="docutils literal"><span class="pre">respondInlineView</span></code>: respond template đã được nhúng(không tách rời các tệp template), có
hoặc không có layout.</li>
<li><code class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></code>: respond một string, không có layout</li>
<li><code class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></code>: như trên, với content type đặt là &#8220;text/html&#8221;</li>
<li><code class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>: convert Scala object thành JSON object sau đó respond</li>
<li><code class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></code>: kết hợp cả 2 method ở trên</li>
<li><code class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondBinary</span></code>: respond một mảng byte</li>
<li><code class="docutils literal"><span class="pre">respondFile</span></code>: send một tệp trực tiếp từ đĩa với tốc độ cao, sử dụng
<a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a>
(aka send-file)</li>
<li><code class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></code></li>
</ul>
<p>Xitrum không tự động gửi bất kỳ response nào.
Bạn phải gọi method <code class="docutils literal"><span class="pre">respondXXX</span></code> ở trên để gửi response.
Nếu bạn không gọi <code class="docutils literal"><span class="pre">respondXXX</span></code>, Xitrum sẽ giữ kết nối HTTP, và bạn có thể
gọi <code class="docutils literal"><span class="pre">respondXXX</span></code> sau.</p>
<p>Để kiểm tra kết nối còn mở hay không, gọi <code class="docutils literal"><span class="pre">channel.isOpen</span></code>.
Bạn cũng có thể sử dụng <code class="docutils literal"><span class="pre">addConnectionClosedListener</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>addConnectionClosedListener {
  // The connection has been closed
  // Unsubscribe from events, release resources etc.
}
</pre></div>
</div>
<p>Vì tính năng async response không được gửi ngay lập tức.
<code class="docutils literal"><span class="pre">respondXXX</span></code> trả về
<a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html">ChannelFuture</a>.
Bạn có thể sử dụng nó để thực hiện action khi response đã thực sự được gửi đi.</p>
<p>Ví dụ, bạn muốn đóng kết nối sau khi response đã được gửi đi:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.channel.{ChannelFuture, ChannelFutureListener}

val future = respondText(&quot;Hello&quot;)
future.addListener(new ChannelFutureListener {
  def operationComplete(future: ChannelFuture) {
    future.getChannel.close()
  }
})
</pre></div>
</div>
<p>hoặc ngắn hơn:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondText</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">addListener</span><span class="p">(</span><span class="n">ChannelFutureListener</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="websocket">
<h3>WebSocket<a class="headerlink" href="#websocket" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import scala.runtime.ScalaRunTime
import xitrum.annotation.WEBSOCKET
import xitrum.{WebSocketAction, WebSocketBinary, WebSocketText, WebSocketPing, WebSocketPong}

@WEBSOCKET(&quot;echo&quot;)
class EchoWebSocketActor extends WebSocketAction {
  def execute() {
    // Here you can extract session data, request headers etc.
    // but do not use respondText, respondView etc.
    // To respond, use respondWebSocketXXX like below.

    log.debug(&quot;onOpen&quot;)

    context.become {
      case WebSocketText(text) =&gt;
        log.info(&quot;onTextMessage: &quot; + text)
        respondWebSocketText(text.toUpperCase)

      case WebSocketBinary(bytes) =&gt;
        log.info(&quot;onBinaryMessage: &quot; + ScalaRunTime.stringOf(bytes))
        respondWebSocketBinary(bytes)

      case WebSocketPing =&gt;
        log.debug(&quot;onPing&quot;)

      case WebSocketPong =&gt;
        log.debug(&quot;onPong&quot;)
    }
  }

  override def postStop() {
    log.debug(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>Một actor sẽ được tạo khi có một request. Actor sẽ được dừng lại khi một trong các điều kiện sau
xảy ra:</p>
<ul class="simple">
<li>Kết nối bị đóng.</li>
<li>WebSocket close frame được nhận hoặc gửi đi</li>
</ul>
<p>Sử dụng các method sau để gửi WebSocket frames:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondWebSocketText</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketBinary</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketPing</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketClose</span></code></li>
</ul>
<p>Không có respondWebSocketPong, vì Xitrum sẽ tự động gửi pong frame
khi nó nhận được ping frame.</p>
<p>Để lấy URL cho WebSocket action ở trên:</p>
<div class="highlight-python"><div class="highlight"><pre>// Probably you want to use this in Scalate view etc.
val url = absWebSocketUrl[EchoWebSocketActor]
</pre></div>
</div>
</div>
<div class="section" id="sockjs">
<h3>SockJS<a class="headerlink" href="#sockjs" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/sockjs/sockjs-client">SockJS</a> là một thư viện trình duyệt
JavaScript cung cấp một WebSocket-like object, dành cho các trình duyệt không hỗ
trợ WebSocket. Đầu tiên SockJS thử sử dụng WebSocket. Nếu không thành công, nó có thể sử dụng một số cách nhưng vẫn đưa về sử dụng WebSocket-like object.</p>
<p>Nếu bạn muốn làm việc với WebSocket API trên mọi trình duyệt, bạn nên sử dụng
SockJS và tránh sử dụng trực tiếp WebSocket directly.</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  var sock = new SockJS(&#39;http://mydomain.com/path_prefix&#39;);
  sock.onopen = function() {
    console.log(&#39;open&#39;);
  };
  sock.onmessage = function(e) {
    console.log(&#39;message&#39;, e.data);
  };
  sock.onclose = function() {
    console.log(&#39;close&#39;);
  };
&lt;/script&gt;
</pre></div>
</div>
<p>Xitrum bao gồm các tệp JavaScript của SockJS.
Trong view template, chỉ cần viết như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>...
html
  head
    != jsDefaults
...
</pre></div>
</div>
<p>SockJS đòi hỏi một <a class="reference external" href="https://github.com/sockjs/sockjs-protocol">server counterpart</a>.
Xitrum sẽ tự động cung cấp.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SockJsAction, SockJsText}
import xitrum.annotation.SOCKJS

@SOCKJS(&quot;echo&quot;)
class EchoSockJsActor extends SockJsAction {
  def execute() {
    // To respond, use respondSockJsXXX like below

    log.info(&quot;onOpen&quot;)

    context.become {
      case SockJsText(text) =&gt;
        log.info(&quot;onMessage: &quot; + text)
        respondSockJsText(text)
    }
  }

  override def postStop() {
    log.info(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>Một actor sẽ được tạo khi có một SockJS session mới. Nó sẽ dừng lại khi SockJS session này
đóng lại.</p>
<p>Sử dụng các method sau để gửi các send SockJS frames:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondSockJsText</span></code></li>
<li><code class="docutils literal"><span class="pre">respondSockJsClose</span></code></li>
</ul>
<p>Xem <a class="reference external" href="https://github.com/sockjs/sockjs-node#various-issues-and-design-considerations">Various issues and design considerations</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>Về cơ bản, cookie không phù hợp với mô hình SockJS. Nếu bạn muốn authorize cho một
session, cũng cấp một token đặc biệt trên một page, gửi chúng như những thứ đầu tiên
qua kết nối SockJS và validate nó ở server. Về cơ bản thì đây là cách thức hoạt động của
cookie
</pre></div>
</div>
<p>Để cấu hình SockJS clustering, xem <a class="reference internal" href="index.html#document-cluster"><em>Clustering với Akka</em></a>.</p>
</div>
<div class="section" id="chunked-response">
<h3>Chunked response<a class="headerlink" href="#chunked-response" title="Permalink to this headline">¶</a></h3>
<p>Để gửi <a class="reference external" href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked response</a>:</p>
<ol class="arabic simple">
<li>Gọi <code class="docutils literal"><span class="pre">setChunked</span></code></li>
<li>Gọi <code class="docutils literal"><span class="pre">respondXXX</span></code> bao nhiêu lần bạn muốn</li>
<li>Cuối cùng, gọi <code class="docutils literal"><span class="pre">respondLastChunk</span></code></li>
</ol>
<p>Chunked response có nhiều use cases. Ví dụ, khi bạn cần generate một tệp CSV lớn hơn bộ nhớ, bạn có thể generate chunk by chunk và gửi chúng khi bạn generate:</p>
<div class="highlight-python"><div class="highlight"><pre>// &quot;Cache-Control&quot; header will be automatically set to:
// &quot;no-store, no-cache, must-revalidate, max-age=0&quot;
//
// Note that &quot;Pragma: no-cache&quot; is linked to requests, not responses:
// http://palizine.plynt.com/issues/2008Jul/cache-control-attributes/
setChunked()

val generator = new MyCsvGenerator

generator.onFirstLine { line =&gt;
  val future = respondText(header, &quot;text/csv&quot;)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) generator.next()
    }
  }
}

generator.onNextLine { line =&gt;
  val future = respondText(line)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) generator.next()
    }
  })
}

generator.onLastLine { line =&gt;
  val future = respondText(line)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) respondLastChunk()
    }
  })
}

generator.generate()
</pre></div>
</div>
<p>Ghi nhớ:</p>
<ul class="simple">
<li>Header được gửi ở lần gọi <code class="docutils literal"><span class="pre">respondXXX</span></code> đầu tiên.</li>
<li>Bạn có thể gửi các optional trailing header tại <code class="docutils literal"><span class="pre">respondLastChunk</span></code></li>
<li><a class="reference internal" href="index.html#document-cache"><em>Page và action cache</em></a> không thế sử dụng với chunked response.</li>
</ul>
<p>Với việc sử dụng chunked response cùng với <code class="docutils literal"><span class="pre">ActorAction</span></code>, bạn có thể dễ dàng implement
<a class="reference external" href="http://www.cubrid.org/blog/dev-platform/faster-web-page-loading-with-facebook-bigpipe/">Facebook BigPipe</a>.</p>
<div class="section" id="forever-iframe">
<h4>Forever iframe<a class="headerlink" href="#forever-iframe" title="Permalink to this headline">¶</a></h4>
<p>Chunked response <a class="reference external" href="http://www.shanison.com/2010/05/10/stop-the-browser-%E2%80%9Cthrobber-of-doom%E2%80%9D-while-loading-comet-forever-iframe/">có thể được sử dụng</a>
cho <a class="reference external" href="http://en.wikipedia.org/wiki/Comet_%28programming%29">Comet</a>.</p>
<p>Page nhúng iframe:</p>
<div class="highlight-python"><div class="highlight"><pre>...
&lt;script&gt;
  var functionForForeverIframeSnippetsToCall = function() {...}
&lt;/script&gt;
...
&lt;iframe width=&quot;1&quot; height=&quot;1&quot; src=&quot;path/to/forever/iframe&quot;&gt;&lt;/iframe&gt;
...
</pre></div>
</div>
<p>Action respond <code class="docutils literal"><span class="pre">&lt;script&gt;</span></code> snippets mãi mãi:</p>
<div class="highlight-python"><div class="highlight"><pre>// Prepare forever iframe

setChunked()

// Need something like &quot;123&quot; for Firefox to work
respondText(&quot;&lt;html&gt;&lt;body&gt;123&quot;, &quot;text/html&quot;)

// Most clients (even curl!) do not execute &lt;script&gt; snippets right away,
// we need to send about 2KB dummy data to bypass this problem
for (i &lt;- 1 to 100) respondText(&quot;&lt;script&gt;&lt;/script&gt;\n&quot;)
</pre></div>
</div>
<p>Sau đo, bất cứ khi nào bạn muốn truyền dữ liệu đến trình duyệt, chỉ cần gửi một snippet:</p>
<div class="highlight-python"><div class="highlight"><pre>if (channel.isOpen)
  respondText(&quot;&lt;script&gt;parent.functionForForeverIframeSnippetsToCall()&lt;/script&gt;\n&quot;)
else
  // The connection has been closed, unsubscribe from events etc.
  // You can also use ``addConnectionClosedListener``.
</pre></div>
</div>
</div>
<div class="section" id="event-source">
<h4>Event Source<a class="headerlink" href="#event-source" title="Permalink to this headline">¶</a></h4>
<p>Xem <a class="reference external" href="http://dev.w3.org/html5/eventsource/">http://dev.w3.org/html5/eventsource/</a></p>
<p>Event Source response là một loại chunked response đặc biệt.
Dữ liệu phải là kiểu UTF-8.</p>
<p>Để respond event source, gọi <code class="docutils literal"><span class="pre">respondEventSource</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>respondEventSource(&quot;data1&quot;, &quot;event1&quot;)  // Event name is &quot;event1&quot;
respondEventSource(&quot;data2&quot;)            // Event name is set to &quot;message&quot; by default
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-static"></span><div class="section" id="cac-tep-tinh">
<h2>Các tệp tĩnh<a class="headerlink" href="#cac-tep-tinh" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cung-cap-cac-tep-tinh-tren-dia">
<h3>Cung cấp các tệp tĩnh trên đĩa<a class="headerlink" href="#cung-cap-cac-tep-tinh-tren-dia" title="Permalink to this headline">¶</a></h3>
<p>Thư mục của dự án:</p>
<div class="highlight-python"><div class="highlight"><pre>config
public
  favicon.ico
  robots.txt
  404.html
  500.html
  img
    myimage.png
  css
    mystyle.css
  js
    myscript.js
src
build.sbt
</pre></div>
</div>
<p>Xitrum tự động cung cấp các tệp tĩnh trong thư mực <code class="docutils literal"><span class="pre">public</span></code>.
URLs đến các tệp này:</p>
<div class="highlight-python"><div class="highlight"><pre>/img/myimage.png
/css/mystyle.css
/css/mystyle.min.css
</pre></div>
</div>
<p>Để dẫn đến chúng:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={publicUrl(&quot;img/myimage.png&quot;)} /&gt;
</pre></div>
</div>
<p>Để cung cấp các tệp thường trong môi trường phát triển và bản rút gọn trong
môi trường của sản phẩm (mystyle.css và mystyle.min.css as above):</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={publicUrl(&quot;css&quot;, &quot;mystyle.css&quot;, &quot;mystyle.min.css&quot;)} /&gt;
</pre></div>
</div>
<p>Để gửi các tệp tĩnh trên đĩa từ action, sử dụng method <code class="docutils literal"><span class="pre">respondFile</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondFile</span><span class="p">(</span><span class="s">&quot;/absolute/path&quot;</span><span class="p">)</span>
<span class="n">respondFile</span><span class="p">(</span><span class="s">&quot;path/relative/to/the/current/working/directory&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Để tối ưu hóa tốc độ cung cấp các tệp tĩnh, bạn có thể bỏ qua các tệp không
cần thiết với bộ lọc regex. Nếu request url không match với pathRegex, Xitrum
sẽ respond lỗi 404 cho request đó.</p>
<p>Xem <code class="docutils literal"><span class="pre">pathRegex</span></code> trong <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
</div>
<div class="section" id="index-html-fallback">
<h3>index.html fallback<a class="headerlink" href="#index-html-fallback" title="Permalink to this headline">¶</a></h3>
<p>Nếu không có route (không có action) cho URL <code class="docutils literal"><span class="pre">/foo/bar</span></code> (hoặc
<code class="docutils literal"><span class="pre">/foo/bar/</span></code>), Xitrum sẽ tìm các tệp tĩnh <code class="docutils literal"><span class="pre">public/foo/bar/index.html</span></code> (năm
trong thư mục <code class="docutils literal"><span class="pre">public</span></code>). Nếu tìm thây tệp, Xitrum sẽ respond nó về cho phía
client.</p>
</div>
<div class="section" id="va-500">
<h3>404 và 500<a class="headerlink" href="#va-500" title="Permalink to this headline">¶</a></h3>
<p>404.html và 500.html trong thư mục <code class="docutils literal"><span class="pre">public</span></code> được sử dụng khi không có route
nào matched và có một lỗi trong quá trình thực thi. Nếu bạn muốn tự kiểm soát
lỗi:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{Error404, Error500}

@Error404
class My404ErrorHandlerAction extends Action {
  def execute() {
    if (isAjax)
      jsRespond(&quot;alert(&quot; + jsEscape(&quot;Not Found&quot;) + &quot;)&quot;)
    else
      renderInlineView(&quot;Not Found&quot;)
  }
}

@Error500
class My500ErrorHandlerAction extends Action {
  def execute() {
    if (isAjax)
      jsRespond(&quot;alert(&quot; + jsEscape(&quot;Internal Server Error&quot;) + &quot;)&quot;)
    else
      renderInlineView(&quot;Internal Server Error&quot;)
  }
}
</pre></div>
</div>
<p>Response status được đặt thành 404 hoặc 500 trước khi action được thực thi, vì
vậy bạn không cần phải đặt chúng một các thủ công.</p>
</div>
<div class="section" id="cung-cap-cac-tep-tai-nguyen-trong-classpath-voi-webjars-convention">
<h3>Cung cấp các tệp tài nguyên trong classpath với WebJars convention<a class="headerlink" href="#cung-cap-cac-tep-tai-nguyen-trong-classpath-voi-webjars-convention" title="Permalink to this headline">¶</a></h3>
<div class="section" id="webjars">
<h4>WebJars<a class="headerlink" href="#webjars" title="Permalink to this headline">¶</a></h4>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>WebJars &lt;<a class="reference external" href="http://www.webjars.org/">http://www.webjars.org/</a>&gt;_ cung cấp rất nhiều các thư viện web mà bạn
<a href="#id3"><span class="problematic" id="id4">`</span></a>có sử dụng trong project.</p>
<p>Ví dụ, nếu bạn muốn sử dụng <a class="reference external" href="http://underscorejs.org/">Underscore.js</a>, khai
báo trong tệp <code class="docutils literal"><span class="pre">build.sbt</span></code> của project như sau:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;org.webjars&quot;</span> <span class="o">%</span> <span class="s">&quot;underscorejs&quot;</span> <span class="o">%</span> <span class="s">&quot;1.6.0-3&quot;</span>
</pre></div>
</div>
<p>Sau đó trong tệp .jade:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">script</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="p">{</span><span class="n">webJarsUrl</span><span class="p">(</span><span class="s">&quot;underscorejs/1.6.0&quot;</span><span class="p">,</span> <span class="s">&quot;underscore.js&quot;</span><span class="p">,</span> <span class="s">&quot;underscore-min.js&quot;</span><span class="p">)})</span>
</pre></div>
</div>
<p>Xitrum sẽ tự động sử dụng <code class="docutils literal"><span class="pre">underscore.js</span></code> cho môi trường phát triển và
<code class="docutils literal"><span class="pre">underscore-min.js</span></code> cho môi trường sản phẩm.</p>
<p>Kết quả như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>/webjars/underscorejs/1.6.0/underscore.js?XOKgP8_KIpqz9yUqZ1aVzw
</pre></div>
</div>
<p>Nếu bạn muốn sử dụng cũng một tệp trong cả 2 môi trường:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">script</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="p">{</span><span class="n">webJarsUrl</span><span class="p">(</span><span class="s">&quot;underscorejs/1.6.0/underscore.js&quot;</span><span class="p">)})</span>
</pre></div>
</div>
<p>Khi thư viện này phụ thuộc vào thư viện kia, SBT sẽ tự động tải các thư viện
liên quan về. Nếu thấy SBT không tải đúng phiên bản (có thể xác nhận bằng cách
chạy lệnh <cite>sbt xitrum-package`</cite> rồi xem các tệp trong thư mục <code class="docutils literal"><span class="pre">target/xitrum/lib</span></code>
được tạo ra), bạn có thể ép SBT dùng đúng phiên bản bạn muốn bằng <code class="docutils literal"><span class="pre">dependencyOverrides</span></code>.
Ví dụ nếu bạn thấy SBT chọn thư viện jQuery phiên bản 2.x, mà bạn lại muốn
dùng phiên bản 1.x để có thể hỗ trợ Internet Explorer 6, 7, hoặc 8, thì có
thể khai báo như sau:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dependencyOverrides</span> <span class="o">+=</span> <span class="s">&quot;org.webjars&quot;</span> <span class="o">%</span> <span class="s">&quot;jquery&quot;</span> <span class="o">%</span> <span class="s">&quot;1.11.3&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="luu-resource-file-trong-tep-jar-voi-webjars-convention">
<h4>Lưu resource file trong tệp .jar với WebJars convention<a class="headerlink" href="#luu-resource-file-trong-tep-jar-voi-webjars-convention" title="Permalink to this headline">¶</a></h4>
<p>Nếu bạn là người phát triển thư viện và muốn cung cấp tệp myimage.png từ thư
viện của bạn, một tệp .jar trong classpath, sau đó lưu myimage.png trong tệp
.jar với <a class="reference external" href="http://www.webjars.org/">WebJars</a> convention, ví dụ:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">META</span><span class="o">-</span><span class="n">INF</span><span class="o">/</span><span class="n">resources</span><span class="o">/</span><span class="n">webjars</span><span class="o">/</span><span class="n">mylib</span><span class="o">/</span><span class="mf">1.0</span><span class="o">/</span><span class="n">myimage</span><span class="o">.</span><span class="n">png</span>
</pre></div>
</div>
<p>Để cung cấp tệp:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={webJarsUrl(&quot;mylib/1.0/myimage.png&quot;)} /&gt;
</pre></div>
</div>
<p>Trong cả môi trường, đường dẫn URL sẽ là:</p>
<div class="highlight-python"><div class="highlight"><pre>/webjars/mylib/1.0/myimage.png?xyz123
</pre></div>
</div>
</div>
<div class="section" id="respond-mot-tep-trong-classpath">
<h4>Respond một tệp trong classpath<a class="headerlink" href="#respond-mot-tep-trong-classpath" title="Permalink to this headline">¶</a></h4>
<p>Để respond một tệp trong một classpath element (một tệp .jar hoặc một thư
mục), kể cả khi tệp không được lưu với <a class="reference external" href="http://www.webjars.org/">WebJars</a>
convention:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;path/relative/to/the/classpath/element&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Ex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;akka/actor/Actor.class&quot;</span><span class="p">)</span>
<span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;META-INF/resources/webjars/underscorejs/1.6.0/underscore.js&quot;</span><span class="p">)</span>
<span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;META-INF/resources/webjars/underscorejs/1.6.0/underscore-min.js&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cache-o-phia-client-voi-etag-va-max-age">
<h3>Cache ở phía client với ETag và max-age<a class="headerlink" href="#cache-o-phia-client-voi-etag-va-max-age" title="Permalink to this headline">¶</a></h3>
<p>Xitrum tự động thêm <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_ETag">Etag</a> cho các tệp
tĩnh trên đĩa và classpath.</p>
<p>ETags sử dụng cho các tệp nhỏ như mã MD5 của file content. Chúng sẽ được cache
để sử dụng sau. Key của cache entry là <code class="docutils literal"><span class="pre">(file</span> <span class="pre">path,</span> <span class="pre">modified</span> <span class="pre">time)</span></code>. Bởi vì
modified time ở các server khác nhau thì khác nhau, nên mỗi web server trong
một cluster (nhóm) sẽ có riêng local ETag cache.</p>
<p>Với các tệp lớn, chỉ khi sửa đổi tệp mới sử dụng Etag. Có vẻ không thực sự
hoàn hảo bởi không thể đồng nhất các tệp trên các server khác nhau vì chúng có
nhiều ETag khác nhau, nhưng nó vẫn tốt hơn là không sử dụng ETag.</p>
<p><code class="docutils literal"><span class="pre">publicUrl</span></code> và <code class="docutils literal"><span class="pre">webJarsUrl</span></code> tự động thêm ETag vào URL khi chúng được generate. Ví dụ:</p>
<div class="highlight-python"><div class="highlight"><pre>webJarsUrl(&quot;jquery/2.1.1/jquery.min.js&quot;)
=&gt; /webjars/jquery/2.1.1/jquery.min.js?0CHJg71ucpG0OlzB-y6-mQ
</pre></div>
</div>
<p>Xitrum cũng đặt <code class="docutils literal"><span class="pre">max-age</span></code> và <code class="docutils literal"><span class="pre">Exprires</span></code> header thành
<a class="reference external" href="https://developers.google.com/speed/docs/best-practices/caching">one year</a>. Bạn không
cần lo lắng rằng trình duyệt không chọn tệp mới nhất khi bạn sửa đổi. Bởi vì khi một tệp
trên ổ đĩa được sửa, thuộc tính <code class="docutils literal"><span class="pre">modified</span> <span class="pre">time</span></code> của tệp đó sẽ thay đổi, do đó URL tạo
ra bởi <code class="docutils literal"><span class="pre">publicUrl</span></code> và <code class="docutils literal"><span class="pre">webJarUrl</span></code> cũng thay đổi theo. ETag cache của tệp cũng sẽ thay
đổi bởi cache key thay đổi.</p>
</div>
<div class="section" id="gzip">
<h3>GZIP<a class="headerlink" href="#gzip" title="Permalink to this headline">¶</a></h3>
<p>Xitrum thực hiện việc nén GZIP tự động. Thuộc tính <code class="docutils literal"><span class="pre">Content-Type</span></code> tại header sẽ cho biết
định dạng của respond là <code class="docutils literal"><span class="pre">text/html</span></code> hay <code class="docutils literal"><span class="pre">xml/application</span></code> v.v.</p>
<p>Xitrum luôn tự động nén GZIP với các tệp tĩnh, nhưng định dạng responses được tùy biến, để
tối ưu hóa, Xitrum chỉ thực hiện GZIP với các response lớn hơn 1KB.</p>
</div>
<div class="section" id="cache-o-phia-server">
<h3>Cache ở phía Server<a class="headerlink" href="#cache-o-phia-server" title="Permalink to this headline">¶</a></h3>
<p>Để hạn chế load tệp từ đĩa, Xitrum cache các tệp tĩnh nhỏ trong bộ nhớ với quy tắc LRU (Lần cuối
sử dụng xa nhất). Xem <code class="docutils literal"><span class="pre">small_static_file_size_in_kb</span></code> và <code class="docutils literal"><span class="pre">max_cached_small_static_files</span></code>
trong <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
</div>
</div>
<span id="document-flash"></span><div class="section" id="cung-cap-flash-socket-policy-file">
<h2>Cung cấp flash socket policy file<a class="headerlink" href="#cung-cap-flash-socket-policy-file" title="Permalink to this headline">¶</a></h2>
<p>Đọc thêm về flash socket policy:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html">http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html</a></li>
<li><a class="reference external" href="http://www.lightsphere.com/dev/articles/flash_socket_policy.html">http://www.lightsphere.com/dev/articles/flash_socket_policy.html</a></li>
</ul>
<p>Giao thức để truyền tệp socket policy khác với giao thức HTTP.
Để gửi:</p>
<ol class="arabic simple">
<li>Sửa tệp <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/flash_socket_policy.xml">config/flash_socket_policy.xml</a> một cách thích hợp</li>
<li>Sửa tệp <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a> để có thể truyền tệp bên trên.</li>
</ol>
</div>
<span id="document-scopes"></span><div class="section" id="scopes">
<h2>Scopes<a class="headerlink" href="#scopes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="request">
<h3>Request<a class="headerlink" href="#request" title="Permalink to this headline">¶</a></h3>
<div class="section" id="cac-loai-parameter">
<h4>Các loại parameter<a class="headerlink" href="#cac-loai-parameter" title="Permalink to this headline">¶</a></h4>
<p>Có 2 loại request parameter: textual parameter và file upload parameter (binary).</p>
<p>Có 3 loại textual parameter, thuộc kiểu <code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Seq[String]]</span></code>:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">queryParams</span></code>: parameter nằm sau dấu ? trong URL ,ví dụ : <a class="reference external" href="http://example.com/blah?x=1&amp;y=2">http://example.com/blah?x=1&amp;y=2</a></li>
<li><code class="docutils literal"><span class="pre">bodyTextParams</span></code>: parameter trong phần body của POST request</li>
<li><code class="docutils literal"><span class="pre">pathParams</span></code>: parameter nhúng trong URL, ví dụ: <code class="docutils literal"><span class="pre">GET(&quot;articles/:id/:title&quot;)</span></code></li>
</ol>
<p>Các parameter được gộp thành kiểu <code class="docutils literal"><span class="pre">textParams</span></code> (từ 1 đến 3, kiểu sau sẽ override kiểu trước).</p>
<p><code class="docutils literal"><span class="pre">bodyFileParams</span></code> thuộc kiểu scala.collection.mutable.Map[String, Seq[<a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/multipart/FileUpload.html">FileUpload</a>]].</p>
</div>
<div class="section" id="accesing-parameter">
<h4>Accesing parameter<a class="headerlink" href="#accesing-parameter" title="Permalink to this headline">¶</a></h4>
<p>Từ một action, bạn có thể truy cập đến các parameter trực tiếp, hoặc bạn có thể
sử dụng các accessor method.</p>
<p>Để truy cập <code class="docutils literal"><span class="pre">textParams</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">param(&quot;x&quot;)</span></code>: trả về <code class="docutils literal"><span class="pre">String</span></code>, throws exception nếu x không tồn tại</li>
<li><code class="docutils literal"><span class="pre">paramo(&quot;x&quot;)</span></code>: trả về <code class="docutils literal"><span class="pre">Option[String]</span></code></li>
<li><code class="docutils literal"><span class="pre">params(&quot;x&quot;)</span></code>: trả về <code class="docutils literal"><span class="pre">Seq[String]</span></code>, Seq.empty nếu x không tồn tại</li>
</ul>
<p>Bạn có thể convert các text parameter thành các kiểu khác như Int, Long, Float, Double
một các tự động bằng cách sử dụng <code class="docutils literal"><span class="pre">param[Int](&quot;x&quot;)</span></code>, <code class="docutils literal"><span class="pre">params[Int](&quot;x&quot;)</span></code> v.v. Để convert
các text parameter thành các kiểu khác, override
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala-2.11/xitrum/scope/request/ParamAccess.scala">convertTextParam</a>.</p>
<p>Với các file upload parameter: <code class="docutils literal"><span class="pre">param[FileUpload](&quot;x&quot;)</span></code>, <code class="docutils literal"><span class="pre">params[FileUpload](&quot;x&quot;)</span></code> v.v.
Để biết chi tiết, hãy xem <a class="reference internal" href="index.html#document-upload"><em>Upload chapter</em></a>.</p>
</div>
<div class="section" id="at">
<h4>&#8220;at&#8221;<a class="headerlink" href="#at" title="Permalink to this headline">¶</a></h4>
<p>Để truyền tham số khi thực hiện một request (từ action đến view hoặc layout), có thể
sử dụng <code class="docutils literal"><span class="pre">at</span></code>. <code class="docutils literal"><span class="pre">at</span></code> thuộc kiểu <code class="docutils literal"><span class="pre">scala.collection.mutable.HashMap[String,</span> <span class="pre">Any]</span></code>.
Nếu bạn từng tiếp xúc với Rails, bạn sẽ nhận ra rằng <code class="docutils literal"><span class="pre">at</span></code> là một bản sao của <code class="docutils literal"><span class="pre">&#64;</span></code>
trong Rails.</p>
<p>Articles.scala</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val (title, body) = ...  // Get from DB
    at(&quot;title&quot;) = title
    respondInlineView(body)
  }
}
</pre></div>
</div>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;{if (at.isDefinedAt(&quot;title&quot;)) &quot;My Site - &quot; + at(&quot;title&quot;) else &quot;My Site&quot;}&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="atjson">
<h4>&#8220;atJson&#8221;<a class="headerlink" href="#atjson" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">atJson</span></code> là một helper method tự động convert <code class="docutils literal"><span class="pre">at(&quot;key&quot;)</span></code> sang JSON.
Nếu bạn chuyển model từ Scala sang JavaScript.</p>
<p><code class="docutils literal"><span class="pre">atJson(&quot;key&quot;)</span></code> tương đương với <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.toJson(at(&quot;key&quot;))</span></code>:</p>
<p>Action.scala</p>
<div class="highlight-python"><div class="highlight"><pre>case class User(login: String, name: String)

...

def execute() {
  at(&quot;user&quot;) = User(&quot;admin&quot;, &quot;Admin&quot;)
  respondView()
}
</pre></div>
</div>
<p>Action.ssp</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script type=&quot;text/javascript&quot;&gt;
  var user = ${atJson(&quot;user&quot;)};
  alert(user.login);
  alert(user.name);
&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="requestvar">
<h4>RequestVar<a class="headerlink" href="#requestvar" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">at</span></code> không typesafe bởi vì bạn có thể đặt mọi thứ vào trong map. Để typesafe
hơn, bạn nên sử dụng RequestVar một class đóng gói <code class="docutils literal"><span class="pre">at</span></code>.</p>
<p>RVar.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.RequestVar

object RVar {
  object title extends RequestVar[String]
}
</pre></div>
</div>
<p>Articles.scala</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val (title, body) = ...  // Get from DB
    RVar.title.set(title)
    respondInlineView(body)
  }
}
</pre></div>
</div>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;{if (RVar.title.isDefined) &quot;My Site - &quot; + RVar.title.get else &quot;My Site&quot;}&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="cookie">
<h3>Cookie<a class="headerlink" href="#cookie" title="Permalink to this headline">¶</a></h3>
<p>Bạn có thể đọc thêm Wikipedia về <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie">cookies</a>.</p>
<p>Trong một action, sử dụng <code class="docutils literal"><span class="pre">requestCookies</span></code>, <code class="docutils literal"><span class="pre">Map[String,</span> <span class="pre">String]</span></code>, để đọc cookie
gửi bởi browser.</p>
<div class="highlight-python"><div class="highlight"><pre>requestCookies.get(&quot;myCookie&quot;) match {
  case None         =&gt; ...
  case Some(string) =&gt; ...
}
</pre></div>
</div>
<p>Để gửi cookie đến browser, tạo một <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/DefaultCookie.html">DefaultCookie</a>
và thêm nó vào <code class="docutils literal"><span class="pre">responseCookies</span></code>, một <code class="docutils literal"><span class="pre">ArrayBuffer</span></code> đã bao gồm <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/Cookie.html">Cookie</a>.</p>
<div class="highlight-python"><div class="highlight"><pre>val cookie = new DefaultCookie(&quot;name&quot;, &quot;value&quot;)
cookie.setHttpOnly(true)  // true: JavaScript cannot access this cookie
responseCookies.append(cookie)
</pre></div>
</div>
<p>Nếu bạn không set path của cookie bằng cách gọi <code class="docutils literal"><span class="pre">cookie.setPath(cookiePath)</span></code>,
đường path của nó sẽ được gán là root path của site (<code class="docutils literal"><span class="pre">xitrum.Config.withBaseUrl(&quot;/&quot;)</span></code>).
Việc này đề phòng việc trùng lặp cookie.</p>
<p>Để xóa cookie gửi bởi browser, gửi một cookie trùng tên và đặt max age của
cookie này là 0. Browser sẽ giải phóng cookie này ngay lập tức. Để báo với browser
xóa cookie khi tắt browser, đặt max age thành <code class="docutils literal"><span class="pre">Long.MinValue</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cookie</span><span class="o">.</span><span class="n">setMaxAge</span><span class="p">(</span><span class="n">Long</span><span class="o">.</span><span class="n">MinValue</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference external" href="http://mrcoles.com/blog/cookies-max-age-vs-expires/">Internet Explorer không hỗ trợ &#8220;max-age&#8221;</a>,
nhưng Netty có thể nhận diện và xuất ra &#8220;max-age&#8221; hoặc &#8220;expires&#8221; một cách chính xác. Don&#8217;t worry!</p>
<p>Browser sẽ không gửi các cookie attribute ngược trở lại server. Browser
sẽ <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie#Cookie_attributes">only send the cookie name-value pairs</a>.</p>
<p>Nếu bạn muốn ngăn chặn các người dùng khác giả mạo cookie, sử dụng
<code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.toSecureUrlSafeBase64</span></code> và <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.fromSecureUrlSafeBase64</span></code>.
Để biết thêm thông tin, xem <a class="reference internal" href="index.html#document-howto"><em>How to encrypt data</em></a>.</p>
<div class="section" id="su-dung-ki-tu-trong-cookie">
<h4>Sử dụng kí tự trong cookie<a class="headerlink" href="#su-dung-ki-tu-trong-cookie" title="Permalink to this headline">¶</a></h4>
<p>Bạn không thế sử dụng
<a class="reference external" href="http://stackoverflow.com/questions/1969232/allowed-characters-in-cookies">các ký tự động trong cookie</a>.
Ví dụ, nếu bạn muốn sử dụng kí tự UTF-8, bạn cần phải encode, bằng cách sử
dụng <code class="docutils literal"><span class="pre">xitrum.utill.UrlSafeBase64</span></code> hoặc <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri</span></code>.</p>
<p>Viết cookie:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.util.CharsetUtil
import xitrum.util.UrlSafeBase64

val value   = &quot;&quot;&quot;{&quot;identity&quot;:&quot;example@gmail.com&quot;,&quot;first_name&quot;:&quot;Alexander&quot;}&quot;&quot;&quot;
val encoded = UrlSafeBase64.noPaddingEncode(value.getBytes(CharsetUtil.UTF_8))
val cookie  = new DefaultCookie(&quot;profile&quot;, encoded)
responseCookies.append(cookie)
</pre></div>
</div>
<p>Đọc cookie:</p>
<div class="highlight-python"><div class="highlight"><pre>requestCookies.get(&quot;profile&quot;).foreach { encoded =&gt;
  UrlSafeBase64.autoPaddingDecode(encoded).foreach { bytes =&gt;
    val value = new String(bytes, CharsetUtil.UTF_8)
    println(&quot;profile: &quot; + value)
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="session">
<h3>Session<a class="headerlink" href="#session" title="Permalink to this headline">¶</a></h3>
<p>Xitrum tự động quản lý Session bao gồm lưu trữ, trả về dữ liệu, mã hóa, v.v.
Bạn không cần phải bận tâm đến Session.</p>
<p>Trong action, bạn có thể sử dụng action <code class="docutils literal"><span class="pre">session</span></code>, một instance
<code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Any]</span></code>. Mọi thứ lưu trữ trong <code class="docutils literal"><span class="pre">session</span></code>
phải serializable.</p>
<p>Ví dụ, để đánh dấu một người dùng đã đăng nhập, bạn có để đặt username của người
dùng vào session:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">session</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">userId</span>
</pre></div>
</div>
<p>Sau đó, nếu bạn muốn kiểm tra người dùng đã đăng nhập hay chưa, chỉ cần kiểm tra
đã có username trong session hay chưa:</p>
<div class="highlight-python"><div class="highlight"><pre>if (session.isDefinedAt(&quot;userId&quot;)) println(&quot;This user has logged in&quot;)
</pre></div>
</div>
<p>Lưu trữ user ID và lấy thông tin người dùng từ database mỗi lần truy cập thường
được sử dụng hơn, Cách này bạn có thể biết được thông tin người dùng đã được cập
nhất (bao gồm quyền và xác thực) ở mỗi lần truy cập.</p>
<div class="section" id="session-clear">
<h4>session.clear()<a class="headerlink" href="#session-clear" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://guides.rubyonrails.org/security.html#session-fixation">Với một dòng mã bạn có thể bảo vệ ứng xụng khỏi session fixation</a>.</p>
<p>Hãy đọc link trên đây để biết thêm về session fixation. Để ngăn chặn tấn công
bằng session fixation, trong action cho phép người dùng đăng nhập, gọi method
<code class="docutils literal"><span class="pre">session.clear()</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;login&quot;)
class LoginAction extends Action {
  def execute() {
    ...
    session.clear()  // Reset first before doing anything else with the session
    session(&quot;userId&quot;) = userId
  }
}
</pre></div>
</div>
<p>Để thực hiện đăng xuất, cũng gọi method <code class="docutils literal"><span class="pre">session.clear()</span></code>.</p>
</div>
<div class="section" id="sessionvar">
<h4>SessionVar<a class="headerlink" href="#sessionvar" title="Permalink to this headline">¶</a></h4>
<p>SessionVar, giống như RequestVar, là một cách làm cho session typesafe hơn.</p>
<p>Lấy một ví dụ, bạn muốn lưu trữ username vào session sau khi thực hiện đăng
nhập:</p>
<p>Khai báo session var:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.SessionVar

object SVar {
  object username extends SessionVar[String]
}
</pre></div>
</div>
<p>Sau khi đăng nhập thành công:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SVar</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
</pre></div>
</div>
<p>Hiển thị username:</p>
<div class="highlight-python"><div class="highlight"><pre>if (SVar.username.isDefined)
  &lt;em&gt;{SVar.username.get}&lt;/em&gt;
else
  &lt;a href={url[LoginAction]}&gt;Login&lt;/a&gt;
</pre></div>
</div>
<ul class="simple">
<li>Để xóa session var: <code class="docutils literal"><span class="pre">SVar.username.remove()</span></code></li>
<li>Để reset toàn bộ session: <code class="docutils literal"><span class="pre">session.clear()</span></code></li>
</ul>
</div>
<div class="section" id="luu-tru-session">
<h4>Lưu trữ session<a class="headerlink" href="#luu-tru-session" title="Permalink to this headline">¶</a></h4>
<p>Xitrum cung cấp 3 cách lưu trữ session.
Trong tệp <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>
bạn có thể chọn các lưu trữ bạn muốn:</p>
<p>CookieSessionStore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Store sessions on client side</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">xitrum</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">CookieSessionStore</span>
</pre></div>
</div>
<p>LruSessionStore:</p>
<div class="highlight-python"><div class="highlight"><pre># Simple in-memory server side session store
store {
  &quot;xitrum.local.LruSessionStore&quot; {
    maxElems = 10000
  }
}
</pre></div>
</div>
<p>Nếu bạn chạy một cụm nhiều máy chr, bạn có thể
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">sử dụng Hazelcast để lưu trữ cluster-aware session</a>,</p>
<p>Lưu ý rằng khi bạn sử dụng CookieSessionStore hoặc Hazelcast, dữ liệu trong session
phải được serializable. Nếu bạn phải lưu trữ những thứ unserializable, sử dụng
LruSessionStore. Nếu bạn sử dụng LruSessionStore và vẫn muốn chạy một cụm nhiều
máy chủ, bạn phải sử dụng load balancer có hỗ trợ sticky sessions.</p>
<p>3 cách lưu trữ session trên đây đủ sử dụng trong các trường hợp thông thường.
Nếu bạn có một trường hợp đặc biệt và muốn sử dụng cách lưu trữ session riêng,
kế thừa
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/scope/session/SessionStore.scala">SessionStore</a>
hoặc
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/scope/session/ServerSessionStore.scala">ServerSessionStore</a>
và implement các abstract method.</p>
<p>Việc cấu hình có thể sử dụng một trong 2 cách:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">store</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">StoreClassName</span>
</pre></div>
</div>
<p>Hoặc:</p>
<div class="highlight-python"><div class="highlight"><pre>store {
  &quot;my.session.StoreClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>Lưu trữ session ở cookie của client bất cứ khi nào có thể (serializable và
<a class="reference external" href="http://stackoverflow.com/questions/640938/what-is-the-maximum-size-of-a-web-browsers-cookies-key">nhỏ hơn 4KB dữ liệu</a>), it&#8217;s more scalable.
Lưu trữ session ở phía server (trong bộ nhớ hoặc Database) chỉ khi cần thiết.</p>
<p>Good read:
<a class="reference external" href="http://www.technicalinfo.net/papers/WebBasedSessionManagement.html">Web Based Session Management - Best practices in managing HTTP-based client sessions</a>.</p>
</div>
<div class="section" id="luu-tru-session-o-client-hay-server">
<h4>Lưu trữ Session ở Client hay Server<a class="headerlink" href="#luu-tru-session-o-client-hay-server" title="Permalink to this headline">¶</a></h4>
<p>Có 2 hình thức lưu trữ session:</p>
<ul class="simple">
<li>Chỉ ở phía client</li>
<li>Kết hợp cả 2 : client và server</li>
</ul>
<p>Với chỉ lưu trữ ở client:</p>
<ul class="simple">
<li>Dữ liệu trong session được lưu trữ trong cookie mã hóa ở phía client.</li>
<li>Phía server không cần phải lưu trữ bất cứ thứ gì.</li>
<li>Khi có một request truyền tới, server sẽ tiến hành giải mã dữ liệu.</li>
</ul>
<p>Kết hợp cả 2 : client và server:</p>
<ul class="simple">
<li>Một session có 2 phần: session ID và session data.</li>
<li>Server lưu trữ dữ liệu trong session, theo cặp ID -&gt; data</li>
<li>ID cũng được lưu trữ trong cookie đã được mã hóa ở client.</li>
<li>Khi có một request truyền tới, server sẽ giải mã ID, và sử dụng ID để tìm data</li>
<li>Các này giống như sử dụng thẻ tín dụng. Số tiền không lưu trong thẻ tín dụng mà</li>
</ul>
<p>ở ID</p>
<p>Trong cả 2 cách, client phải lưu trữ một vài thứ như cookie (dữ liệu được mã hóa
và ID được mã hóa). &#8220;Lưu trữ session ở server&#8221; có nghĩa là lưu trữ dữ liệu của
session ở phía server.</p>
</div>
</div>
<div class="section" id="object-vs-val">
<h3>object vs. val<a class="headerlink" href="#object-vs-val" title="Permalink to this headline">¶</a></h3>
<p>Sử dụng <code class="docutils literal"><span class="pre">object</span></code> thay vì <code class="docutils literal"><span class="pre">val</span></code>.</p>
<p><strong>Không làm như sau</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre>object RVar {
  val title    = new RequestVar[String]
  val category = new RequestVar[String]
}

object SVar {
  val username = new SessionVar[String]
  val isAdmin  = new SessionVar[Boolean]
}
</pre></div>
</div>
<p>Đoạn code trên là đúng cú pháp và sẽ được biên dịch nhưng không chạy, bởi vì các
Var bản thân chúng sử dụng class nameđể tìm kiếm. Khi sử dụng <code class="docutils literal"><span class="pre">val</span></code>, <code class="docutils literal"><span class="pre">title</span></code>
và <code class="docutils literal"><span class="pre">category</span></code> sẽ có chung class name &#8220;xitrum.RequestVar&#8221;. Tương tự với <code class="docutils literal"><span class="pre">username</span></code>
và <code class="docutils literal"><span class="pre">isAdmin</span></code>.</p>
</div>
</div>
<span id="document-validation"></span><div class="section" id="validation">
<h2>Validation<a class="headerlink" href="#validation" title="Permalink to this headline">¶</a></h2>
<p>Xitrum sử dụng <a class="reference external" href="http://bassistance.de/jquery-plugins/jquery-plugin-validation/">jQuery Validation plugin</a>
vào mục đích validation ở phía client và cung cấp các validation helper cho phía server.</p>
<div class="section" id="validator-mac-dinh">
<h3>Validator mặc định<a class="headerlink" href="#validator-mac-dinh" title="Permalink to this headline">¶</a></h3>
<p>Xitrum cung cấp validator trong package <code class="docutils literal"><span class="pre">xitrum.validator</span></code>.
Chúng có những method sau:</p>
<div class="highlight-python"><div class="highlight"><pre>check(value): Boolean
message(name, value): Option[String]
exception(name, value)
</pre></div>
</div>
<p>Nếu validation báo lỗi, <code class="docutils literal"><span class="pre">message</span></code> sẽ trả về <code class="docutils literal"><span class="pre">Some(error</span> <span class="pre">message)</span></code>,
<code class="docutils literal"><span class="pre">exception</span></code> sẽ throw <code class="docutils literal"><span class="pre">xitrum.exception.InvalidInput(error</span> <span class="pre">message)</span></code>.</p>
<p>Bạn có thể sử dụng validator bất cứ đâu.</p>
<p>Ví dụ action:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.validator.Required

@POST(&quot;articles&quot;)
class CreateArticle {
  def execute() {
    val title = param(&quot;tite&quot;)
    val body  = param(&quot;body&quot;)
    Required.exception(&quot;Title&quot;, title)
    Required.exception(&quot;Body&quot;,  body)

    // Do with the valid title and body...
  }
}
</pre></div>
</div>
<p>Nếu không sử dụng <code class="docutils literal"><span class="pre">try</span></code> và <code class="docutils literal"><span class="pre">catch</span></code>, khi có lỗi trong quá trình validation
(not pass), Xitrum sẽ tự động <code class="docutils literal"><span class="pre">catch</span></code> các exception và respond thông báo lỗi
về phía client. Điều này giúp cho việc viết các web API hoặc sử dụng validation
ở phía client dễ dàng hơn.</p>
<p>Model example:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.validator.Required

case class Article(id: Int = 0, title: String = &quot;&quot;, body: String = &quot;&quot;) {
  def isValid           = Required.check(title)   &amp;&amp;     Required.check(body)
  def validationMessage = Required.message(title) orElse Required.message(body)
}
</pre></div>
</div>
<p>Xem <a class="reference external" href="https://github.com/xitrum-framework/xitrum/tree/master/src/main/scala/xitrum/validator">package xitrum.validator</a> để có đầy đủ các validator mặc định.</p>
</div>
<div class="section" id="tao-mot-validator">
<h3>Tạo một validator<a class="headerlink" href="#tao-mot-validator" title="Permalink to this headline">¶</a></h3>
<p>Kế thừa <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/validator/Validator.scala">xitrum.validator.Validator</a>.
Bạn chỉ phải implement 2 method <code class="docutils literal"><span class="pre">check</span></code> và <code class="docutils literal"><span class="pre">message</span></code>.</p>
<p>Bạn cũng có thể sử dụng <a class="reference external" href="http://commons.apache.org/proper/commons-validator/">Commons Validator</a>.</p>
</div>
</div>
<span id="document-upload"></span><div class="section" id="tai-len-tep">
<h2>Tải lên tệp<a class="headerlink" href="#tai-len-tep" title="Permalink to this headline">¶</a></h2>
<p>Xem thêm <a class="reference internal" href="index.html#document-scopes"><em>Scopes chapter</em></a>.</p>
<p>Trong form tải lên (upload form), bạn cần đặt <code class="docutils literal"><span class="pre">enctype</span></code> thành <code class="docutils literal"><span class="pre">multipart/form-data</span></code>.</p>
<p>MyUpload.scalate:</p>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[MyUpload]} enctype=&quot;multipart/form-data&quot;)
  != antiCsrfInput

  label Please select a file:
  input(type=&quot;file&quot; name=&quot;myFile&quot;)

  button(type=&quot;submit&quot;) Upload
</pre></div>
</div>
<p>Trong <code class="docutils literal"><span class="pre">MyUpload</span></code> action:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.handler.codec.http.multipart.FileUpload

val myFile = param[FileUpload](&quot;myFile&quot;)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">myFile</span></code> là một instance của <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/multipart/FileUpload.html">FileUpload</a>.
Sử dụng các method của chúng để lấy tên tệp, di chuyển tệp vào một thư mục v.v.</p>
<p>Các tệp nhỏ (nhỏ hơn 16 KB) sẽ được lưu trong bộ nhớ. Các tệp lớn thường được lưu
trong hệ thống thư mục lưu trữ tạm (hoặc một thư mục xác định bởi <code class="docutils literal"><span class="pre">xitrum.request.tmpUploadDir</span></code>
trong xitrum.conf), và sẽ được xóa tự động khi đóng kết nối hoặc một respond được
gửi đi.</p>
<div class="section" id="ajax-style-upload">
<h3>Ajax style upload<a class="headerlink" href="#ajax-style-upload" title="Permalink to this headline">¶</a></h3>
<p>Có rất nhiều thư viện JavaScript hỗ trợ tải lên Ajax style. Chúng sử dụng iframe
ẩn hoặc Flash để gửi <code class="docutils literal"><span class="pre">multipart/form-data</span></code> ở bên trên đến server.
Nếu bạn không chắc chắn parameter nào của request trong thư viện sử dụng trong form
để gửi tệp, hãy xem Xitrum access log.</p>
</div>
</div>
<span id="document-filter"></span><div class="section" id="bo-loc-filter-trong-action">
<h2>Bộ lọc (filter) trong Action<a class="headerlink" href="#bo-loc-filter-trong-action" title="Permalink to this headline">¶</a></h2>
<div class="section" id="before-filters">
<h3>Before filters<a class="headerlink" href="#before-filters" title="Permalink to this headline">¶</a></h3>
<p>Before filters chạy trước khi action chạy.
Nếu một before filter respond bất kì thứ gì, tất cả các filter sau đó và cả action
sẽ không chạy.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;before_filter&quot;)
class MyAction extends Action {
  beforeFilter {
    log.info(&quot;I run therefore I am&quot;)
  }

  // Method này chạy sau filter bên trên
  def execute() {
    respondInlineView(&quot;Before filters should have been run, please check the log&quot;)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="after-filters">
<h3>After filters<a class="headerlink" href="#after-filters" title="Permalink to this headline">¶</a></h3>
<p>Before filters chạy sau khi action chạy.
Chúng là các hàm (function) không tham số. Các giá trị trả về của các hàm này
sẽ bị từ chối.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;after_filter&quot;)
class MyAction extends Action {
  afterFilter {
    log.info(&quot;Run at &quot; + System.currentTimeMillis())
  }

  def execute() {
    respondText(&quot;After filter should have been run, please check the log&quot;)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="around-filters">
<h3>Around filters<a class="headerlink" href="#around-filters" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;around_filter&quot;)
class MyAction extends Action {
  aroundFilter { action =&gt;
    val begin = System.currentTimeMillis()
    action()
    val end   = System.currentTimeMillis()
    val dt    = end - begin
    log.info(s&quot;The action took $dt [ms]&quot;)
  }

  def execute() {
    respondText(&quot;Around filter should have been run, please check the log&quot;)
  }
}
</pre></div>
</div>
<p>Nếu có nhiều around filter, chúng sẽ lồng nhau.</p>
</div>
<div class="section" id="thu-tu-thuc-hien-cua-cac-bo-loc-filter">
<h3>Thứ tự thực hiện của các bộ lọc (filter)<a class="headerlink" href="#thu-tu-thuc-hien-cua-cac-bo-loc-filter" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Before filters được chạy đầu tiên, sau đó là  around filter, cuối cùng là after
filter.</li>
<li>Néu một trong nhưng before filter trả về false, các filter con lại ( bao gồm
around và after filter) sẽ không được chạy.</li>
<li>After filters luôn được chạy nếu ít nhát có một around filter được chạy.</li>
<li>Nếu một around filter không gọi <code class="docutils literal"><span class="pre">action</span></code>, các around filter lồng bên trong
filter này sẽ không được chạy.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>before1 -true-&gt; before2 -true-&gt; +--------------------+ --&gt; after1 --&gt; after2
                                | around1 (1 of 2)   |
                                |   around2 (1 of 2) |
                                |     action         |
                                |   around2 (2 of 2) |
                                | around1 (2 of 2)   |
                                +--------------------+
</pre></div>
</div>
</div>
</div>
<span id="document-cache"></span><div class="section" id="cache-o-server">
<h2>Cache ở server<a class="headerlink" href="#cache-o-server" title="Permalink to this headline">¶</a></h2>
<p>Cũng có thể xem phần nói về <a class="reference internal" href="index.html#document-cluster"><em>clustering</em></a>.</p>
<p>Tối ưu hóa cache cả ở phía máy chủ (server) và máy khách (client) để tăng tốc độ đáp ứng.
Ở tầng máy chủ web, các tập tin nhỏ được cache vào bộ nhớ, đối với các tập tin lớn thì sử dụng kỹ thuật
zero copy của NIO. . Các tệp tĩnh trong xitrum được
cung cấp với tốc độ <a class="reference external" href="https://gist.github.com/3293596">tương đương với Nginx</a>.
Tại lớp web framework, bạn có thể khai báo cache ở mức page, action và object với
phong cách <a class="reference external" href="https://github.com/rails/rails">Rails framework</a>.</p>
<p><a class="reference external" href="http://code.google.com/speed/page-speed/docs/rules_intro.html">Tất cả thủ thuật mà Google khuyên nên dùng để tăng tốc trang web</a>
như method GET có điều kiện được áp dụng để cache phía client.</p>
<p>Với các nội dung động (dynamic content), nếu content không đổi sau khi được tạo
(như một tệp tĩnh), bạn có thể cần đặt header để được lưu trữ một cách chủ động
ở phía client. Trong trường hợp này, sử dụng <code class="docutils literal"><span class="pre">setClientCacheAggressively()</span></code> trong
Action.</p>
<p>Ngược lại, đôi khi bạn có thể không muốn cache ở phía client, bạn sử dụng method
<code class="docutils literal"><span class="pre">setNoClientCache()</span></code> trong action.</p>
<p>Cache ở phía server sẽ được trình bày chi tiết dưới dây.</p>
<div class="section" id="cache-o-muc-page-hoac-action">
<h3>Cache ở mức page hoặc action<a class="headerlink" href="#cache-o-muc-page-hoac-action" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{GET, CacheActionMinute, CachePageMinute}

@GET(&quot;articles&quot;)
@CachePageMinute(1)
class ArticlesIndex extends Action {
  def execute() {
    ...
  }
}

@GET(&quot;articles/:id&quot;)
@CacheActionMinute(1)
class ArticlesShow extends Action {
  def execute() {
    ...
  }
}
</pre></div>
</div>
<p>Thuật ngữ &#8220;page cache&#8221; và &#8220;action cache&#8221; bắt nguồn từ
<a class="reference external" href="http://guides.rubyonrails.org/caching_with_rails.html">Ruby on Rails</a>.</p>
<p>Thứ tự thực thi một request được thiết kế như sa:
(1) request -&gt; (2) các method before filter -&gt; (3) các method thực thi action -&gt; (4) response</p>
<p>Ở request đầu tiên, Xitrum sẽ cache response trong một thời gian sống xác đinh.
<code class="docutils literal"><span class="pre">&#64;CachePageMinute(1)</span></code> hoặc <code class="docutils literal"><span class="pre">&#64;CacheActionMinute(1)</span></code> đều có nghĩa là cache
trong 1 phút.
Xitrum chỉ cache khi response có trạng thái &#8220;200 OK&#8221;. Ví dụ, response với trạng
thái &#8220;500 Internal Server Error&#8221; hoặc &#8220;302 Found&#8221; (direct) sẽ không được cache.</p>
<p>Ở các request sau đến cùng một action, nếu response đã được cache vẫn nằm trong thời
gian sống xác định bên trên, Xitrum sẽ chỉ respond chính response đã được cache.</p>
<ul class="simple">
<li>Với page cache, thứ tự thực hiện là (1) -&gt; (4).</li>
<li>Với action cache, thứ tự thực hiện là (1) -&gt; (2) -&gt; (4), hoặc chỉ là (1) -&gt; (2)
nếu một trong những before filter trả về &#8220;false&#8221;.</li>
</ul>
<p>Sự khác biệt giữa 2 loại cache: với page cache, các before filter sẽ không chạy.</p>
<p>Thông tường, page cache thường được sử dụng khi các response giống nhau được gửi
đến tất cả người dùng.
Action cache được sử dụng khi bạn muốn chạy một before filter để &#8220;guard&#8221; (bảo vệ)
response đã được cache, giống như việc kiểm ra người dùng đã đăng nhập hay chưa:</p>
<ul class="simple">
<li>Nếu người dùng đã đăng nhập, họ có thể sử dụng response đã được cache.</li>
<li>Nếu người dùng chưa thực hiện đăng nhập, redirect họ đến trang đăng nhập.</li>
</ul>
</div>
<div class="section" id="cache-o-muc-object">
<h3>Cache ở mức object<a class="headerlink" href="#cache-o-muc-object" title="Permalink to this headline">¶</a></h3>
<p>Bạn sử dụng method trong <code class="docutils literal"><span class="pre">xitrum.Config.xitrum.cache</span></code>, nó là một instance của
<a class="reference external" href="http://xitrum-framework.github.io/api/3.17/index.html#xitrum.Cache">xitrum.Cache</a>.</p>
<p>Không có một TTL(time to live - thời gian sống) rõ rõ ràng:</p>
<ul class="simple">
<li>put(key, value)</li>
</ul>
<p>Với một TTL(time to live - thời gian sống) rõ rõ ràng:</p>
<ul class="simple">
<li>putSecond(key, value, seconds)</li>
<li>putMinute(key, value, minutes)</li>
<li>putHour(key, value, hours)</li>
<li>putDay(key, value, days)</li>
</ul>
<p>Only if absent:</p>
<ul class="simple">
<li>putIfAbsent(key, value)</li>
<li>putIfAbsentSecond(key, value, seconds)</li>
<li>putIfAbsentMinute(key, value, minutes)</li>
<li>putIfAbsentHour(key, value, hours)</li>
<li>putIfAbsentDay(key, value, days)</li>
</ul>
</div>
<div class="section" id="xoa-cache">
<h3>Xóa cache<a class="headerlink" href="#xoa-cache" title="Permalink to this headline">¶</a></h3>
<p>Xóa &#8220;page cache&#8221; và &#8220;action cache&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">removeAction</span><span class="p">[</span><span class="n">MyAction</span><span class="p">]</span>
</pre></div>
</div>
<p>Xóa &#8220;object cache&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>Xóa tất cả các khóa bắt đầu với một prefix:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">removePrefix</span><span class="p">(</span><span class="n">keyPrefix</span><span class="p">)</span>
</pre></div>
</div>
<p>Với <code class="docutils literal"><span class="pre">removePrefix</span></code>, bạn có thể kế thừa form cache trong prefix.
Ví dụ bạn muốn cache những thứ liên quan đến một article, sau khi article thay đổi,
bạn muốn xóa tất cả những thứ đó.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Config.xitrum.cache

// Cache với một prefix
val prefix = &quot;articles/&quot; + article.id
cache.put(prefix + &quot;/likes&quot;, likes)
cache.put(prefix + &quot;/comments&quot;, comments)

// Sau đó, khi xảy ra 1 sự kiện nào đó, và bạn muốn xóa tất cả các cache liên
//quan đến artical
cache.remove(prefix)
</pre></div>
</div>
</div>
<div class="section" id="config">
<h3>Config<a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h3>
<p>Tính năng cache trong Xitrum được cung cấp bởi các cache engine. Bạn có thể chọn
engine phù hợp với yếu cầu của bạn.</p>
<p>Trong <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>,
bạn có thể cấu hình cache engine tại 1 trong 2 form sau, phụ thuộc vào engine bạn
chọn:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cache</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">EngineClassName</span>
</pre></div>
</div>
<p>Or:</p>
<div class="highlight-python"><div class="highlight"><pre>cache {
  &quot;my.cache.EngineClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>Xitrum cung cấp:</p>
<div class="highlight-python"><div class="highlight"><pre>cache {
  # Simple in-memory cache
  &quot;xitrum.local.LruCache&quot; {
    maxElems = 10000
  }
}
</pre></div>
</div>
<p>Nếu bạn có một cụm máy chủ, bạn có thể sử dụng <a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast</a>.</p>
<p>Nếu bạn muốn tạo cache engine cho riêng bạn, implement
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Cache.scala">interface</a>
<code class="docutils literal"><span class="pre">xitrum.Cache</span></code>.</p>
</div>
<div class="section" id="cache-hoat-dong-nhu-the-nao">
<h3>Cache hoạt động như thế nào<a class="headerlink" href="#cache-hoat-dong-nhu-the-nao" title="Permalink to this headline">¶</a></h3>
<p>Inbound:</p>
<div class="highlight-python"><div class="highlight"><pre>               action response nên được
               cache và cache đã tồn tại
request        trước đó?
-------------------------+---------------NO---------------&gt;
                         |
&lt;---------YES------------+
  respond từ cache
</pre></div>
</div>
<p>Outbound:</p>
<div class="highlight-python"><div class="highlight"><pre>               action response nên được
               cache và cache chưa tồn tại
               trước đó?                           response
&lt;---------NO-------------+---------------------------------
                         |
&lt;---------YES------------+
  lưu response vào cache
</pre></div>
</div>
</div>
<div class="section" id="xitrum-util-locallrucache">
<h3>xitrum.util.LocalLruCache<a class="headerlink" href="#xitrum-util-locallrucache" title="Permalink to this headline">¶</a></h3>
<p>Cache trên đây là cache chia sẻ bởi toàn bộ hệ thống. Nếu bạn muốn cache ở trong
một phạm vi nhỏ, bạn có thể sử dụng <code class="docutils literal"><span class="pre">xitrum.util.LocalLruCache</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.LocalLruCache

// LRU (Least Recently Used) cache that can contain 1000 elements.
// Keys and values are both of type String.
val cache = LocalLruCache[String, String](1000)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">cache</span></code> đã được trả về là một <a class="reference external" href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html">java.util.LinkedHashMap</a>.
Bạn có thể sử dụng method <code class="docutils literal"><span class="pre">LinkedHashMap</span></code> từ nó.</p>
</div>
</div>
<span id="document-i18n"></span><div class="section" id="i18n">
<h2>I18n<a class="headerlink" href="#i18n" title="Permalink to this headline">¶</a></h2>
<p>Phong cách GNU gettext được sử dụng. Không giống như các i18n method khác, gettext
hỗ trợ đa số các form.</p>
<img alt="_images/poedit.png" src="_images/poedit.png" />
<div class="section" id="viet-cac-internationalized-messages-vao-source-code">
<h3>Viết các internationalized messages vào source code<a class="headerlink" href="#viet-cac-internationalized-messages-vao-source-code" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.Action</span></code> kế thừa <code class="docutils literal"><span class="pre">xitrum.I18n</span></code>, và có 2 method sau:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span><span class="p">(</span><span class="s">&quot;Message&quot;</span><span class="p">)</span>
<span class="n">tc</span><span class="p">(</span><span class="s">&quot;Context&quot;</span><span class="p">,</span> <span class="s">&quot;Message&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Bạn có thể gọi trực tiếp 2 method trên từ trong action.
Tại một nơi khác như model, bạn cần truyền current action vào đó và gọi <code class="docutils literal"><span class="pre">t</span></code> và
<code class="docutils literal"><span class="pre">tc</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>// In an action
respondText(MyModel.hello(this))

// In the model
import xitrum.I18n
object MyModel {
  def hello(i18n: I18n) = i18n.t(&quot;Hello World&quot;)
}
</pre></div>
</div>
</div>
<div class="section" id="trien-khai-cac-tin-nhan-den-tep-pot">
<h3>Triển khai các tin nhắn đến tệp pot<a class="headerlink" href="#trien-khai-cac-tin-nhan-den-tep-pot" title="Permalink to this headline">¶</a></h3>
<p>Tạo một tệp i18n.pot trong thư mục gốc của project, sau đó biên dịch lại cả
project.</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt clean
rm i18n.pot
touch i18n.pot
sbt/sbt compile
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span></code> dùng để xóa tất cả các tệp .class , bắt SBT biên dịch lại cả
project. Vì sau <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span></code>, SBT sẽ thử tải lại toàn bộ <a class="reference internal" href="index.html#document-deps"><em>dependencies</em></a>,
bạn có thể tiến hành nhanh hơn một chút với lệnh <code class="docutils literal"><span class="pre">find</span> <span class="pre">target</span> <span class="pre">-name</span> <span class="pre">*.class</span> <span class="pre">-delete</span></code>,
nó sẽ xóa toàn bộ các tệp . class trong thư mục <code class="docutils literal"><span class="pre">target</span></code>.</p>
<p>Sau khi biên dịch lại, i18n.pot sẽ được lấp đầy với các gettext message triển khai
từ mã nguồn. Để làm điều này, <a class="reference external" href="http://www.scala-lang.org/node/140">Scala compiler plugin technique</a>
được sử dụng.</p>
<p>Tuy nhiên, phương pháp này sẽ chỉ trích rút dữ liệu từ mã nguồn. Nếu bạn có các
tệp Java, bạn có thể sử dụng câu lệnh <code class="docutils literal"><span class="pre">xgettext</span></code> để trích xuất dữ liệu:</p>
<div class="highlight-python"><div class="highlight"><pre>xgettext -kt -ktc:1c,2 -ktn:1,2 -ktcn:1c,2,3 -o i18n_java.pot --from-code=UTF-8 $(find src/main/java -name &quot;*.java&quot;)
</pre></div>
</div>
<p>Sau đó bạn gộp tệp i18n_java.pot và tệp i18n.pot.</p>
</div>
<div class="section" id="luu-cac-tep-po-tai-dau">
<h3>Lưu các tệp .po tại đâu<a class="headerlink" href="#luu-cac-tep-po-tai-dau" title="Permalink to this headline">¶</a></h3>
<p>i18n.pot là một tệp bản mẫu. Bạn cần sao chép nó đến tệp &lt;language&gt;.po và dịch.</p>
<p>Xitrum theo dõi thư mực có tên <code class="docutils literal"><span class="pre">i18n</span></code> trong classpath.
Nếu một tệp &lt;language&gt;.po trong thư mục đó được thay đổi hoặc được thêm vào ở runtime,
Xitrum sẽ tự động tải lại tệp &lt;language&gt;.po đó.</p>
<div class="highlight-python"><div class="highlight"><pre>src
  main
    scala
    view
    resources
      i18n
        ja.po
        vi.po
        ...
</pre></div>
</div>
<p>Sử dụng công cụ như <a class="reference external" href="http://www.poedit.net/">Poedit</a> để edit các tệp .po.
Bạn cũng có thể sử dụng nó để hợp các tệp pot mới vào tệp po cũ.</p>
<img alt="_images/update_from_pot.png" src="_images/update_from_pot.png" />
<p>Bạn có thể đóng gói các tệp .po trong nhiều tệp JAR. Xitrum sẽ tự động gộp chúng
khi chạy.</p>
<div class="highlight-python"><div class="highlight"><pre>mylib.jar
  i18n
    ja.po
    vi.po
        ...

another.jar
  i18n
    ja.po
    vi.po
        ...
</pre></div>
</div>
</div>
<div class="section" id="chon-ngon-ngu">
<h3>Chọn ngôn ngữ<a class="headerlink" href="#chon-ngon-ngu" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Để lấy cấc ngôn ngữ trong <code class="docutils literal"><span class="pre">Accept-Language</span></code> request header bởi browser, gọi
<code class="docutils literal"><span class="pre">browserLanguages</span></code>. Kết quả sẽ được sắp xếp theo mức ưu tiên đặt bởi trình duyệt
từ cao xuống thấp.</li>
<li>Ngôn ngữ mặc định là &#8220;en&#8221;. Để chuyển ngôn ngữ, ví dụ Nhật Bản, gọi <code class="docutils literal"><span class="pre">language</span> <span class="pre">=</span> <span class="pre">&quot;ja&quot;</span></code></li>
<li>Để tự đặt ngôn ngữ phù hợp nhất trong resource, gọi
<code class="docutils literal"><span class="pre">autosetLanguage(resourceLanguages)</span></code>, với
<code class="docutils literal"><span class="pre">resourceLanguages</span></code> là một list các ngôn ngữ có trong thư mục
<code class="docutils literal"><span class="pre">resources/i18n</span></code> và các tệp JAR.
Nếu không có ngôn ngữ nào phù hợp, ngôn ngữ vẫn mặc định là &#8220;en&#8221;.</li>
<li>Để lấy ngôn ngữ hiện thời được đặt bên trên, sử dụng <code class="docutils literal"><span class="pre">language</span></code>.</li>
</ul>
<p>Trong action, thông thường trong một before filter, để đặt language:</p>
<div class="highlight-python"><div class="highlight"><pre>beforeFilter {
  val lango: Option[String] = yourMethodToGetUserPreferenceLanguageInSession()
  lango match {
    case None       =&gt; autosetLanguage(&quot;ja&quot;, &quot;vi&quot;)
    case Some(lang) =&gt; language = lang
  }
}
</pre></div>
</div>
</div>
<div class="section" id="validation-messages">
<h3>Validation messages<a class="headerlink" href="#validation-messages" title="Permalink to this headline">¶</a></h3>
<p>jQuery Validation plugin cung cấp <a class="reference external" href="https://github.com/jzaefferer/jquery-validation/tree/master/src/localization">i18n error messages</a>.
Xitrum tự động thêm các tệp message tương ứng vào ngôn ngữ hiện thời.</p>
<p>Với validator mặc định ở phía server trong package <code class="docutils literal"><span class="pre">xitrum.validator</span></code>, Xitrum cũng
cung cấp bản dịch tương ứng.</p>
</div>
<div class="section" id="voi-da-so-form">
<h3>Với đa số form<a class="headerlink" href="#voi-da-so-form" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tn</span><span class="p">(</span><span class="s">&quot;Message&quot;</span><span class="p">,</span> <span class="s">&quot;Plural form&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">tcn</span><span class="p">(</span><span class="s">&quot;Context&quot;</span><span class="p">,</span> <span class="s">&quot;Message&quot;</span><span class="p">,</span> <span class="s">&quot;Plural form&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Xitrum chỉ có thể chạy đúng với đa số form sau:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.gnu.org/software/gettext/manual/html_node/Plural-forms.html#Plural-forms">What are plural forms</a></li>
<li><a class="reference external" href="http://www.gnu.org/software/gettext/manual/html_node/Translating-plural-forms.html#Translating-plural-forms">Translating plural forms</a></li>
</ul>
<p>Phần lớn các form thường nằm trong số sau:</p>
<div class="highlight-python"><div class="highlight"><pre>nplurals=1; plural=0
nplurals=2; plural=n != 1
nplurals=2; plural=n&gt;1
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2
nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2
nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 &gt; 0 &amp;&amp; n%100 &lt; 20)) ? 1 : 2
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=3; plural=(n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2
nplurals=3; plural=n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=4; plural=n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3
</pre></div>
</div>
</div>
<div class="section" id="dinh-dang-ngay-va-so">
<h3>Định dạng ngày và số<a class="headerlink" href="#dinh-dang-ngay-va-so" title="Permalink to this headline">¶</a></h3>
<p>Nếu bạn sử dụng Scalate template engine, mặc định ngày và số sẽ được định dạng theo
ngôn ngữ hiện thời.</p>
<p>Nếu bạn muốn sử dụng định dạng khác:</p>
<div class="highlight-python"><div class="highlight"><pre>import java.text.{DateFormat, NumberFormat}

val myDateFormat   = ...
val myNumberFormat = ...
val options        = Map(&quot;date&quot; -&gt; myDateFormat, &quot;number&quot; -&gt; myNumberFormat)
respondView(options)
</pre></div>
</div>
</div>
</div>
<span id="document-log"></span><div class="section" id="log">
<h2>Log<a class="headerlink" href="#log" title="Permalink to this headline">¶</a></h2>
<div class="section" id="su-dung-truc-tiep-doi-tuong-xitrum-log">
<h3>Sử dụng trực tiếp đối tượng xitrum.Log<a class="headerlink" href="#su-dung-truc-tiep-doi-tuong-xitrum-log" title="Permalink to this headline">¶</a></h3>
<p>Từ bất kỳ đâu, bạn có thể gọi một cách trực tiếp như sau:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;My debug msg&quot;</span><span class="p">)</span>
<span class="n">xitrum</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;My info msg&quot;</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="su-dung-trait-xitrum-log">
<h3>Sử dụng trait xitrum.Log<a class="headerlink" href="#su-dung-trait-xitrum-log" title="Permalink to this headline">¶</a></h3>
<p>Nếu bạn muốn biết log tạo bởi class nào, bạn nên kế thừa trait xitrum.Log:</p>
<div class="highlight-python"><div class="highlight"><pre>package my_package
import xitrum.Log

object MyModel extends Log {
  log.debug(&quot;My debug msg&quot;)
  log.info(&quot;My info msg&quot;)
  ...
}
</pre></div>
</div>
<p>Trong tệp log/xitrum.log bạn sẽ thấy log message đến từ <code class="docutils literal"><span class="pre">MyModel</span></code>.</p>
<p>Xitrum action kế thừa trait xitrum.Log, vì thế trong action, bạn có thể viết:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="khong-phai-kiem-tra-log-level-truoc-khi-log">
<h3>Không phải kiểm tra log level trước khi log<a class="headerlink" href="#khong-phai-kiem-tra-log-level-truoc-khi-log" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.Log</span></code> dựa trên <a class="reference external" href="http://slf4s.org/">SLF4S</a> (<a class="reference external" href="http://slf4s.org/api/1.7.7/">API</a>),
<code class="docutils literal"><span class="pre">SLFS4</span></code> lại được xây dựng trên <a class="reference external" href="http://www.slf4j.org/">SLF4J</a>.</p>
<p>Thông thường, trước khi thực thi một phép tính lớn để log result, bạn phải kiểm tra log level
để hạn chế lãng phí CPU cho phép tính.</p>
<p><a class="reference external" href="https://github.com/mattroberts297/slf4s/blob/master/src/main/scala/org/slf4s/Logger.scala">SLF4S tự động thực hiện việc kiểm tra</a>,
do đó bạn không cần phải tự kiểm tra.</p>
<p>Trước đó (đoạn mã này không còn chạy với bản Xitrum hiện tại 3.13+):</p>
<div class="highlight-python"><div class="highlight"><pre>if (log.isTraceEnabled) {
  val result = heavyCalculation()
  log.trace(&quot;Output: {}&quot;, result)
}
</pre></div>
</div>
<p>Hiện tại:</p>
<div class="highlight-python"><div class="highlight"><pre>log.trace(s&quot;Output: #{heavyCalculation()}&quot;)
</pre></div>
</div>
</div>
<div class="section" id="cau-hinh-log-level">
<h3>Cấu hình log level<a class="headerlink" href="#cau-hinh-log-level" title="Permalink to this headline">¶</a></h3>
<p>Trong tệp build.sbt, có một dòng như sau:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;ch.qos.logback&quot;</span> <span class="o">%</span> <span class="s">&quot;logback-classic&quot;</span> <span class="o">%</span> <span class="s">&quot;1.1.2&quot;</span>
</pre></div>
</div>
<p>Dòng này có nghĩa rằng : mặc định <a class="reference external" href="http://logback.qos.ch/">Logback</a> được sử dụng.
Tệp cấu hình Logback nằm tại <code class="docutils literal"><span class="pre">config/logback.xml</span></code>.</p>
<p>Bạn có thể thay thê Logback bằng bất kì implementation nào khác của <a class="reference external" href="http://www.slf4j.org/">SLF4J</a>.</p>
</div>
<div class="section" id="log-vao-fluentd">
<h3>Log vào Fluentd<a class="headerlink" href="#log-vao-fluentd" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://www.fluentd.org/">Fluentd</a> là một log collector phổ biến. Bạn có thể
cấu hình Logback để gửi log (từ nhiều nơi) đến một Fluentd server.</p>
<p>Đầu tiên, thêm thư viện <a class="reference external" href="https://github.com/sndyuk/logback-more-appenders">logback-more-appenders</a>
vào trong project:</p>
<div class="highlight-python"><div class="highlight"><pre>libraryDependencies += &quot;org.fluentd&quot; % &quot;fluent-logger&quot; % &quot;0.2.11&quot;

resolvers += &quot;Logback more appenders&quot; at &quot;http://sndyuk.github.com/maven&quot;

libraryDependencies += &quot;com.sndyuk&quot; % &quot;logback-more-appenders&quot; % &quot;1.1.0&quot;
</pre></div>
</div>
<p>Sau đó trong tệp <code class="docutils literal"><span class="pre">config/logback.xml</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>...

&lt;appender name=&quot;FLUENT&quot; class=&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;&gt;
  &lt;tag&gt;mytag&lt;/tag&gt;
  &lt;label&gt;mylabel&lt;/label&gt;
  &lt;remoteHost&gt;localhost&lt;/remoteHost&gt;
  &lt;port&gt;24224&lt;/port&gt;
  &lt;maxQueueSize&gt;20000&lt;/maxQueueSize&gt;  &lt;!-- Save to memory when remote server is down --&gt;
&lt;/appender&gt;

&lt;root level=&quot;DEBUG&quot;&gt;
  &lt;appender-ref ref=&quot;FLUENT&quot;/&gt;
  &lt;appender-ref ref=&quot;OTHER_APPENDER&quot;/&gt;
&lt;/root&gt;

...
</pre></div>
</div>
</div>
</div>
<span id="document-deploy"></span><div class="section" id="trien-khai-ung-dung-web-tren-server">
<h2>Triển khai ứng dụng web trên server<a class="headerlink" href="#trien-khai-ung-dung-web-tren-server" title="Permalink to this headline">¶</a></h2>
<p>Bạn có thể chạy trực tiếp Xitrum:</p>
<div class="highlight-python"><div class="highlight"><pre>Browser ------ Xitrum instance
</pre></div>
</div>
<p>Hoăc behind a load balancer như HAProxy, hoặc reverse proxy như Apache hay Nginx:</p>
<div class="highlight-python"><div class="highlight"><pre>Browser ------ Load balancer/Reverse proxy -+---- Xitrum instance1
                                            +---- Xitrum instance2
</pre></div>
</div>
<div class="section" id="dong-gi-thu-muc">
<h3>Đóng gí thư mục<a class="headerlink" href="#dong-gi-thu-muc" title="Permalink to this headline">¶</a></h3>
<p>Chạy <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">xitrum-package</span></code> để chuẩn bị cho thư mục <code class="docutils literal"><span class="pre">target/xitrum</span></code> sẵn sàng
triển khai tại server sản phẩm:</p>
<div class="highlight-python"><div class="highlight"><pre>target/xitrum
  config
    [config files]
  public
    [static public files]
  lib
    [dependencies and packaged project file]
  script
    runner
    runner.bat
    scalive
    scalive.jar
    scalive.bat
</pre></div>
</div>
</div>
<div class="section" id="customize-xitrum-package">
<h3>Customize xitrum-package<a class="headerlink" href="#customize-xitrum-package" title="Permalink to this headline">¶</a></h3>
<p>Mặc định câu lệnh <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">xitrum-package</span></code> được cấu hình để sao chép các thư mục
<code class="docutils literal"><span class="pre">config</span></code>, <code class="docutils literal"><span class="pre">public</span></code>, và <code class="docutils literal"><span class="pre">script</span></code> đến <code class="docutils literal"><span class="pre">target/xitrum</span></code>. Nếu bạn muốn câu lệnh
đó sao chép các thư mục hoặc tệp khác sửa tệp <code class="docutils literal"><span class="pre">build.sbt</span></code> như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>XitrumPackage.copy(&quot;config&quot;, &quot;public, &quot;script&quot;, &quot;doc/README.txt&quot;, &quot;etc.&quot;)
</pre></div>
</div>
<p>Xem <a class="reference external" href="https://github.com/xitrum-framework/xitrum-package">xitrum-package homepage</a>
để biết thêm chi tiết.</p>
</div>
<div class="section" id="ket-noi-scala-console-den-mot-tien-trinh-jvm-dang-chay">
<h3>Kết nối Scala console đến một tiến trình JVM đang chạy<a class="headerlink" href="#ket-noi-scala-console-den-mot-tien-trinh-jvm-dang-chay" title="Permalink to this headline">¶</a></h3>
<p>Trong môi trường sản phẩm (production environment), nếu không có khởi tạo, bạn có
thể sử dụng <a class="reference external" href="https://github.com/xitrum-framework/scalive">Scalive</a>
để kết nối một Scala console đến một tiến trình JVM đang chạy để gỡ lỗi trực tiếp.</p>
<p>Chạy <code class="docutils literal"><span class="pre">scalive</span></code> trong thư mục script:</p>
<div class="highlight-python"><div class="highlight"><pre>script
  runner
  runner.bat
  scalive
  scalive.jar
  scalive.bat
</pre></div>
</div>
</div>
<div class="section" id="cai-dat-oracle-jdk-tren-centos-hoac-ubuntu">
<h3>Cài đặt Oracle JDK trên CentOS hoặc Ubuntu<a class="headerlink" href="#cai-dat-oracle-jdk-tren-centos-hoac-ubuntu" title="Permalink to this headline">¶</a></h3>
<p>Dưới đây là hướng dẫn một cách đơn giản để cài đặt Java.Bạn có thể
cài đặt Java bằng cách sử dụng trình quản lý gói.</p>
<p>Kiểm tra các phiên bản Java đã được cài đặt:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --list java
</pre></div>
</div>
<p>Output example:</p>
<div class="highlight-python"><div class="highlight"><pre>/usr/lib/jvm/jdk1.7.0_15/bin/java
/usr/lib/jvm/jdk1.7.0_25/bin/java
</pre></div>
</div>
<p>Kiểm tra môi trường (32 bit hay 64 bit):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">init</span>
</pre></div>
</div>
<p>Output example:</p>
<div class="highlight-python"><div class="highlight"><pre>/sbin/init: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x4efe732752ed9f8cc491de1c8a271eb7f4144a5c, stripped
</pre></div>
</div>
<p>Tải JDK từ <a class="reference external" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">Oracle</a>.
Đây là một <a class="reference external" href="http://stackoverflow.com/questions/10268583/how-to-automate-download-and-instalation-of-java-jdk-on-linux">thủ thuật</a>
để tải jdk mà không dùng trình duyệt:</p>
<div class="highlight-python"><div class="highlight"><pre>wget --no-cookies --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/7u45-b18/jdk-7u45-linux-x64.tar.gz&quot;
</pre></div>
</div>
<p>Giải nén và di chuyển thư mục</p>
<div class="highlight-python"><div class="highlight"><pre>tar -xzvf jdk-7u45-linux-x64.tar.gz
sudo mv jdk1.7.0_45 /usr/lib/jvm/jdk1.7.0_45
</pre></div>
</div>
<p>Cài đặt java:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/java&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javac&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javap&quot; &quot;javap&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javap&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javaws&quot; 1
</pre></div>
</div>
<p>Chọn đường dẫn đến phiên bản Java</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --config java
</pre></div>
</div>
<p>Output example:</p>
<div class="highlight-python"><div class="highlight"><pre>There are 3 choices for the alternative java (providing /usr/bin/java).

  Selection    Path                               Priority   Status
------------------------------------------------------------
* 0            /usr/lib/jvm/jdk1.7.0_25/bin/java   50001     auto mode
  1            /usr/lib/jvm/jdk1.7.0_15/bin/java   50000     manual mode
  2            /usr/lib/jvm/jdk1.7.0_25/bin/java   50001     manual mode
  3            /usr/lib/jvm/jdk1.7.0_45/bin/java   1         manual mode

Press enter to keep the current choice[*], or type selection number: 3
update-alternatives: using /usr/lib/jvm/jdk1.7.0_45/bin/java to provide /usr/bin/java (java) in manual mode
</pre></div>
</div>
<p>Kiểm tra phiên bản Java:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">java</span> <span class="o">-</span><span class="n">version</span>
</pre></div>
</div>
<p>Output example:</p>
<div class="highlight-python"><div class="highlight"><pre>java version &quot;1.7.0_45&quot;
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
</pre></div>
</div>
<p>Tương tự với javac, javap, javaws:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --config javac
sudo update-alternatives --config javap
sudo update-alternatives --config javaws
</pre></div>
</div>
</div>
<div class="section" id="chay-xitrum-o-che-do-san-pham-khi-he-thong-khoi-dong">
<h3>Chạy Xitrum ở chế độ sản phẩm khi hệ thống khởi động<a class="headerlink" href="#chay-xitrum-o-che-do-san-pham-khi-he-thong-khoi-dong" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">script/runner</span></code> (cho các hệ thông Unix-like) và <code class="docutils literal"><span class="pre">script/runner.bat</span></code> (cho Windows) là các đoạn script
để chạy bất cứ đối tượng nào có method <code class="docutils literal"><span class="pre">main</span></code>. Sử dụng chúng để khởi động web server trong môi trường
sản phẩm.</p>
<div class="highlight-python"><div class="highlight"><pre>script/runner quickstart.Boot
</pre></div>
</div>
<p>Bạn có thể sửa <code class="docutils literal"><span class="pre">runner</span></code> (hoặc <code class="docutils literal"><span class="pre">runner.bat</span></code>) để chỉnh
<a class="reference external" href="http://www.oracle.com/technetwork/java/hotspotfaq-138619.html">JVM settings</a>.
Xem thêm <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
<p>Để khởi động Xitrum ẩn trên Linux khi khởi động hệ thống, cách đơn giản là thêm dòng
sau vào <code class="docutils literal"><span class="pre">/etc/rc.local</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>su - user_foo_bar -c /path/to/the/runner/script/above &amp;
</pre></div>
</div>
<p><a class="reference external" href="http://cr.yp.to/daemontools.html">daemontools</a> là một giải pháp khác, để cài đặt trên Centos
xem <a class="reference external" href="http://whomwah.com/2008/11/04/installing-daemontools-on-centos5-x86_64/">hướng dẫn</a>.</p>
<p>Hoặc sử dụng <a class="reference external" href="http://supervisord.org/">Supervisord</a>.
Ví dụ <code class="docutils literal"><span class="pre">/etc/supervisord.conf</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>[program:my_app]
directory=/path/to/my_app
command=/path/to/my_app/script/runner quickstart.Boot
autostart=true
autorestart=true
startsecs=3
user=my_user
redirect_stderr=true
stdout_logfile=/path/to/my_app/log/stdout.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=7
stdout_capture_maxbytes=1MB
stdout_events_enabled=false
environment=PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/opt/aws/bin:~/bin
</pre></div>
</div>
<p>Các giải pháp khác:</p>
<ul class="simple">
<li><a class="reference external" href="http://smarden.org/runit/">runit</a></li>
<li><a class="reference external" href="http://upstart.ubuntu.com/">upstart</a></li>
</ul>
</div>
<div class="section" id="thiet-lap-cong-chuyen-tiep">
<h3>Thiết lập cổng chuyển tiếp<a class="headerlink" href="#thiet-lap-cong-chuyen-tiep" title="Permalink to this headline">¶</a></h3>
<p>Xitrum mặc định giao tiếp trên cổng 8000 và 4430.
Bạn có thể đổi cổng trong <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
<p>Bạn có thể thay đổi <code class="docutils literal"><span class="pre">/etc/sysconfig/iptables</span></code> với các lệnh sau để chuyển tiếp cổng
80 sang 8000 và 443 sang 4430:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo su - root
chmod 700 /etc/sysconfig/iptables
iptables-restore &lt; /etc/sysconfig/iptables
iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8000
iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 4430
iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 80 -j REDIRECT --to-ports 8000
iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 443 -j REDIRECT --to-ports 4430
iptables-save -c &gt; /etc/sysconfig/iptables
chmod 644 /etc/sysconfig/iptables
</pre></div>
</div>
<p>Tất nhiên nếu Apache sử dụng cổng 80 và 443, bạn sẽ cần phải dùng Apache:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo /etc/init.d/httpd stop
sudo chkconfig httpd off
</pre></div>
</div>
<p>Tham khao:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.frozentux.net/iptables-tutorial/chunkyhtml/">Iptables tutorial</a></li>
</ul>
</div>
<div class="section" id="cau-hinh-linux-de-ket-noi-hang-loat">
<h3>Cấu hình Linux để kết nối hàng loạt<a class="headerlink" href="#cau-hinh-linux-de-ket-noi-hang-loat" title="Permalink to this headline">¶</a></h3>
<p>Nhớ rằng trên MacOS,
<a class="reference external" href="https://groups.google.com/forum/#!topic/spray-user/S-SNR2m0BWU">JDK có vấn đề nghiêm trọng với tốc độ IO (NIO)</a>.</p>
<p>Tham khảo:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.basho.com/riak/latest/ops/tuning/linux/">Linux Performance Tuning (Riak)</a></li>
<li><a class="reference external" href="http://docs.basho.com/riak/latest/ops/tuning/aws/">AWS Performance Tuning (Riak)</a></li>
<li><a class="reference external" href="http://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/">Ipsysctl tutorial</a></li>
<li><a class="reference external" href="http://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/tcpvariables.html">TCP variables</a></li>
</ul>
<div class="section" id="tang-so-luong-cac-tep-duoc-mo">
<h4>Tăng số lượng các tệp được mở<a class="headerlink" href="#tang-so-luong-cac-tep-duoc-mo" title="Permalink to this headline">¶</a></h4>
<p>Mỗi connection với Linux là một tệp được mở.
Mặc định số lượng tối đa các tệp được mở là 1024.
Để tăng giới hạn, sửa tệp <code class="docutils literal"><span class="pre">/etc/security/limits.conf</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>*  soft  nofile  1024000
*  hard  nofile  1024000
</pre></div>
</div>
<p>Bạn cần đăng xuất và đăng nhập lại hệ thống để kết thúc việc sửa đổi.
Để xác nhận chạy <code class="docutils literal"><span class="pre">ulimit</span> <span class="pre">-n</span></code>.</p>
</div>
<div class="section" id="dieu-chinh-kernel">
<h4>Điều chỉnh kernel<a class="headerlink" href="#dieu-chinh-kernel" title="Permalink to this headline">¶</a></h4>
<p>Như được dẫn trong
<a class="reference external" href="http://www.metabrew.com/article/a-million-user-comet-application-with-mochiweb-part-1">A Million-user Comet Application with Mochiweb</a>,
sửa tệp /etc/sysctl.conf:</p>
<div class="highlight-python"><div class="highlight"><pre># General gigabit tuning
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216

# This gives the kernel more memory for TCP
# which you need with many (100k+) open socket connections
net.ipv4.tcp_mem = 50576 64768 98152

# Backlog
net.core.netdev_max_backlog = 2048
net.core.somaxconn = 1024
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_syncookies = 1

# If you run clients
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 10
</pre></div>
</div>
<p>Chạy <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">sysctl</span> <span class="pre">-p</span></code> để áp dụng các thay đổi.
Không cần khởi động lại hệ thống, kernel đã có khả năng xử lý nhiều kết nối hơn.</p>
</div>
<div class="section" id="luu-y-ve-backlog">
<h4>Lưu ý về backlog<a class="headerlink" href="#luu-y-ve-backlog" title="Permalink to this headline">¶</a></h4>
<p>TCP thực hiện bắt tay 3 bước để thiết lập kết nối.
Khi một client từ xa kết nối đến máy chủ, client sẽ gửi một gói tin SYN.
Và hệ điều hành của phía máy chủ sẽ gửi lại các gói tin SYN-ACK.
Sau đó, khách hàng từ xa thiết lập một kết nối bằng cách gửi một gói tin ACK lại.
Xitrum sẽ nhận được nó khi kết nối được thiết lập đầy đủ.</p>
<p>Theo như
<a class="reference external" href="https://sites.google.com/site/beingroot/articles/apache/socket-backlog-tuning-for-apache">Socket backlog tuning for Apache</a>,
connection timeout xảy ra khi gói tin SYN bị mất bởi backlog queue của web server bị
lấp đầy bởi các kết nối gửi SYN-ACK đến các client chậm.</p>
<p>Theo như
<a class="reference external" href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/configtuning-kernel-limits.html">FreeBSD Handbook</a>,
giá trị mặc định của là 128 thường quá thấp để xử lý các kết nối mới trong một server
có tải lớn. Đối với các máy chủ như vậy, nên tăng giá trị này thành 1024 hoặc hơn.
Listen queue lớn hơn cũng là cách tốt để chống lại việc tấn công từ chối dịch vụ (Denial of Service - DoS)</p>
<p>Backlog size của Xitrum được đặt thành 1024 (memcached cũng dùng giá trị này),
nhưng bạn cũng cần chỉnh kernel như trên.
The backlog size of Xitrum is set to 1024 (memcached also uses this value),</p>
<p>Kiểm tra cấu hình backlog:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cat</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">net</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">somaxconn</span>
</pre></div>
</div>
<p>hoặc:</p>
<div class="highlight-python"><div class="highlight"><pre>sysctl net.core.somaxconn
</pre></div>
</div>
<p>Để điều chỉnh tạm thời, bạn có thể làm như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo sysctl -w net.core.somaxconn=1024
</pre></div>
</div>
</div>
</div>
<div class="section" id="haproxy-tip">
<h3>HAProxy tip<a class="headerlink" href="#haproxy-tip" title="Permalink to this headline">¶</a></h3>
<p>Để cấu hình HAProxy cho SockJS, xem <a class="reference external" href="https://github.com/sockjs/sockjs-node/blob/master/examples/haproxy.cfg">ví dụ</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>defaults
    mode http
    timeout connect 10s
    timeout client  10h  # Set to long time to avoid WebSocket connections being closed when there&#39;s no network activity
    timeout server  10h  # Set to long time to avoid ERR_INCOMPLETE_CHUNKED_ENCODING on Chrome

frontend xitrum_with_discourse
    bind 0.0.0.0:80

    option forwardfor

    acl is_discourse path_beg /forum
    use_backend discourse if is_discourse
    default_backend xitrum

backend xitrum
    server srv_xitrum 127.0.0.1:8000

backend discourse
    server srv_discourse 127.0.0.1:3000
</pre></div>
</div>
<p>Để HAProxy tải lại tệp cấu hình mà không cần khởi động lại, xem <a class="reference external" href="http://serverfault.com/questions/165883/is-there-a-way-to-add-more-backend-server-to-haproxy-without-restarting-haproxy">cuộc thảo luận</a>.</p>
<p>HAProxy thì dễ sử dụng hơn Nginx. Nó phù hợp với Xitrum bởi như được đề cập đến trong
<a class="reference internal" href="index.html#document-cache"><em>the section about caching</em></a>, Các tệp tĩnh trong Xitrum thì
<a class="reference external" href="https://gist.github.com/3293596">very fast</a>. Bạn không cần sử dụng các tệp tĩnh
để phục vụ các tĩnh năng của Nginx.</p>
</div>
<div class="section" id="nginx-tip">
<h3>Nginx tip<a class="headerlink" href="#nginx-tip" title="Permalink to this headline">¶</a></h3>
<p>Nếu bạn sửu dụng tính năng WebSocket hoặc SockJS trong Xitrum và muốn chạy Xitrum ẩn sau
Nginx 1.2, bạn phải cài đặt thêm module như
<a class="reference external" href="https://github.com/yaoweibin/nginx_tcp_proxy_module">nginx_tcp_proxy_module</a>.
Nginx 1.3+ hỗ trợ WebSocket.</p>
<p>Mặc định Nginx sử dụng giao thức HTTP 1.0 để reverse proxy. Nếu backend server trả về
chunked response, bạn cần báo Nginx sử dụng HTTP 1.1 như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>location / {
  proxy_http_version 1.1;
  proxy_set_header Connection &quot;&quot;;
  proxy_pass http://127.0.0.1:8000;
}
</pre></div>
</div>
<p><a class="reference external" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive">Tài liệu này</a> chỉ ra rằng để http keepalive, bạn cũng
nên đặt proxy_set_header Connection &#8220;&#8221;;</p>
</div>
<div class="section" id="trien-khai-tren-heroku">
<h3>Triển khai trên Heroku<a class="headerlink" href="#trien-khai-tren-heroku" title="Permalink to this headline">¶</a></h3>
<p>Bạn cũng có thẻ chạy Xitrum trên <a class="reference external" href="https://www.heroku.com/">Heroku</a>.</p>
<div class="section" id="dang-ky-va-tao-repository">
<h4>Đăng ký và tạo repository<a class="headerlink" href="#dang-ky-va-tao-repository" title="Permalink to this headline">¶</a></h4>
<p>Làm theo <a class="reference external" href="https://devcenter.heroku.com/articles/quickstart">Official Document</a>,
để đăng ký và tạo repository.</p>
</div>
<div class="section" id="tao-procfile">
<h4>Tạo Procfile<a class="headerlink" href="#tao-procfile" title="Permalink to this headline">¶</a></h4>
<p>Tạo Procfile và lưu tại thư mục gốc của project. Heroku đọc tệp này thực thi khi khởi động.</p>
<div class="highlight-python"><div class="highlight"><pre>web: target/xitrum/script/runner &lt;YOUR_PACKAGE.YOUR_MAIN_CLASS&gt;
</pre></div>
</div>
</div>
<div class="section" id="thay-doi-thiet-lap-cong">
<h4>Thay đổi thiết lập cổng<a class="headerlink" href="#thay-doi-thiet-lap-cong" title="Permalink to this headline">¶</a></h4>
<p>Vì Heroku sử dụng cổng một cách tự động, bạn cần làm như sau:</p>
<p>config/xitrum.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>port {
  http              = ${PORT}
  # https             = 4430
  # flashSocketPolicy = 8430  # flash_socket_policy.xml will be returned
}
</pre></div>
</div>
<p>Nếu bạn muốn sử dụng SSL, bạn cần <a class="reference external" href="https://addons.heroku.com/ssl">add on</a>.</p>
</div>
<div class="section" id="xem-log-level">
<h4>Xem log level<a class="headerlink" href="#xem-log-level" title="Permalink to this headline">¶</a></h4>
<p>config/logback.xml:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;root level=&quot;INFO&quot;&gt;
  &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
&lt;/root&gt;
</pre></div>
</div>
<p>Tail log từ Heroku command:</p>
<div class="highlight-python"><div class="highlight"><pre>heroku logs -tail
</pre></div>
</div>
</div>
<div class="section" id="tao-alias-cho-xitrum-package">
<h4>Tạo alias cho <code class="docutils literal"><span class="pre">xitrum-package</span></code><a class="headerlink" href="#tao-alias-cho-xitrum-package" title="Permalink to this headline">¶</a></h4>
<p>Tại thời điểm triển khai, Heroku chạy <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span> <span class="pre">compile</span> <span class="pre">stage</span></code>. Vì vậy bạn cần thêm
alias cho <code class="docutils literal"><span class="pre">xitrum-package</span></code>.</p>
<p>build.sbt:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">addCommandAlias</span><span class="p">(</span><span class="s">&quot;stage&quot;</span><span class="p">,</span> <span class="s">&quot;;xitrum-package&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="push-len-heroku">
<h4>Push lên Heroku<a class="headerlink" href="#push-len-heroku" title="Permalink to this headline">¶</a></h4>
<p>Quá trình triển khai được nối bởi git push.</p>
<div class="highlight-python"><div class="highlight"><pre>git push heroku master
</pre></div>
</div>
<p>Xem thêm <a class="reference external" href="https://devcenter.heroku.com/articles/getting-started-with-scala">Official document cho Scala</a>.</p>
</div>
</div>
</div>
<span id="document-cluster"></span><div class="section" id="clustering-voi-akka-va-hazelcast">
<h2>Clustering với Akka và Hazelcast<a class="headerlink" href="#clustering-voi-akka-va-hazelcast" title="Permalink to this headline">¶</a></h2>
<p>Xitrum được thiết kế để chạy trong môi trường sản xuất như nhiều instance
đằng sau một máy chủ proxy hoặc cân bằng tải:</p>
<div class="highlight-python"><div class="highlight"><pre>                              / Xitrum instance 1
Load balancer/proxy server ---- Xitrum instance 2
                              \ Xitrum instance 3
</pre></div>
</div>
<p>Cache, sessions, và SockJS sessions có thể được be clustered bởi tính năng của
<a class="reference external" href="http://akka.io/">Akka</a> và <a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast</a>.</p>
<p>Với Hazelcast, Xitrum trở thành một in-process memory cache server. Bạn không cần
sử dụng các máy chủ bổ sung như Memcache.</p>
<p>Xem thêm <code class="docutils literal"><span class="pre">config/akka.conf</span></code>, và đọc <a class="reference external" href="http://akka.io/docs/">Akka doc</a> hay
<a class="reference external" href="http://hazelcast.org/documentation/">Hazelcast doc</a> để biết cách cấu hình
Akka và Hazelcast cluster.</p>
<p>Nhớ rằng: Với session, bạn cũng có thể <code class="xref doc docutils literal"><span class="pre">lưu</span> <span class="pre">trữ</span> <span class="pre">ở</span> <span class="pre">client</span> <span class="pre">bằng</span> <span class="pre">cookie</span> <span class="pre">/scopes&gt;</span></code>.</p>
</div>
<span id="document-handler"></span><div class="section" id="netty-handler">
<h2>Netty handler<a class="headerlink" href="#netty-handler" title="Permalink to this headline">¶</a></h2>
<p>Chương này sử dụng các kiến thức nâng cao, bạn không cần biết sử dụng Xitrum
một cách thông thường. Để có thể hiểu, bạn cần có kiến thức về <a class="reference external" href="http://netty.io/">Netty</a>.</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Rack_(Web_server_interface)">Rack</a>,
<a class="reference external" href="http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a>, và
<a class="reference external" href="http://en.wikipedia.org/wiki/PSGI">PSGI</a> đều có kiến trúc middleware.
Xitrum dựa trên <a class="reference external" href="http://netty.io/">Netty</a> nên đều có handlers.
Bạn có thể tạo thêm handler và cấu hình chúng các kênh pipeline của hander
You can create additional handlers and customize the channel pipeline. Việc
làm này, bạn có thể tối ưu hiệu suất server cho một số use case cụ thể.</p>
<p>Chương này trình bày về:</p>
<ul class="simple">
<li>Kiến trúc của Netty handler</li>
<li>Handlers cung cấp bởi Xitrum và thứ tự mặc định</li>
<li>Cách tạo mới và cấu hình một handler</li>
</ul>
<div class="section" id="kien-truc-cua-netty-handler">
<h3>Kiến trúc của Netty handler<a class="headerlink" href="#kien-truc-cua-netty-handler" title="Permalink to this headline">¶</a></h3>
<p>Với mỗi kết nối, sẽ có một kênh pipeline để handle dữ liệu IO.
Mỗi kênh pipeline là một chuối cac handler. Có 2 kiểu handler.</p>
<ul class="simple">
<li>Inbound: request từ client -&gt; server</li>
<li>Outbound: response từ server -&gt; client</li>
</ul>
<p>Hãy đọc thêm tài liệu về <a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html">ChannelPipeline</a>
để biết thêm thông tin.</p>
<div class="highlight-python"><div class="highlight"><pre>                                               I/O Request
                                          via Channel or
                                      ChannelHandlerContext
                                                    |
+---------------------------------------------------+---------------+
|                           ChannelPipeline         |               |
|                                                  \|/              |
|    +---------------------+            +-----------+----------+    |
|    | Inbound Handler  N  |            | Outbound Handler  1  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
|               |                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  .               |
|               .                                   .               |
| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
|        [ method call]                       [method call]         |
|               .                                   .               |
|               .                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
|               |                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler  1  |            | Outbound Handler  M  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
+---------------+-----------------------------------+---------------+
                |                                  \|/
+---------------+-----------------------------------+---------------+
|               |                                   |               |
|       [ Socket.read() ]                    [ Socket.write() ]     |
|                                                                   |
|  Netty Internal I/O Threads (Transport Implementation)            |
+-------------------------------------------------------------------+
</pre></div>
</div>
</div>
<div class="section" id="tuy-chinh-handler">
<h3>Tùy chỉnh handler<a class="headerlink" href="#tuy-chinh-handler" title="Permalink to this headline">¶</a></h3>
<p>Khi khởi động server Xitrum, bạn có thể truyền vào
<a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelInitializer.html">ChannelInitializer</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Server

object Boot {
  def main(args: Array[String]) {
    Server.start(myChannelInitializer)
  }
}
</pre></div>
</div>
<p>Với server HTTTPS, Xitrum sẽ tự động thêm SSL handler vào trước pipeline.
Bạn có thể tái sử dụng các Xitrum handler trong pipeline.</p>
</div>
<div class="section" id="xitrum-handler-mac-dinh">
<h3>Xitrum handler mặc định<a class="headerlink" href="#xitrum-handler-mac-dinh" title="Permalink to this headline">¶</a></h3>
<p>Xem <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/handler/DefaultHttpChannelInitializer.scala">xitrum.handler.DefaultHttpChannelInitializer</a>.</p>
<p>Sharable handlers (một instances được sử dụng chung bởi nhiều kết nối) được đặt trong
object <code class="docutils literal"><span class="pre">DefaultHttpChannelInitializer</span></code> ở trên do đó chúng có thể được chọn bởi ứng dụng
muốn sử dụng pipeline tùy chỉnh. Những ứng dụng có thể chỉ muốn có một tập hợp con của các
handler mặc định.</p>
<p>Ví dụ, khi ứng dụng sử dụng dispatcher của chính nó (khong phải là routing/dispatcher của Xitrum) và chỉ cần tính năng xử lý tệp tĩnh nhanh của Xitrum, có thể chỉ cần sử dụng các
handler:</p>
<p>Inbound:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HttpRequestDecoder</span></code></li>
<li><code class="docutils literal"><span class="pre">PublicFileServer</span></code></li>
<li>Its own dispatcher</li>
</ul>
<p>Outbound:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HttpResponseEncoder</span></code></li>
<li><code class="docutils literal"><span class="pre">ChunkedWriteHandler</span></code></li>
<li><code class="docutils literal"><span class="pre">XSendFile</span></code></li>
</ul>
</div>
</div>
<span id="document-metrics"></span><div class="section" id="metrics">
<h2>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h2>
<p>Xitrum thu thập bộ nhớ JVM heap, CPU, và tình trạng thực thi các action từ mỗi node
Akka cluster của ứng dụng. Nó xuất ra các số liệu trong định dạng dữ liệu JSON. Xitrum cũng để
bạn thu thập cách các dữ liệu khác.</p>
<p>This metrics feature is based on the library <a class="reference external" href="http://metrics.dropwizard.io/3.1.0/">Coda Hale Metrics</a>.</p>
<div class="section" id="thu-thap-metrics">
<h3>Thu thập metrics<a class="headerlink" href="#thu-thap-metrics" title="Permalink to this headline">¶</a></h3>
<div class="section" id="bo-nho-heap-va-cpu">
<h4>Bộ nhớ heap và CPU<a class="headerlink" href="#bo-nho-heap-va-cpu" title="Permalink to this headline">¶</a></h4>
<p>Bộ nhớ JVM heap và CPU sẽ được thu thập như
<a class="reference external" href="http://doc.akka.io/api/akka/2.3.0/index.html#akka.cluster.NodeMetrics">NodeMetrics</a>
từ mỗi node của hệ thống Akka actor.</p>
<p>Bộ nhớ heap:</p>
<img alt="_images/metrics_heapmemory.png" src="_images/metrics_heapmemory.png" />
<p>CPU: số lượng tiến trình và tải trung bình</p>
<img alt="_images/metrics_cpu.png" src="_images/metrics_cpu.png" />
</div>
<div class="section" id="action-metric">
<h4>Action metric<a class="headerlink" href="#action-metric" title="Permalink to this headline">¶</a></h4>
<p>Xitrum thu thập tình trạng thực thi các action của mỗi node như một
<a class="reference external" href="http://metrics.dropwizard.io/3.1.0/getting-started/#histograms">Histogram</a>.
Bạn có thể biết chính các bao nhiêu lần action được thực thim và thời gian
thực thi của những non-async action.</p>
<img alt="_images/metrics_action_count.png" src="_images/metrics_action_count.png" />
<p>Thời gian thực hiện lần gần nhất của một action:</p>
<img alt="_images/metrics_action_time.png" src="_images/metrics_action_time.png" />
</div>
<div class="section" id="thu-thap-cac-so-lieu-tuy-chinh">
<h4>Thu thập các số liệu tùy chỉnh<a class="headerlink" href="#thu-thap-cac-so-lieu-tuy-chinh" title="Permalink to this headline">¶</a></h4>
<p>Ngoài các số liệu mặc định bên trên, bạn có thể thu thập các dữ liệu cho riêng mình.
<code class="docutils literal"><span class="pre">xitrum.Metrics</span></code> có thể truy cập vào <code class="docutils literal"><span class="pre">gauge</span></code>, <code class="docutils literal"><span class="pre">counter</span></code>, <code class="docutils literal"><span class="pre">meter</span></code>,
<code class="docutils literal"><span class="pre">timer</span></code> và <code class="docutils literal"><span class="pre">histogram</span></code>. Vui lòng tham khảo
<a class="reference external" href="http://metrics.dropwizard.io/3.1.0/">Coda Hale Metrics</a> và
<a class="reference external" href="https://github.com/erikvanoosten/metrics-scala">its Scala implementation</a>
để biết cách sử dụng chúng.</p>
<p>Ví dụ về timer:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, Metrics}
import xitrum.annotation.GET

object MyAction {
  lazy val myTimer = Metrics.timer(&quot;myTimer&quot;)
}

@GET(&quot;my/action&quot;)
class MyAction extends Action {
  import MyAction._

  def execute() {
    myTimer.time {
      // Something that you want to measure execution time
      ...
    }
    ...
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="xuat-ra-cac-metric">
<h3>Xuất ra các metric<a class="headerlink" href="#xuat-ra-cac-metric" title="Permalink to this headline">¶</a></h3>
<p>Xitrum xuất ra giá trị mới nhất của metric dưới định đạng JSON sau một chu kỳ
xác định.
Các dữ liệu thu thập được có nhiều biến động, sẽ không được lưu trữ vĩnh viễn</p>
<p>HeapMemory:</p>
<div class="highlight-python"><div class="highlight"><pre>{
  &quot;TYPE&quot;      : &quot;heapMemory&quot;,
  &quot;SYSTEM&quot;    : akka.actor.Address.system,
  &quot;HOST&quot;      : akka.actor.Address.host,
  &quot;PORT&quot;      : akka.actor.Address.port,
  &quot;HASH&quot;      : akka.actor.Address.hashCode,
  &quot;TIMESTAMP&quot; : akka.cluster.NodeMetrics.timestamp,
  &quot;USED&quot;      : Number as byte,
  &quot;COMMITTED&quot; : Number as byte,
  &quot;MAX&quot;       : Number as byte
}
</pre></div>
</div>
<p>CPU:</p>
<div class="highlight-python"><div class="highlight"><pre>{
  &quot;TYPE&quot;              : &quot;cpu&quot;,
  &quot;SYSTEM&quot;            : akka.actor.Address.system,
  &quot;HOST&quot;              : akka.actor.Address.host,
  &quot;PORT&quot;              : akka.actor.Address.port,
  &quot;HASH&quot;              : akka.actor.Address.hashCode,
  &quot;TIMESTAMP&quot;         : akka.cluster.NodeMetrics.timestamp
  &quot;SYSTEMLOADAVERAGE&quot; : Number,
  &quot;CPUCOMBINED&quot;       : Number,
  &quot;PROCESSORS&quot;        : Number
}
</pre></div>
</div>
<p>MetricsRegistry sẽ được phân tách bởi
<a class="reference external" href="http://metrics.dropwizard.io/3.1.0/manual/json/">metrics-json</a>.</p>
<div class="section" id="xitrum-viewer-mac-dinh">
<h4>Xitrum viewer mặc định<a class="headerlink" href="#xitrum-viewer-mac-dinh" title="Permalink to this headline">¶</a></h4>
<p>Xitrum cung cấp metric viewer mặc định tại URL <code class="docutils literal"><span class="pre">/xitrum/metrics/viewer?api_key=&lt;see</span> <span class="pre">xitrum.conf&gt;</span></code>.
URL này hiển thị các đồ thị như trên. Các đồ thị được tạo bởi <a class="reference external" href="http://d3js.org/">D3.js</a>.</p>
<p>URL có thể được tạ ra với:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Config
import xitrum.metrics.XitrumMetricsViewer

url[XitrumMetricsViewer](&quot;api_key&quot; -&gt; Config.xitrum.metrics.get.apiKey)
</pre></div>
</div>
</div>
<div class="section" id="jconsole-viewer">
<h4>Jconsole viewer<a class="headerlink" href="#jconsole-viewer" title="Permalink to this headline">¶</a></h4>
<p>Bạn có thể xem nó với <a class="reference external" href="http://metrics.dropwizard.io/3.1.0/getting-started/#reporting-via-jmx">JVM Reporter</a>.</p>
<img alt="_images/metrics_jconsole.png" src="_images/metrics_jconsole.png" />
<p>Khởi động JMX reporter:</p>
<div class="highlight-python"><div class="highlight"><pre>import com.codahale.metrics.JmxReporter

object Boot {
  def main(args: Array[String]) {
    Server.start()
    JmxReporter.forRegistry(xitrum.Metrics.registry).build().start()
  }
}
</pre></div>
</div>
<p>Sau đó chạy <a class="reference external" href="http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">jconsole</a> command.</p>
</div>
<div class="section" id="hien-thi-metiric-voi-custom-viewer">
<h4>Hiển thị metiric với custom viewer<a class="headerlink" href="#hien-thi-metiric-voi-custom-viewer" title="Permalink to this headline">¶</a></h4>
<p>Metric sẽ được xuất ra tại SockJS URL <code class="docutils literal"><span class="pre">xitrum/metrics/channel</span></code> như JSON.
<code class="docutils literal"><span class="pre">jsAddMetricsNameSpace</span></code> là một JavaScript snippet mà Xitrum cung cấp để tạo
kết nối.</p>
<p>Sử dụng JSON handler của bạn và gọi <code class="docutils literal"><span class="pre">initMetricsChannel</span></code> với handler đó.</p>
<p>Ví dụ về action:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.GET
import xitrum.metrics.MetricsViewer

@GET(&quot;my/metrics/viewer&quot;)
class MySubscriber extends MetricsViewer {
  def execute() {
    jsAddMetricsNameSpace(&quot;window&quot;)
    jsAddToView(&quot;&quot;&quot;
      function onValue(json) {
        console.log(json);
      }
      function onClose(){
        console.log(&quot;channel closed&quot;);
      }
      window.initMetricsChannel(onValue, onClose);
    &quot;&quot;&quot;)
    respondView()
  }
}
</pre></div>
</div>
</div>
<div class="section" id="luu-metric">
<h4>Lưu metric<a class="headerlink" href="#luu-metric" title="Permalink to this headline">¶</a></h4>
<p>Để tiết kiệm bộ nhớ, Xitrum không ghi nhớ các giá trị metric cũ. Nếu bạn muốn lưu metric vào
cơ sở dữ liệu hoặc tệp, bạn cần implement vào subscriber của bạn.</p>
<p>Ví dụ:</p>
<div class="highlight-python"><div class="highlight"><pre>import akka.actor.Actor
import xitrum.metrics.PublisherLookUp

class MySubscriber extends Actor with PublisherLookUp {
  override def preStart() {
    lookUpPublisher()
  }

  def receive = {
    case _ =&gt;
  }

  override def doWithPublisher(globalPublisher: ActorRef) = {
    context.become {
      // When run in multinode environment
      case multinodeMetrics: Set[NodeMetrics] =&gt;
        // Save to DB or write to file.

      // When run in single node environment
      case nodeMetrics: NodeMetrics =&gt;
        // Save to DB or write to file.

      case Publish(registryAsJson) =&gt;
        // Save to DB or write to file.

      case _ =&gt;
    }
  }
}
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-howto"></span><div class="section" id="howto">
<h2>HOWTO<a class="headerlink" href="#howto" title="Permalink to this headline">¶</a></h2>
<p>Chương này bao gồm một số thủ thuật nhỏ.</p>
<div class="section" id="basic-authentication">
<h3>Basic authentication<a class="headerlink" href="#basic-authentication" title="Permalink to this headline">¶</a></h3>
<p>Bạn có thể bảo vệ toàn bộ site hoặc chỉ action nào đó với
<a class="reference external" href="http://en.wikipedia.org/wiki/Basic_access_authentication">basic authentication</a>.</p>
<p>Ghi nhớ rằng Xitrum không hỗ trợ
<a class="reference external" href="http://en.wikipedia.org/wiki/Digest_access_authentication">digest authentication</a>
vì nó cung cấp một cái nhìn sai về bảo mật. Từ đó làm cho digest authentication dễ bị tấn công man-in-the-middle.
Để bảo mật tốt hơn, bạn nên sử dụng HTTPS
(không cần sử dụng Apache hay Nginx như reverse proxy chỉ cần sử dụng HTTPS).</p>
<div class="section" id="cau-hinh-basic-authentication-cho-toan-bo-site">
<h4>Cấu hình basic authentication cho toàn bộ site<a class="headerlink" href="#cau-hinh-basic-authentication-cho-toan-bo-site" title="Permalink to this headline">¶</a></h4>
<p>Trong tệp <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>&quot;basicAuth&quot;: {
  &quot;realm&quot;:    &quot;xitrum&quot;,
  &quot;username&quot;: &quot;xitrum&quot;,
  &quot;password&quot;: &quot;xitrum&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="them-basic-authentication-vao-mot-action">
<h4>Thêm basic authentication vào một action<a class="headerlink" href="#them-basic-authentication-vao-mot-action" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action

class MyAction extends Action {
  beforeFilter {
    basicAuth(&quot;Realm&quot;) { (username, password) =&gt;
      username == &quot;username&quot; &amp;&amp; password == &quot;password&quot;
    }
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="load-cac-tep-config">
<h3>Load các tệp config<a class="headerlink" href="#load-cac-tep-config" title="Permalink to this headline">¶</a></h3>
<div class="section" id="tep-json">
<h4>Tệp JSON<a class="headerlink" href="#tep-json" title="Permalink to this headline">¶</a></h4>
<p>JSON thuận tiện cho việc sử dụng làm các tệp cấu hình với cấu trúc lồng nhau.</p>
<p>Lưu tệp cấu hình của bạn trong thư mục &#8220;config&#8221;. Thư mục này được đặt trong
classpath ở chế độ phát triển bởi build.sbt và trong chế độ sản phẩm bởi  script/runner (và script/runner.bat).</p>
<p>myconfig.json:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span>
  <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="s">&quot;God&quot;</span><span class="p">,</span>
  <span class="s">&quot;password&quot;</span><span class="p">:</span> <span class="s">&quot;Does God need a password?&quot;</span><span class="p">,</span>
  <span class="s">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="s">&quot;Eva&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Load:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Loader

case class MyConfig(username: String, password: String, children: Seq[String])
val myConfig = Loader.jsonFromClasspath[MyConfig](&quot;myconfig.json&quot;)
</pre></div>
</div>
<p>Ghi chú:</p>
<ul class="simple">
<li>Các Key and string phải được dùng dấu nháy kép <code class="docutils literal"><span class="pre">&quot;</span></code>.</li>
<li>Hiện tại, bạn không thể viết comment trong tệp JSON</li>
</ul>
</div>
<div class="section" id="tep-properties">
<h4>Tệp properties<a class="headerlink" href="#tep-properties" title="Permalink to this headline">¶</a></h4>
<p>Bạn cũng có thể các tệp property, nhưng bạn nên sử dụng JSON. Tệp property không phải typesafe, không hỗ trợ UTF-8 và các cấu trúc lồng nhau v.v.</p>
<p>myconfig.properties:</p>
<div class="highlight-python"><div class="highlight"><pre>username = God
password = Does God need a password?
children = Adam, Eva
</pre></div>
</div>
<p>Load:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Loader

// Here you get an instance of java.util.Properties
val properties = Loader.propertiesFromClasspath(&quot;myconfig.properties&quot;)
</pre></div>
</div>
</div>
<div class="section" id="typesafe-tep-cau-hinh">
<h4>Typesafe tệp cấu hình<a class="headerlink" href="#typesafe-tep-cau-hinh" title="Permalink to this headline">¶</a></h4>
<p>Xitrum cũng bao gồm Akka mà Akka sử dụng
<a class="reference external" href="https://github.com/typesafehub/config">thư viện cấu hình</a> tạp bởi
<a class="reference external" href="http://typesafe.com/company">company called Typesafe</a>.
Chúng có thẻ tốt hơn tải các tệp cấu hình.</p>
<p>myconfig.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>username = God
password = Does God need a password?
children = [&quot;Adam&quot;, &quot;Eva&quot;]
</pre></div>
</div>
<p>Load:</p>
<div class="highlight-python"><div class="highlight"><pre>import com.typesafe.config.{Config, ConfigFactory}

val config   = ConfigFactory.load(&quot;myconfig.conf&quot;)
val username = config.getString(&quot;username&quot;)
val password = config.getString(&quot;password&quot;)
val children = config.getStringList(&quot;children&quot;)
</pre></div>
</div>
</div>
</div>
<div class="section" id="serialize-va-deserialize">
<h3>Serialize và deserialize<a class="headerlink" href="#serialize-va-deserialize" title="Permalink to this headline">¶</a></h3>
<p>Để serialize thành <code class="docutils literal"><span class="pre">Array[Byte]</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri
val bytes = SeriDeseri.toBytes(&quot;my serializable object&quot;)
</pre></div>
</div>
<p>Để deserialize các byte ngược trở lại:</p>
<div class="highlight-python"><div class="highlight"><pre>val option = SeriDeseri.fromBytes[MyType](bytes)  // Option[MyType]
</pre></div>
</div>
<p>Nếu bạn muốn lưu tệp:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">xitrum.util.Loader</span>
<span class="n">Loader</span><span class="o">.</span><span class="n">bytesToFile</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="s">&quot;myObject.bin&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To load from the file:</p>
<div class="highlight-python"><div class="highlight"><pre>val bytes = Loader.bytesFromFile(&quot;myObject.bin&quot;)
</pre></div>
</div>
</div>
<div class="section" id="ma-hoa-du-lieu">
<h3>Mã hóa dữ liệu<a class="headerlink" href="#ma-hoa-du-lieu" title="Permalink to this headline">¶</a></h3>
<p>Để mã hóa dữ liệu mà bạn không cần giải mã sau đó (mã hóa một chiều), bạn có thể
sử dụng MD5 hoặc những thuật toán tương tư.</p>
<p>Nếu bạn muốn giải mã về sau, bạn có thể sử dụng tiện ích mà Xitrum cung cấp:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Secure

// Array[Byte]
val encrypted = Secure.encrypt(&quot;my data&quot;.getBytes)

// Option[Array[Byte]]
val decrypted = Secure.decrypt(encrypted)
</pre></div>
</div>
<p>Bạn có thể sử dụng <code class="docutils literal"><span class="pre">xitrum.util.UrlSafeBase64</span></code> để mã hóa và giải mã các dữ liệu nhị phân
thanh chuỗi thông thường (nhúng vào HTML để response chẳng hạn).</p>
<div class="highlight-python"><div class="highlight"><pre>// String that can be included in URL, cookie etc.
val string = UrlSafeBase64.noPaddingEncode(encrypted)

// Option[Array[Byte]]
val encrypted2 = UrlSafeBase64.autoPaddingDecode(string)
</pre></div>
</div>
<p>Nếu bạn có thể phối hợp các quá trình bên trên trong một bước:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri

val mySerializableObject = new MySerializableClass

// String
val encrypted = SeriDeseri.toSecureUrlSafeBase64(mySerializableObject)

// Option[MySerializableClass]
val decrypted = SeriDeseri.fromSecureUrlSafeBase64[MySerializableClass](encrypted)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">SeriDeseri</span></code> sử dụng <a class="reference external" href="https://github.com/twitter/chill">Twitter Chill</a>
để serialize và deserialize. Dữ liệu của bạn phải là serializable.</p>
<p>Bạn có thể chỉ rõ khóa (key) để mã hóa.</p>
<div class="highlight-python"><div class="highlight"><pre>val encrypted = Secure.encrypt(&quot;my data&quot;.getBytes, &quot;my key&quot;)
val decrypted = Secure.decrypt(encrypted, &quot;my key&quot;)
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>val encrypted = SeriDeseri.toSecureUrlSafeBase64(mySerializableObject, &quot;my key&quot;)
val decrypted = SeriDeseri.fromSecureUrlSafeBase64[MySerializableClass](encrypted, &quot;my key&quot;)
</pre></div>
</div>
<p>Nếu bạn không chỉ rõ key nào, <code class="docutils literal"><span class="pre">secureKey</span></code> trong tệp <code class="docutils literal"><span class="pre">xitrum.conf</span></code> trong thư mục config
sẽ được sử dụng.</p>
</div>
<div class="section" id="nhieu-site-voi-cung-mot-ten-mien">
<h3>Nhiều site với cùng một tên miền<a class="headerlink" href="#nhieu-site-voi-cung-mot-ten-mien" title="Permalink to this headline">¶</a></h3>
<p>Neus bạn muốn sử dụng một reverse proxy như Nginx để chạy nhiều site khác nhau
tại cùng một tên miền:</p>
<div class="highlight-python"><div class="highlight"><pre>http://example.com/site1/...
http://example.com/site2/...
</pre></div>
</div>
<p>Bạn có thể cấu hình baseUrl trong <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
<p>Trong mã JS, để có chính xác URL cho Ajax request, sử dụng <code class="docutils literal"><span class="pre">withBaseUrl</span></code>
trong <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># If the current site&#39;s baseUrl is &quot;site1&quot;, the result will be:</span>
<span class="c"># /site1/path/to/my/action</span>
<span class="n">xitrum</span><span class="o">.</span><span class="n">withBaseUrl</span><span class="p">(</span><span class="s">&#39;/path/to/my/action&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="convert-markdown-sang-html">
<h3>Convert Markdown sang HTML<a class="headerlink" href="#convert-markdown-sang-html" title="Permalink to this headline">¶</a></h3>
<p>Nếu bạn đã configured project để sử dụng <a class="reference internal" href="index.html#document-template_engines"><em>Scalate template engine</em></a>,
Bạn chỉ cần phải làm như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>import org.fusesource.scalamd.Markdown
val html = Markdown(&quot;input&quot;)
</pre></div>
</div>
<p>Ngoài ra, bạn cần thêm thành phần phụ thuộc này vào tệp <code class="docutils literal"><span class="pre">build.sbt</span></code> của project.</p>
<div class="highlight-python"><div class="highlight"><pre>libraryDependencies += &quot;org.fusesource.scalamd&quot; %% &quot;scalamd&quot; % &quot;1.6&quot;
</pre></div>
</div>
</div>
<div class="section" id="theo-doi-su-thay-doi-cua-tep">
<h3>Theo dõi sự thay đổi của tệp<a class="headerlink" href="#theo-doi-su-thay-doi-cua-tep" title="Permalink to this headline">¶</a></h3>
<p>Bạn cần thiết lập callback cho
<a class="reference external" href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/StandardWatchEventKinds.html">StandardWatchEventKinds</a>
trên tệp và thư mục.</p>
<div class="highlight-python"><div class="highlight"><pre>import java.nio.file.Paths
import xitrum.util.FileMonitor

val target = Paths.get(&quot;absolute_path_or_path_relative_to_application_directory&quot;).toAbsolutePath
FileMonitor.monitor(FileMonitor.MODIFY, target, { path =&gt;
  // Do some callback with path
  println(s&quot;File modified: $path&quot;)

  // And stop monitoring if necessary
  FileMonitor.unmonitor(FileMonitor.MODIFY, target)
})
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">FileMonitor</span></code> sử dụng
<a class="reference external" href="https://github.com/lloydmeta/schwatcher">Schwatcher</a>.</p>
</div>
<div class="section" id="thu-muc-tam-thoi">
<h3>Thư mục tạm thời<a class="headerlink" href="#thu-muc-tam-thoi" title="Permalink to this headline">¶</a></h3>
<p>Mặc định Xitrum project (xem <code class="docutils literal"><span class="pre">tmpDir</span></code> trong xitrum.conf) sử dụng thư mục <code class="docutils literal"><span class="pre">tmp</span></code>
trong thư mục hoạt động hiện thời để lưu các tệp .scala generate bởi Scalate, các tệp
lớn sẽ được tải lên v.v.</p>
<p>Để lấy đường dẫn đến thư mục đó:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">Config</span><span class="o">.</span><span class="n">xitrum</span><span class="o">.</span><span class="n">tmpDir</span><span class="o">.</span><span class="n">getAbsolutePath</span>
</pre></div>
</div>
<p>Tạo một tệp mới hoặc thư mục trong thư mục đó:</p>
<div class="highlight-python"><div class="highlight"><pre>val file = new java.io.File(xitrum.Config.xitrum.tmpDir, &quot;myfile&quot;)

val dir = new java.io.File(xitrum.Config.xitrum.tmpDir, &quot;mydir&quot;)
dir.mkdirs()
</pre></div>
</div>
</div>
<div class="section" id="stream-video">
<h3>Stream video<a class="headerlink" href="#stream-video" title="Permalink to this headline">¶</a></h3>
<p>Có nhiều cách để steam video. Cách đơn giản nhất:</p>
<ul class="simple">
<li>Cung cấp tệp video .mp4 theo từng đoạn, người dùng có thể xem video trong khi
tải về.</li>
<li>Và sử dụng một HTTP server như Xitrum có hỗ trợ
<a class="reference external" href="http://en.wikipedia.org/wiki/Byte_serving">range requests</a>, để người dùng có
thể nhảy đến đoạn phim mà chưa được tải về.</li>
</ul>
<p>Bạn có thể sử dụng <a class="reference external" href="http://gpac.wp.mines-telecom.fr/mp4box/">MP4Box</a> để  tải nội dụng
của tệp phim một các xen kẽ mỗi 0.5 giây:</p>
<div class="highlight-python"><div class="highlight"><pre>MP4Box -inter 500 movie.mp4
</pre></div>
</div>
</div>
</div>
<span id="document-deps"></span><div class="section" id="dependencies">
<h2>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h2>
<div class="section" id="thu-vien-dependency">
<h3>Thư viện Dependency<a class="headerlink" href="#thu-vien-dependency" title="Permalink to this headline">¶</a></h3>
<p>Xitrum bao gồm một vài thư viện. Trong Xiturm project, bạn có thẻ sử dụng chúng
một cách trực tiếp.</p>
<img alt="_images/deps.png" src="_images/deps.png" />
<p>Các dependency chính:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.scala-lang.org/">Scala</a>:
Xitrum được viết bằng ngôn ngữ Scala.</li>
<li><a class="reference external" href="https://netty.io/">Netty</a>:
Với async HTTP(S) server. Nhiều tính năng trong Xitrum dựa trên Netty như
WebSocket và cung cấp tệp bằng zero copy.</li>
<li><a class="reference external" href="http://akka.io/">Akka</a>:
Với SockJS. Akka phụ thuộc vào <a class="reference external" href="https://github.com/typesafehub/config">Typesafe Config</a>,
Typesafe Config lại được sử dụng trong Xitrum.</li>
</ul>
<p>Các dependencies khác:</p>
<ul class="simple">
<li><a class="reference external" href="http://commons.apache.org/lang/">Commons Lang</a>:
Để escaping dữ liệu JSON.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/glokka">Glokka</a>:
Để clustering SockJS actors.</li>
<li><a class="reference external" href="https://github.com/json4s/json4s">JSON4S</a>:
Để phân tích và tạo dữ liệu JSON. JSON4S phụ thuộc
<a class="reference external" href="http://paranamer.codehaus.org/">Paranamer</a>.</li>
<li><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Rhino">Rhino</a>:
Để Scalate cho việc biên dịch CoffeeScript thành JavaScript.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/sclasner">Sclasner</a>:
For scanning HTTP routes in action classes in .class and .jar files.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/scaposer">Scaposer</a>:
For i18n.</li>
<li><a class="reference external" href="https://github.com/twitter/chill">Twitter Chill</a>:
Để serializing và deserializing cookie và sessions.
Chill dựa trên <a class="reference external" href="http://code.google.com/p/kryo/">Kryo</a>.</li>
<li><a class="reference external" href="http://slf4s.org/">SLF4S</a>, <a class="reference external" href="http://logback.qos.ch/">Logback</a>:
Để logging.</li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">`Skeleton project mới của Xitrum&lt;https://github.com/xitrum-framework/xitrum-new&gt;`_</span></a>&#8216;
bao gồm các công cụ sau:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/scala-xgettext">scala-xgettext</a>:
Để <a class="reference internal" href="index.html#document-i18n"><em>trích chuỗi i18n</em></a> từ tệp .scala files khi biên dịch chúng.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-package">xitrum-package</a>:
Để <a class="reference internal" href="index.html#document-deploy"><em>đóng gói project</em></a>, sẵn sàng cho việc deploy trên production
server.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/scalive">Scalive</a>:
Để két nối Scala console đến một tiến trình JVM đang chạy phục vụ gỡ lỗi trực tiếp.</li>
</ul>
</div>
<div class="section" id="cac-project-lien-quan">
<h3>Các project liên quan<a class="headerlink" href="#cac-project-lien-quan" title="Permalink to this headline">¶</a></h3>
<p>Demos:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">xitrum-new</a>:
Xitrum new project skeleton.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-demos">xitrum-demos</a>:
Bản demo các tính năng của Xitrum.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-placeholder">xitrum-placeholder</a>:
Bản demo API lấy hình ảnh.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/comy">comy</a>:
Bản demo service rút ngon URL.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-multimodule-demo">xitrum-multimodule-demo</a>:
Ví dụ về tạo project multimodule <a class="reference external" href="http://www.scala-sbt.org/">SBT</a>.</li>
</ul>
<p>Plugins:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a>:
Đây là template engine mặc định của Xitrum, preconfigured trong
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">Xitrum new project skeleton</a>.
Bạn có thể thay nó bằng các template engine khác, hoặc loại bỏ hoàng toàn nó
nếu project của bạn không cần bất kì template engine nào. Nó phụ thuộc vào
<a class="reference external" href="http://scalate.fusesource.org/">Scalate</a> và
<a class="reference external" href="https://github.com/chirino/scalamd">Scalamd</a>.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">xitrum-hazelcast</a>:
Để clustering cache và session tại server.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-ko">xitrum-ko</a>:
Cung cấp một số helper cho <a class="reference external" href="http://knockoutjs.com/">Knockoutjs</a>.</li>
</ul>
<p>Các project khác:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-doc">xitrum-doc</a>:
mã nguồn của <a class="reference external" href="http://xitrum-framework.github.io/guide.html">Xitrum Guide</a>.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-framework.github.io">xitrum-hp</a>:
mã nguồn của <a class="reference external" href="http://xitrum-framework.github.io/">Xitrum Homepage</a>.</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html#document-index">Mục Lục</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro">Giới thiệu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#tinh-nang">Tính năng</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#dong-gop">Đóng góp</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-tutorial">Hướng dẫn</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#tao-mot-project-xitrum-moi">Tạo một project Xitrum mới</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#khoi-dong-project-xitrum">Khởi động project Xitrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#import-mot-project-xitrum-vao-eclipse">Import một project Xitrum vào Eclipse</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#import-mot-project-xitrum-vao-intellij">Import một project Xitrum vào IntelliJ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nap-lai-tu-dong-autoreload">Nạp lại tự động (Autoreload)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#chay-project-voi-ides">Chạy project với IDEs</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#chay-project-voi-sbt">Chạy project với SBT</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dcevm">DCEVM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#danh-sach-cac-tap-tin-bi-bo-qua">Danh sách các tập tin bị bỏ qua</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-action_view">Action and view</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#action-thong-thuong">Action thông thường</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#futureaction">FutureAction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#actor-action">Actor action</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#gui-respond-cho-client">Gửi Respond cho client</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#gui-tra-mot-view-file">Gửi trả một      view file</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#ep-kieu-cho-currentaction">Ép kiểu cho currentAction</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id1">Mustache</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#coffeescript">CoffeeScript</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#layout">Layout</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#su-dung-layout-khong-dung-tep-rieng-biet">Sử dụng layout không dùng tệp riêng biệt:</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#truyen-truc-tiep-layout-den-method-respondview">Truyền trực tiếp layout đến method respondView</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#inline-view">Inline view</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#render-fragment">Render fragment</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tra-ve-view-cho-action-khac">Trả về view cho action khác</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#mot-action-nhieu-view">Một action - nhiều view</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#component">Component</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-restful">RESTful APIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#route-cache">Route cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#muc-do-uu-tien-cua-cac-route-first-last">Mức độ ưu tiên của các route (first, last)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nhieu-duong-dan-cho-mot-action">Nhiều đường dẫn cho một action</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#dot-trong-route">Dot trong route</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#regular-expression-trong-route">Regular Expression trong route</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xu-ly-cac-phan-con-lai-cua-route">Xử lý các phần còn lại của route</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#lien-ket-den-mot-action">Liên kết đến một action</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#redirect-den-mot-action-khac">Redirect đến một action khác</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#forward-den-action-khac">Forward đến action khác</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xac-dinh-ajax-request">Xác định Ajax request</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#anti-csrf">Anti-CSRF</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#anticsrfinput-va-anticsrftoken">antiCsrfInput và antiCsrfToken</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#skipcsrfcheck">SkipCsrfCheck</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#kiem-soat-cac-route">Kiểm soát các route</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#lay-tat-ca-cac-request-content">Lấy tất cẩ các request content</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#viet-tai-lieu-api-voi-swagger">Viết tài liệu API với Swagger</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-template_engines">Template engines</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#cau-hinh-template-engine">Cấu hình template engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xoa-template-engine">Xóa template engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tu-tao-template-engine-cho-rieng-ban">Tự tạo template engine cho riêng bạn</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-postback">Postbacks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#layout">Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#form">Form</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#non-form">Non-form</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#hop-thoai-xac-nhan">Hộp thoại xác nhận</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#them-parameter-khac">Thêm parameter khác</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#hien-thi-hinh-dong-khi-load-ajax">Hiện thị hình động khi load Ajax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-xml">XML</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#unescape-xml">Unescape XML</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cac-nhom-xml-element">Các nhóm XML element</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#render-xhtml">Render XHTML</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-js">JavaScript and JSON</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#javascript">JavaScript</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#them-cac-doan-javascript-vao-mot-view">Thêm các đoạn JavaScript vào một view</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#respond-javascript-truc-tiep-khong-su-dung-view">Respond JavaScript trực tiếp không sử dụng view</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#json">JSON</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#plugin-cho-knockout-js">Plugin cho Knockout.js</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-async">Async response</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#websocket">WebSocket</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#sockjs">SockJS</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#chunked-response">Chunked response</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#forever-iframe">Forever iframe</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#event-source">Event Source</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-static">Các tệp tĩnh</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#cung-cap-cac-tep-tinh-tren-dia">Cung cấp các tệp tĩnh trên đĩa</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#index-html-fallback">index.html fallback</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#va-500">404 và 500</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cung-cap-cac-tep-tai-nguyen-trong-classpath-voi-webjars-convention">Cung cấp các tệp tài nguyên trong classpath với WebJars convention</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#webjars">WebJars</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#luu-resource-file-trong-tep-jar-voi-webjars-convention">Lưu resource file trong tệp .jar với WebJars convention</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#respond-mot-tep-trong-classpath">Respond một tệp trong classpath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cache-o-phia-client-voi-etag-va-max-age">Cache ở phía client với ETag và max-age</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#gzip">GZIP</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cache-o-phia-server">Cache ở phía Server</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-flash">Cung cấp flash socket policy file</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-scopes">Scopes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#request">Request</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#cac-loai-parameter">Các loại parameter</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#accesing-parameter">Accesing parameter</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#at">&#8220;at&#8221;</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#atjson">&#8220;atJson&#8221;</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#requestvar">RequestVar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cookie">Cookie</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#su-dung-ki-tu-trong-cookie">Sử dụng kí tự trong cookie</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#session">Session</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#session-clear">session.clear()</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sessionvar">SessionVar</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#luu-tru-session">Lưu trữ session</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#luu-tru-session-o-client-hay-server">Lưu trữ Session ở Client hay Server</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#object-vs-val">object vs. val</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-validation">Validation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#validator-mac-dinh">Validator mặc định</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tao-mot-validator">Tạo một validator</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-upload">Tải lên tệp</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax-style-upload">Ajax style upload</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-filter">Bộ lọc (filter) trong Action</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#before-filters">Before filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#after-filters">After filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#around-filters">Around filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#thu-tu-thuc-hien-cua-cac-bo-loc-filter">Thứ tự thực hiện của các bộ lọc (filter)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cache">Cache ở server</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#cache-o-muc-page-hoac-action">Cache ở mức page hoặc action</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cache-o-muc-object">Cache ở mức object</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xoa-cache">Xóa cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#config">Config</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cache-hoat-dong-nhu-the-nao">Cache hoạt động như thế nào</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-util-locallrucache">xitrum.util.LocalLruCache</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-i18n">I18n</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#viet-cac-internationalized-messages-vao-source-code">Viết các internationalized messages vào source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#trien-khai-cac-tin-nhan-den-tep-pot">Triển khai các tin nhắn đến tệp pot</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#luu-cac-tep-po-tai-dau">Lưu các tệp .po tại đâu</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#chon-ngon-ngu">Chọn ngôn ngữ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#validation-messages">Validation messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#voi-da-so-form">Với đa số form</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#dinh-dang-ngay-va-so">Định dạng ngày và số</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-log">Log</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#su-dung-truc-tiep-doi-tuong-xitrum-log">Sử dụng trực tiếp đối tượng xitrum.Log</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#su-dung-trait-xitrum-log">Sử dụng trait xitrum.Log</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#khong-phai-kiem-tra-log-level-truoc-khi-log">Không phải kiểm tra log level trước khi log</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cau-hinh-log-level">Cấu hình log level</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#log-vao-fluentd">Log vào Fluentd</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deploy">Triển khai ứng dụng web trên server</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#dong-gi-thu-muc">Đóng gí thư mục</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#customize-xitrum-package">Customize xitrum-package</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ket-noi-scala-console-den-mot-tien-trinh-jvm-dang-chay">Kết nối Scala console đến một tiến trình JVM đang chạy</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cai-dat-oracle-jdk-tren-centos-hoac-ubuntu">Cài đặt Oracle JDK trên CentOS hoặc Ubuntu</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#chay-xitrum-o-che-do-san-pham-khi-he-thong-khoi-dong">Chạy Xitrum ở chế độ sản phẩm khi hệ thống khởi động</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#thiet-lap-cong-chuyen-tiep">Thiết lập cổng chuyển tiếp</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cau-hinh-linux-de-ket-noi-hang-loat">Cấu hình Linux để kết nối hàng loạt</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#tang-so-luong-cac-tep-duoc-mo">Tăng số lượng các tệp được mở</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dieu-chinh-kernel">Điều chỉnh kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#luu-y-ve-backlog">Lưu ý về backlog</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#haproxy-tip">HAProxy tip</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nginx-tip">Nginx tip</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#trien-khai-tren-heroku">Triển khai trên Heroku</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#dang-ky-va-tao-repository">Đăng ký và tạo repository</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#tao-procfile">Tạo Procfile</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#thay-doi-thiet-lap-cong">Thay đổi thiết lập cổng</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#xem-log-level">Xem log level</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#tao-alias-cho-xitrum-package">Tạo alias cho <code class="docutils literal"><span class="pre">xitrum-package</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#push-len-heroku">Push lên Heroku</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cluster">Clustering với Akka và Hazelcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-handler">Netty handler</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#kien-truc-cua-netty-handler">Kiến trúc của Netty handler</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tuy-chinh-handler">Tùy chỉnh handler</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-handler-mac-dinh">Xitrum handler mặc định</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-metrics">Metrics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#thu-thap-metrics">Thu thập metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#bo-nho-heap-va-cpu">Bộ nhớ heap và CPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#action-metric">Action metric</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#thu-thap-cac-so-lieu-tuy-chinh">Thu thập các số liệu tùy chỉnh</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xuat-ra-cac-metric">Xuất ra các metric</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#xitrum-viewer-mac-dinh">Xitrum viewer mặc định</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#jconsole-viewer">Jconsole viewer</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#hien-thi-metiric-voi-custom-viewer">Hiển thị metiric với custom viewer</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#luu-metric">Lưu metric</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-howto">HOWTO</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#basic-authentication">Basic authentication</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#cau-hinh-basic-authentication-cho-toan-bo-site">Cấu hình basic authentication cho toàn bộ site</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#them-basic-authentication-vao-mot-action">Thêm basic authentication vào một action</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#load-cac-tep-config">Load các tệp config</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#tep-json">Tệp JSON</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#tep-properties">Tệp properties</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#typesafe-tep-cau-hinh">Typesafe tệp cấu hình</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#serialize-va-deserialize">Serialize và deserialize</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ma-hoa-du-lieu">Mã hóa dữ liệu</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nhieu-site-voi-cung-mot-ten-mien">Nhiều site với cùng một tên miền</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#convert-markdown-sang-html">Convert Markdown sang HTML</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#theo-doi-su-thay-doi-cua-tep">Theo dõi sự thay đổi của tệp</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#thu-muc-tam-thoi">Thư mục tạm thời</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#stream-video">Stream video</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deps">Dependencies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#thu-vien-dependency">Thư viện Dependency</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cac-project-lien-quan">Các project liên quan</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Điều hướng</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">Tài liệu Xitrum Scala Web Framework Guide 3.27.0</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Bản quyền thuộc 2016, Ngoc Dao.
      Được tạo nhờ <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>