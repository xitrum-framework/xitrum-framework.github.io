<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Xitrum Scala Web Framework Guide 3.22 ドキュメント</title>

    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.22',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="None" href="index.html#document-index" />
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li><a href="index.html#document-index">Xitrum Scala Web Framework Guide 3.22 ドキュメント</a> &raquo;</li>
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">

  <div class="section" id="xitrum">
<h1>Xitrum ガイド<a class="headerlink" href="#xitrum" title="このヘッドラインへのパーマリンク">¶</a></h1>

<p>
  <a href="../../xitrum-ja.pdf" title="PDF" style="float:left"><img src="../../../pdf-ja.png"/></a>
  <a href="../../xitrum-ja.pdf" title="PDF">PDF ダウンロード</a></p>
</p>
<div style="clear:both"></div>

<p><a class="reference external" href="http://xitrum-framework.github.io/guide.html">Xitrum ガイドは英語版とロシア語版もあります。</a></p>
<div class="toctree-wrapper compound">
<span id="document-intro"></span><div class="section" id="id1">
<h2>はじめに<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre>+--------------------+
|      Clients       |
+--------------------+
          |
+--------------------+
|       Netty        |
+--------------------+
|       Xitrum       |
| +----------------+ |
| | HTTP(S) Server | |
| |----------------| |
| | Web framework  | |  &lt;- Akka, Hazelcast -&gt; Other instances
| +----------------+ |
+--------------------+
|      Your app      |
+--------------------+
</pre></div>
</div>
<p>Xitrumは <a class="reference external" href="http://netty.io/">Netty</a> と <a class="reference external" href="http://akka.io/">Akka</a> をベースに構築された非同期でスケーラブルなHTTP(S) WEBフレームワークです。</p>
<p>Xitrum <a class="reference external" href="https://groups.google.com/group/xitrum-framework/msg/d6de4865a8576d39">ユーザーの声</a>:</p>
<blockquote>
<div><p>これは本当に印象的な作品である。Liftを除いておそらく最も完全な（そしてとても簡単に使える）Scalaフレームワークです。</p>
<p>XitrumはWebアプリケーションフレームワークの基本的な機能を全て満たしている本物のフルスタックのWebフレームワークである。
とてもうれしいことにそこには、ETag、静的ファイルキャッシュ、自動gzip圧縮があり、
組込みのJSONのコンバータ、インターセプタ、リクエスト/セッション/クッキー/フラッシュの各種スコープ、
サーバー・クライアントにおける統合的バリデーション、内蔵キャッシュ(<a class="reference external" href="http://www.hazelcast.org/">Hazelcast</a>)、i18N、そしてNettyが組み込まれている。
これらの機能を直ぐに使うことができる。ワオ。</p>
</div></blockquote>
<div class="section" id="id3">
<h3>特徴<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li>Scalaの思想に基づく型安全。 全てのAPIは型安全であるべくデザインされています。</li>
<li>Nettyの思想に基づく非同期。 リクエストを捌くアクションは直ぐにレスポンスを返す必要はありません。
ロングポーリング、チャンクレスポンス（ストリーミング）、WebSocket、そしてSockJSをサポートしています。</li>
<li><a class="reference external" href="http://netty.io/">Netty</a> 上に構築された高速HTTP(S) サーバー。
(HTTPSはJavaエンジンとOpenSSLエンジン選択できます。)
Xitrumの静的ファイル配信速度は <a class="reference external" href="https://gist.github.com/3293596">Nginxに匹敵</a> します。</li>
<li>高速なレスポンスを実現する大規模なサーバサイドおよびクライアントサイド双方のキャッシュシステム。
サーバーレイヤでは小さなファイルはメモリにキャッシュされ、大きなファイルはNIOのzero copyを使用して送信されます。
ウェブフレームワークとしてpage、action、そしてobjectをRailsのスタイルでキャッシュすることができます。
<a class="reference external" href="http://code.google.com/speed/page-speed/docs/rules_intro.html">All Google&#8217;s best practices</a> にあるように、
条件付きGETに対してはクライアントサイドキャッシュが適用されます。
もちろんブラウザにリクエストの再送信を強制させることもできます。</li>
<li>静的ファイルに対する <a class="reference external" href="http://en.wikipedia.org/wiki/Byte_serving">Range requests</a> サポート。
この機能により、スマートフォンに対する動画配信や、全てのクライアントに対するファイルダウンロードの停止と再開を実現できます。</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a> 対応。</li>
<li>JAX-RSとRailsエンジンの思想に基づく自動ルートコレクション。全てのルートを１箇所に宣言する必要はありません。
この機能は分散ルーティングと捉えることができます。この機能のおかげでアプリケーションを他のアプリケーションに取り込むことが可能になります。
もしあなたがブログエンジンを作ったならそれをJARにして別のアプリケーションに取り込むだけですぐにブログ機能が使えるようになるでしょう。
ルーティングには更に2つの特徴があります。
ルートの作成（リバースルーティング）は型安全に実施され、
<a class="reference external" href="http://swagger.wordnik.com/">Swagger Doc</a> を使用したルーティングに関するドキュメント作成も可能となります。</li>
<li>クラスファイルおよびルートは開発時にはXitrumによって自動的にリロードされます。</li>
<li>Viewは独立した <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a> テンプレートとして、
またはScalaによるインラインXMLとして、どちらも型安全に記述することが可能です。</li>
<li>クッキーによる（よりスケーラブルな）、<a class="reference external" href="http://www.hazelcast.org/">Hazelcast</a> クラスターによる(よりセキュアな)セッション管理。
Hazelcastは（とても早くて、簡単に）プロセス間分散キャッシュも提供してくれます。
このため別のキャッシュサーバーを用意する必要はなくなります。これはAkkaのpubsub機能にも言えることです。</li>
<li><a class="reference external" href="http://jqueryvalidation.org/">jQuery Validation</a> によるブラウザー、サーバーサイド双方でのバリデーション。</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/GNU_gettext">GNU gettext</a> を使用した国際化対応。
翻訳テキストの抽出は自動で行われるため、プロパティファイルに煩わされることはなくなるでしょう。
翻訳とマージ作業には <a class="reference external" href="http://www.poedit.net/screenshots.php">Poedit</a> のようなパワフルなツールが使えます。
gettextは、他のほとんどのソリューションとは異なり、単数系と複数系の両方の形式をサポートしています。</li>
</ul>
<p>Xitrumは <a class="reference external" href="https://github.com/scalatra/scalatra">Scalatra</a> よりパワフルに、
<a class="reference external" href="http://liftweb.net/">Lift</a> より簡単であることで両者のスペクトルを満たすことを目的としています。
<a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> はScalatraのようにcontroller-firstであり、Liftのような <a class="reference external" href="http://www.assembla.com/wiki/show/liftweb/View_First">view-first</a> ではありません。
多くの開発者にとって馴染み部会controller-firstスタイルです。</p>
<p><a class="reference internal" href="index.html#document-deps"><em>関係プロジェクト</em></a> サンプルやプラグインなどのプロジェクト一覧をご覧ください。</p>
</div>
<div class="section" id="id6">
<h3>貢献者<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> は <a class="reference external" href="https://github.com/xitrum-framework/xitrum">オープンソース</a> プロジェクトです。
<a class="reference external" href="http://groups.google.com/group/xitrum-framework">Google group</a>. のコミュニティに参加してみてください。</p>
<p>貢献者の一覧が <a class="reference external" href="https://github.com/xitrum-framework/xitrum/graphs/contributors">最初の貢献</a> の順番で記載されています:</p>
<p>(*): 現在アクティブなコアメンバー</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/ngocdaothanh">Ngoc Dao (*)</a></li>
<li><a class="reference external" href="https://github.com/alide">Linh Tran</a></li>
<li><a class="reference external" href="https://github.com/earldouglas">James Earl Douglas</a></li>
<li><a class="reference external" href="https://github.com/caiiiycuk">Aleksander Guryanov</a></li>
<li><a class="reference external" href="https://github.com/georgeOsdDev">Takeharu Oshida (*)</a></li>
<li><a class="reference external" href="https://github.com/kimkha">Nguyen Kim Kha</a></li>
<li><a class="reference external" href="https://github.com/murz">Michael Murray</a></li>
</ul>
</div>
</div>
<span id="document-tutorial"></span><div class="section" id="id1">
<h2>チュートリアル<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>本章ではXitrumプロジェクトを作成して実行するところまでを簡単に紹介します。</p>
<p><strong>このチュートリアルではJavaがインストールされたLinux環境を想定しています。</strong></p>
<div class="section" id="xitrum">
<h3>Xitrumプロジェクトの作成<a class="headerlink" href="#xitrum" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>新規のプロジェクトを作成するには
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/archive/master.zip">xitrum-new.zip</a> をダウンロードします。</p>
<div class="highlight-python"><div class="highlight"><pre>wget -O xitrum-new.zip https://github.com/xitrum-framework/xitrum-new/archive/master.zip
</pre></div>
</div>
<p>または:</p>
<div class="highlight-python"><div class="highlight"><pre>curl -L -o xitrum-new.zip https://github.com/xitrum-framework/xitrum-new/archive/master.zip
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>起動<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Scalaのビルドツールとしてデファクトスタンダードである <a class="reference external" href="https://github.com/harrah/xsbt/wiki/Setup">SBT</a> を使用します。
先ほどダウンロードしたプロジェクトには既に SBT 0.13 が <code class="docutils literal"><span class="pre">sbt</span></code> ディレクトリに梱包されています。
SBTを自分でインストールするには、SBTの <a class="reference external" href="https://github.com/harrah/xsbt/wiki/Setup">セットアップガイド</a> を参照してください。</p>
<p>作成したプロジェクトのルートディレクトリで <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">run</span></code> と実行することでXitrumが起動します:</p>
<div class="highlight-python"><div class="highlight"><pre>unzip xitrum-new.zip
cd xitrum-new
sbt/sbt run
</pre></div>
</div>
<p>このコマンドは依存ライブラリ( <a class="reference internal" href="index.html#document-deps"><em>dependencies</em></a> )のダウンロード, およびプロジェクトのコンパイルを実行後、
<code class="docutils literal"><span class="pre">quickstart.Boot</span></code> クラスが実行され、WEBサーバーが起動します。
コンソールには以下の様なルーティング情報が表示されます。</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] Load routes.cache or recollect routes...
[INFO] Normal routes:
GET  /  quickstart.action.SiteIndex
[INFO] SockJS routes:
xitrum/metrics/channel  xitrum.metrics.XitrumMetricsChannel  websocket: true, cookie_needed: false
[INFO] Error routes:
404  quickstart.action.NotFoundError
500  quickstart.action.ServerError
[INFO] Xitrum routes:
GET        /webjars/swagger-ui/2.0.17/index                            xitrum.routing.SwaggerUiVersioned
GET        /xitrum/xitrum.js                                           xitrum.js
GET        /xitrum/metrics/channel                                     xitrum.sockjs.Greeting
GET        /xitrum/metrics/channel/:serverId/:sessionId/eventsource    xitrum.sockjs.EventSourceReceive
GET        /xitrum/metrics/channel/:serverId/:sessionId/htmlfile       xitrum.sockjs.HtmlFileReceive
GET        /xitrum/metrics/channel/:serverId/:sessionId/jsonp          xitrum.sockjs.JsonPPollingReceive
POST       /xitrum/metrics/channel/:serverId/:sessionId/jsonp_send     xitrum.sockjs.JsonPPollingSend
WEBSOCKET  /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocket
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr            xitrum.sockjs.XhrPollingReceive
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr_send       xitrum.sockjs.XhrSend
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr_streaming  xitrum.sockjs.XhrStreamingReceive
GET        /xitrum/metrics/channel/info                                xitrum.sockjs.InfoGET
WEBSOCKET  /xitrum/metrics/channel/websocket                           xitrum.sockjs.RawWebSocket
GET        /xitrum/metrics/viewer                                      xitrum.metrics.XitrumMetricsViewer
GET        /xitrum/metrics/channel/:iframe                             xitrum.sockjs.Iframe
GET        /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocketGET
POST       /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocketPOST
[INFO] HTTP server started on port 8000
[INFO] HTTPS server started on port 4430
[INFO] Xitrum started in development mode
</pre></div>
</div>
<p>初回起動時には、全てのルーティングが収集されログに出力されます。
この情報はアプリケーションのRESTful APIについてドキュメントを書く場合この情報はとても役立つことでしょう。</p>
<p>ブラウザで <a class="reference external" href="http://localhost:8000/">http://localhost:8000</a> もしくは <a class="reference external" href="http://localhost:4430/">https://localhost:4430</a> にアクセスしてみましょう。
次のようなリクエスト情報がコンソールから確認できます。</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] GET quickstart.action.SiteIndex, 1 [ms]
</pre></div>
</div>
</div>
<div class="section" id="eclipse">
<h3>Eclipseプロジェクトの作成<a class="headerlink" href="#eclipse" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>開発環境に <a class="reference external" href="http://scala-ide.org/">Eclipse</a> を使用する場合</p>
<p>プロジェクトディレクトリで以下のコマンドを実行します:</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt eclipse
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">build.sbt</span></code> に記載されたプロジェクト設定に応じてEclipse用の <code class="docutils literal"><span class="pre">.project</span></code> ファイルが生成されます。
Eclipseを起動してインポートしてください。</p>
</div>
<div class="section" id="intellij-idea">
<h3>IntelliJ IDEAプロジェクトの作成<a class="headerlink" href="#intellij-idea" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>開発環境に <a class="reference external" href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> を仕様する場合</p>
<p>プロジェクトディレクトリで以下のコマンドを実行します:</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt gen-idea
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">build.sbt</span></code> に記載されたプロジェクト設定に応じてIntelliJ用の <code class="docutils literal"><span class="pre">.idea</span></code> ファイルが生成されます。
IntelliJを起動してインポートしてください。</p>
</div>
<div class="section" id="id6">
<h3>自動リロード<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>プログラムを再起動することなく .classファイルをリロード（ホットスワップ)することができます。
ただし、プログラムのパフォーマンスと安定性を維持するため、自動リロード機能は開発時のみ使用することを推奨します。</p>
<div class="section" id="ide">
<h4>IDEを使用する場合<a class="headerlink" href="#ide" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>最新のEclipseやIntelliJのようなIDEを使用して開発、起動を行う場合、
デフォルトでIDEがソースコードの変更を監視して、変更があった場合に自動でコンパイルしてくれます。</p>
</div>
<div class="section" id="id7">
<h4>SBTを使用する場合<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>SBTを使用する場合、2つのコンソールを用意する必要があります:</p>
<ul class="simple">
<li>一つ目は <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">run</span></code> を実行します。 このコマンドはプログラムを起動して、 .classファイルに変更があった場合にリロードを行います。</li>
<li>もう一方は <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">~compile</span></code> を実行します。 このコマンドはソースコードの変更を監視して、変更があった場合に .classファイルにコンパイルします。</li>
</ul>
<p>sbtディレクトリには <a class="reference external" href="https://github.com/xitrum-framework/agent7">agent7.jar</a> が含まれます。
このライブラリは、カレントディレクトリ（およびサブディレクトリ)の .classファイルのリロードを担当します。
<code class="docutils literal"><span class="pre">sbt/sbt</span></code> スクリプトの中で <code class="docutils literal"><span class="pre">-javaagent:agent7.jar</span></code> として使用されています。</p>
</div>
<div class="section" id="dcevm">
<h4>DCEVM<a class="headerlink" href="#dcevm" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>通常のJVMはクラスファイルがリロードされた際、メソッドのボディのみ変更が反映されます。
Java HotSpot VM のオープンソース実装である <a class="reference external" href="https://github.com/dcevm/dcevm">DCEVM</a> を使用することで、
ロードしたクラスの再定義をより柔軟に行うことができるようになります。</p>
<p>DCEVMは以下の2つの方法でインストールできます:</p>
<ul class="simple">
<li>インストール済みのJavaへ <a class="reference external" href="https://github.com/dcevm/dcevm/releases">Patch</a> を行う方法</li>
<li><a class="reference external" href="http://dcevm.nentjes.com/">prebuilt</a> バージョンのインストール (こちらのほうが簡単です)</li>
</ul>
<p>パッチを使用してインストールを行う場合:</p>
<ul class="simple">
<li>DCEVMを常に有効にすることができます。</li>
<li>もしくはDCEVMを&#8221;alternative&#8221; JVMとして適用することができます。
この場合、<code class="docutils literal"><span class="pre">java</span></code> コマンドに <code class="docutils literal"><span class="pre">-XXaltjvm=dcevm</span></code> オプションを指定することでDCEVMを使用することができます。
例えば、 <code class="docutils literal"><span class="pre">sbt/sbt</span></code> スクリプトファイルに <code class="docutils literal"><span class="pre">-XXaltjvm=dcevm</span></code> を追記する必要があります。</li>
</ul>
<p>EclipseやIntelliJのようなIDEを使用している場合、DCEVMをプロジェクトの実行JVMに指定する必要があります。</p>
<p>SBTを使用している場合は、 <code class="docutils literal"><span class="pre">java</span></code> コマンドがDCEVMのものを利用できるように <code class="docutils literal"><span class="pre">PATH</span></code> 環境変数を設定する必要があります。
DCEVM自体はクラスの変更をサポートしますが、リロードは行わないため、DCEVMを使用する場合も前述の <code class="docutils literal"><span class="pre">javaagent</span></code> は必要となります。</p>
<p>詳細は <a class="reference external" href="http://javainformed.blogspot.jp/2014/01/jrebel-free-alternative.html">DCEVM - A JRebel free alternative</a> を参照してください。</p>
</div>
</div>
<div class="section" id="ignore">
<h3>ignoreファイルの設定<a class="headerlink" href="#ignore" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="index.html#document-tutorial"><em>チュートリアル</em></a> に沿ってプロジェクトを作成した場合 <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/.gitignore">ignored</a> を参考にignoreファイルを作成してください。</p>
<div class="highlight-python"><div class="highlight"><pre>.*
log
project/project
project/target
target
tmp
</pre></div>
</div>
</div>
</div>
<span id="document-action_view"></span><div class="section" id="action-view">
<h2>Action と view<a class="headerlink" href="#action-view" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Xitrumは3種類のActionを提供しています。
通常の <code class="docutils literal"><span class="pre">Action</span></code> 、<code class="docutils literal"><span class="pre">FutureAction</span></code> 、そして <code class="docutils literal"><span class="pre">ActorAction</span></code> です。</p>
<div class="section" id="action">
<h3>Action<a class="headerlink" href="#action" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends Action {
  def execute() {
    respondText(&quot;Hello&quot;)
  }
}
</pre></div>
</div>
<p>リクエストはNettyのIOスレッド上で直ちに処理されますので、時間かかる処理（ブロック処理）を含めて
はいけません。NettyのIOスレッドを長い時間使ってしまうとNettyは新しいコネクションを受信できなく
なったりリスポンスを返信できなくなったりします。</p>
</div>
<div class="section" id="futureaction">
<h3>FutureAction<a class="headerlink" href="#futureaction" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.FutureAction
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends FutureAction {
  def execute() {
    respondText(&quot;hi&quot;)
  }
}
</pre></div>
</div>
<p>リクエストは下記の <code class="docutils literal"><span class="pre">ActorAction</span></code> と同じスレッドプールが使用されます。これはNettyのスレッドプールとは異なります。</p>
</div>
<div class="section" id="actoraction">
<h3>ActorAction<a class="headerlink" href="#actoraction" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ActionをAkka actorとして定義したい場合、<code class="docutils literal"><span class="pre">ActorAction</span></code> を継承します。</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.concurrent.duration._

import xitrum.ActorAction
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends ActorAction {
  def execute() {
    // See Akka doc about scheduler
    import context.dispatcher
    context.system.scheduler.scheduleOnce(3 seconds, self, System.currentTimeMillis())

    // See Akka doc about &quot;become&quot;
    context.become {
      case pastTime =&gt;
        respondInlineView(s&quot;It&#39;s $pastTime Unix ms 3s ago.&quot;)
    }
  }
}
</pre></div>
</div>
<p>Actorインスタンスはリクエストが発生時に生成されます。このactorインスタンスはコネクションが切断された時、
または <code class="docutils literal"><span class="pre">respondText</span></code> 、 <code class="docutils literal"><span class="pre">respondView</span></code> 等を使用してレスポンスが返された時に停止されます。
チャンクレスポンスの場合すぐには停止されず、最後のチャンクが送信された時点で停止されます。</p>
<p>リクエストは「xitrum」（システム名）というAkka actorシステムのスレッドプール上で処理されます。</p>
</div>
<div class="section" id="id1">
<h3>クライアントへのレスポンス送信<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Actionからクライアントへレスポンスを返すには以下のメソッドを使用します</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondView</span></code>: レイアウトファイルを使用または使用せずに、Viewテンプレートファイルを送信します</li>
<li><code class="docutils literal"><span class="pre">respondInlineView</span></code>: レイアウトファイルを使用または使用せずに、インライン記述されたテンプレートを送信します</li>
<li><code class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></code>: レイアウトファイルを使用せずに文字列を送信します</li>
<li><code class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></code>: contentTypeを&#8221;text/html&#8221;として文字列を送信します</li>
<li><code class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>: ScalaオブジェクトをJSONに変換し、contentTypeを&#8221;application/json&#8221;として送信します</li>
<li><code class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></code> contentTypeを&#8221;application/javascript&#8221;として文字列を送信します</li>
<li><code class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></code>: 上記2つの組み合わせをJSONPとして送信します</li>
<li><code class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></code>: contentTypeを&#8221;application/javascript&#8221;として文字列として送信します</li>
<li><code class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></code>: <cite>respondJs</cite> 、 <cite>respondJsonText</cite> の2つの組み合わせをJSONPとして送信します</li>
<li><code class="docutils literal"><span class="pre">respondBinary</span></code>: バイト配列を送信します</li>
<li><code class="docutils literal"><span class="pre">respondFile</span></code>: ディスクからファイルを直接送信します。 <a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a> を使用するため非常に高速です。</li>
<li><code class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></code>: チャンクレスポンスを送信します</li>
</ul>
</div>
<div class="section" id="view">
<h3>テンプレートViewファイルのレスポンス<a class="headerlink" href="#view" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>全てのActionは <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a> のテンプレートViewファイルと関連付ける事ができます。
上記のレスポンスメソッドを使用して直接レスポンスを送信する代わりに独立したViewファイルを使用することができます。</p>
<p>scr/main/scala/mypackage/MyAction.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends Action {
  def execute() {
    respondView()
  }

  def hello(what: String) = &quot;Hello %s&quot;.format(what)
}
</pre></div>
</div>
<p>scr/main/scalate/mypackage/MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage.MyAction

!!! 5
html
  head
    != antiCsrfMeta
    != xitrumCss
    != jsDefaults
    title Welcome to Xitrum

  body
    a(href={url}) Path to the current action
    p= currentAction.asInstanceOf[MyAction].hello(&quot;World&quot;)

    != jsForView
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xitrumCss</span></code> XitrumのデフォルトCSSファイルです。削除しても問題ありません。</li>
<li><code class="docutils literal"><span class="pre">jsDefaults</span></code> jQuery, jQuery Validate plugin等を含みます。&lt;head&gt;内に記載する必要があります。</li>
<li><code class="docutils literal"><span class="pre">jsForView</span></code> <code class="docutils literal"><span class="pre">jsAddToView</span></code> によって追加されたjavascriptが出力されます。レイアウトの末尾に記載する必要があります。</li>
</ul>
<p>テンプレートファイル内では <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Action.scala">xitrum.Action</a> クラスの全てのメソッドを使用することができます。
また、<cite>unescape</cite> のようなScalateのユーティリティも使用することができます。Scalateのユーティリティについては <a class="reference external" href="http://scalate.fusesource.org/documentation/index.html">Scalate doc</a>　を参照してください。</p>
<p>Scalateテンプレートのデフォルトタイプは <a class="reference external" href="http://scalate.fusesource.org/documentation/jade.html">Jade</a> を使用しています。
ほかには <a class="reference external" href="http://scalate.fusesource.org/documentation/mustache.html">Mustache</a> 、
<a class="reference external" href="http://scalate.fusesource.org/documentation/scaml-reference.html">Scaml</a> 、
<a class="reference external" href="http://scalate.fusesource.org/documentation/ssp-reference.html">Ssp</a> を選択することもできます。
テンプレートのデフォルトタイプを指定は、アプリケーションのconfigディレクトリ内の`xitrum.conf`で設定することができます。</p>
<p><cite>respondView</cite> メソッドにtypeパラメータとして&#8221;jade&#8221;、 &#8220;mustache&#8221;、&#8221;scaml&#8221;、&#8221;ssp&#8221;のいずれか指定することでデフォルトテンプレートタイプをオーバーライドすることも可能です。</p>
<div class="highlight-python"><div class="highlight"><pre>val options = Map(&quot;type&quot; -&gt;&quot;mustache&quot;)
respondView(options)
</pre></div>
</div>
<div class="section" id="currentaction">
<h4>currentActionのキャスト<a class="headerlink" href="#currentaction" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>現在のActionのインスタンスを正確に指定したい場合、<code class="docutils literal"><span class="pre">currentAction</span></code> を指定したActionにキャストします。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span><span class="o">=</span> <span class="n">currentAction</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="p">[</span><span class="n">MyAction</span><span class="p">]</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>複数行で使用する場合、キャスト処理は1度だけ呼び出します。</p>
<div class="highlight-python"><div class="highlight"><pre>- val myAction = currentAction.asInstanceOf[MyAction]; import myAction._

p= hello(&quot;World&quot;)
p= hello(&quot;Scala&quot;)
p= hello(&quot;Xitrum&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>Mustache<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Mustacheについての参考資料:</p>
<ul class="simple">
<li><a class="reference external" href="http://mustache.github.com/mustache.5.html">Mustache syntax</a></li>
<li><a class="reference external" href="http://scalate.fusesource.org/documentation/mustache.html">Scalate implementation</a></li>
</ul>
<p>Mustachのシンタックスは堅牢なため、Jadeで可能な処理の一部は使用できません。</p>
<p>Actionから何か値を渡す場合、<code class="docutils literal"><span class="pre">at</span></code> メソッドを使用します。</p>
<p>Action:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">at</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;Jack&quot;</span>
<span class="n">at</span><span class="p">(</span><span class="s">&quot;xitrumCss&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">xitrumCss</span>
</pre></div>
</div>
<p>Mustache template:</p>
<div class="highlight-python"><div class="highlight"><pre>My name is {{name}}
{{xitrumCss}}
</pre></div>
</div>
<p>注意:以下のキーは予約語のため、 <code class="docutils literal"><span class="pre">at</span></code> メソッドでScalateテンプレートに渡すことはできません。</p>
<ul class="simple">
<li>&#8220;context&#8221;: <code class="docutils literal"><span class="pre">unescape</span></code> 等のメソッドを含むScalateのユーティリティオブジェクト</li>
<li>&#8220;helper&#8221;: 現在のActionオブジェクト</li>
</ul>
</div>
<div class="section" id="coffeescript">
<h4>CoffeeScript<a class="headerlink" href="#coffeescript" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference external" href="http://scalate.fusesource.org/documentation/jade-syntax.html#filters">:coffeescript filter</a> を使用して
CoffeeScriptをテンプレート内に展開することができます。</p>
<div class="highlight-python"><div class="highlight"><pre>body
  :coffeescript
    alert &quot;Hello, Coffee!&quot;
</pre></div>
</div>
<p>出力結果:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;body&gt;
  &lt;script type=&#39;text/javascript&#39;&gt;
    //&lt;![CDATA[
      (function() {
        alert(&quot;Hello, Coffee!&quot;);
      }).call(this);
    //]]&gt;
  &lt;/script&gt;
&lt;/body&gt;
</pre></div>
</div>
<p>注意: ただしこの処理は <a class="reference external" href="http://groups.google.com/group/xitrum-framework/browse_thread/thread/6667a7608f0dc9c7">低速</a> です。</p>
<div class="highlight-python"><div class="highlight"><pre>jade+javascript+1thread: 1-2ms for page
jade+coffesscript+1thread: 40-70ms for page
jade+javascript+100threads: ~40ms for page
jade+coffesscript+100threads: 400-700ms for page
</pre></div>
</div>
<p>高速で動作させるにはあらかじめCoffeeScriptからJavaScriptを生成しておく必要があります。</p>
</div>
</div>
<div class="section" id="id4">
<h3>レイアウト<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">respondView</span></code> または <code class="docutils literal"><span class="pre">respondInlineView</span></code> を使用してViewを送信した場合、
Xitrumはその結果の文字列を、<code class="docutils literal"><span class="pre">renderedView</span></code> の変数としてセットします。
そして現在のActionの <code class="docutils literal"><span class="pre">layout</span></code> メソッドが実行されます。
ブラウザーに送信されるデータは最終的にこのメソッドの結果となります。</p>
<p>デフォルトでは、<code class="docutils literal"><span class="pre">layout</span></code> メソッドは単に <code class="docutils literal"><span class="pre">renderedView</span></code> を呼び出します。
もし、この処理に追加で何かを加えたい場合、オーバーライドします。もし、 <code class="docutils literal"><span class="pre">renderedView</span></code> をメソッド内にインクルードした場合、
そのViewはレイアウトの一部としてインクルードされます。</p>
<p>ポイントは <code class="docutils literal"><span class="pre">layout</span></code> は現在のActionのViewが実行された後に呼ばれるということです。
そしてそこで返却される値がブラウザーに送信される値となります。</p>
<p>このメカニズムはとてもシンプルで魔法ではありません。便宜上Xitrumにはレイアウトが存在しないと考えることができます。
そこにはただ <code class="docutils literal"><span class="pre">layout</span></code> メソッドがあるだけで、全てをこのメソッドで賄うことができます。</p>
<p>典型的な例として、共通レイアウトを親クラスとして使用するパターンを示します。</p>
<p>src/main/scala/mypackage/AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage
import xitrum.Action

trait AppAction extends Action {
  override def layout = renderViewNoLayout[AppAction]()
}
</pre></div>
</div>
<p>src/main/scalate/mypackage/AppAction.jade</p>
<div class="highlight-python"><div class="highlight"><pre>!!! 5
html
  head
    != antiCsrfMeta
    != xitrumCss
    != jsDefaults
    title Welcome to Xitrum

  body
    != renderedView
    != jsForView
</pre></div>
</div>
<p>src/main/scala/mypackage/MyAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends AppAction {
  def execute() {
    respondView()
  }

  def hello(what: String) = &quot;Hello %s&quot;.format(what)
}
</pre></div>
</div>
<p>scr/main/scalate/mypackage/MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage.MyAction

a(href={url}) Path to the current action
p= currentAction.asInstanceOf[MyAction].hello(&quot;World&quot;)
</pre></div>
</div>
<div class="section" id="id5">
<h4>独立したレイアウトファイルを使用しないパターン<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="respondview">
<h4>respondViewにレイアウトを直接指定するパターン<a class="headerlink" href="#respondview" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>val specialLayout = () =&gt;
  DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )

respondView(specialLayout _)
</pre></div>
</div>
</div>
</div>
<div class="section" id="respondinlineview">
<h3>respondInlineView<a class="headerlink" href="#respondinlineview" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>通常ViewはScalateファイルに記載しますが、直接Actionに記載することもできます。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends Action {
  def execute() {
    val s = &quot;World&quot;  // Will be automatically HTML-escaped
    respondInlineView(
      &lt;p&gt;Hello &lt;em&gt;{s}&lt;/em&gt;!&lt;/p&gt;
    )
  }
}
</pre></div>
</div>
</div>
<div class="section" id="renderfragment">
<h3>renderFragment<a class="headerlink" href="#renderfragment" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>MyAction.jadeが
<code class="docutils literal"><span class="pre">scr/main/scalate/mypackage/MyAction.jade</span></code>
にある場合、同じディレクトリにあるフラグメント
<code class="docutils literal"><span class="pre">scr/main/scalate/mypackage/_MyFragment.jade</span></code>
を返す場合:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">renderFragment</span><span class="p">[</span><span class="n">MyAction</span><span class="p">](</span><span class="s">&quot;MyFragment&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>現在のActionが``MyAction``の場合、以下のように省略できます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">renderFragment</span><span class="p">(</span><span class="s">&quot;MyFragment&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>別のアクションに紐付けられたViewをレスポンスする場合<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>次のシンタックスを使用します <code class="docutils literal"><span class="pre">respondView[ClassName]()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.{GET, POST}

@GET(&quot;login&quot;)
class LoginFormAction extends Action {
  def execute() {
    // Respond scr/main/scalate/mypackage/LoginFormAction.jade
    respondView()
  }
}

@POST(&quot;login&quot;)
class DoLoginAction extends Action {
  def execute() {
    val authenticated = ...
    if (authenticated)
      redirectTo[HomeAction]()
    else
      // Reuse the view of LoginFormAction
      respondView[LoginFormAction]()
  }
}
</pre></div>
</div>
<div class="section" id="id7">
<h4>ひとつのアクションに複数のViewを紐付ける方法<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.GET

// These are non-routed actions, for mapping to view template files:
// scr/main/scalate/mypackage/HomeAction_NormalUser.jade
// scr/main/scalate/mypackage/HomeAction_Moderator.jade
// scr/main/scalate/mypackage/HomeAction_Admin.jade
trait HomeAction_NormalUser extends Action
trait HomeAction_Moderator  extends Action
trait HomeAction_Admin      extends Action

@GET(&quot;&quot;)
class HomeAction extends Action {
  def execute() {
    val userType = ...
    userType match {
      case NormalUser =&gt; respondView[HomeAction_NormalUser]()
      case Moderator  =&gt; respondView[HomeAction_Moderator]()
      case Admin      =&gt; respondView[HomeAction_Admin]()
    }
  }
}
</pre></div>
</div>
<p>上記のようにルーティングとは関係ないアクションを記述することは一見して面倒ですが、
この方法はプログラムをタイプセーフに保つことができます。</p>
<p>またはテンプレートのパスを文字列で指定します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_NormalUser&quot;</span><span class="p">)</span>
<span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_Moderator&quot;</span><span class="p">)</span>
<span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_Admin&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">renderView</span></code>, <code class="docutils literal"><span class="pre">renderViewNoLayout</span></code>, <code class="docutils literal"><span class="pre">respondView</span></code>, <code class="docutils literal"><span class="pre">respondViewNoLayout</span></code> では <code class="docutils literal"><span class="pre">src/main/scalate</span></code> からのテンプレートファイルへのパス、
<code class="docutils literal"><span class="pre">renderFragment</span></code> にはフラグメントを配置したディレクトリーへのパスをクラスの代わりに指定することができます。</p>
</div>
</div>
<div class="section" id="component">
<h3>Component<a class="headerlink" href="#component" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複数のViewに対して組み込むことができる再利用可能なコンポーネントを作成することもできます。
コンポーネントのコンセプトはアクションに非常に似ています。
以下のような特徴があります。</p>
<ul class="simple">
<li>コンポーネントはルートを持ちません。すなわち <code class="docutils literal"><span class="pre">execute</span></code> メソッドは不要となります。</li>
<li>コンポーネントは全レスポンスを返すわけではありません。 断片的なviewを &#8220;render&#8221; するのみとなります。
そのため、コンポーネント内部では <code class="docutils literal"><span class="pre">respondXXX</span></code> の代わりに <code class="docutils literal"><span class="pre">renderXXX</span></code> を呼び出す必要があります。</li>
<li>アクションのように、コンポーネントは単一のまたは複数のViewと紐付けるたり、あるいは紐付けないで使用することも可能です。</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.{FutureAction, Component}
import xitrum.annotation.GET

class CompoWithView extends Component {
  def render() = {
    // Render associated view template, e.g. CompoWithView.jade
    // Note that this is renderView, not respondView!
    renderView()
  }
}

class CompoWithoutView extends Component {
  def render() = {
    &quot;Hello World&quot;
  }
}

@GET(&quot;foo/bar&quot;)
class MyAction extends FutureAction {
  def execute() {
    respondView()
  }
}
</pre></div>
</div>
<p>MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage._

!= newComponent[CompoWithView]().render()
!= newComponent[CompoWithoutView]().render()
</pre></div>
</div>
</div>
</div>
<span id="document-restful"></span><div class="section" id="restful-apis">
<h2>RESTful APIs<a class="headerlink" href="#restful-apis" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>XitrumではiPhone、Androidなどのアプリケーション用のRESTful APIsを非常に簡単に記述することができます。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;articles&quot;)
class ArticlesIndex extends Action {
  def execute() {...}
}

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends Action {
  def execute() {...}
}
</pre></div>
</div>
<p>POST、 PUT、 PATCH、 DELETEそしてOPTIONSと同様に
XitrumはHEADリクエストをボディが空のGETリクエストとして自動的に扱います。</p>
<p>通常のブラウザーのようにPUTとDELETEをサポートしていないHTTPクライアントにおいて、
PUTとDELETEを実現するには、リクエストボディに <code class="docutils literal"><span class="pre">_method=put</span></code> や、 <code class="docutils literal"><span class="pre">_method=delete</span></code> を含めることで
可能になります。</p>
<p>アプリケーションの起動時にXitrumはアプリケーションをスキャンし、ルーティングテーブルを作成し出力します。
以下の様なログからアプリケーションがどのようなAPIをサポートしているか知ることができます。</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] Routes:
GET /articles     quickstart.action.ArticlesIndex
GET /articles/:id quickstart.action.ArticlesShow
</pre></div>
</div>
<p>ルーティングはJAX-RSとRailsエンジンの思想に基づいて自動で収集されます。
全てのルートを１箇所に宣言する必要はありません。
この機能は分散ルーティングと捉えることができます。この機能のおかげでアプリケーションを他のアプリケーションに取り込むことが可能になります。
もしあなたがブログエンジンを作ったならそれをJARにして別のアプリケーションに取り込むだけですぐにブログ機能が使えるようになるでしょう。
ルーティングには更に2つの特徴があります。
ルートの作成（リバースルーティング）は型安全に実施され、
<a class="reference external" href="http://swagger.wordnik.com/">Swagger Doc</a> を使用したルーティングに関するドキュメント作成も可能となります。</p>
<div class="section" id="id1">
<h3>ルートのキャッシング<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>起動スピード改善のため、ルートは <code class="docutils literal"><span class="pre">routes.cache</span></code> ファイルにキャッシュされます。
開発時には <code class="docutils literal"><span class="pre">target</span></code> にあるクラスファイル内のルートはキャッシュされません。
もしルートを含む依存ライブラリを更新した場合、 <code class="docutils literal"><span class="pre">routes.cache</span></code> ファイルを削除してください。
また、このファイルはソースコードリポジトリにコミットしないよう気をつけましょう。</p>
</div>
<div class="section" id="firstlast">
<h3>ルートの優先順位(first、last)<a class="headerlink" href="#firstlast" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下の様なルートを作成した場合</p>
<div class="highlight-python"><div class="highlight"><pre>/articles/:id --&gt; ArticlesShow
/articles/new --&gt; ArticlesNew
</pre></div>
</div>
<p>2番目のルートを優先させるには <code class="docutils literal"><span class="pre">&#64;First</span></code> アノテーションを追加します。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.{GET, First}

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends Action {
  def execute() {...}
}

@First  // This route has higher priority than &quot;ArticlesShow&quot; above
@GET(&quot;articles/new&quot;)
class ArticlesNew extends Action {
  def execute() {...}
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Last</span></code> も同じように使用できます。</p>
</div>
<div class="section" id="action">
<h3>Actionへの複数パスの関連付け<a class="headerlink" href="#action" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;image&quot;, &quot;image/:format&quot;)
class Image extends Action {
  def execute() {
    val format = paramo(&quot;format&quot;).getOrElse(&quot;png&quot;)
    // ...
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>ドットを含むルート<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;, &quot;articles/:id.:format&quot;)
class ArticlesShow extends Action {
  def execute() {
    val id     = param[Int](&quot;id&quot;)
    val format = paramo(&quot;format&quot;).getOrElse(&quot;html&quot;)
    // ...
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>正規表現によるルーティング<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ルーティングに正規表現を使用することも可能です。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">GET</span><span class="p">(</span><span class="s">&quot;articles/:id&lt;[0-9]+&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>パスの残り部分の取得<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">/</span></code> 文字が特別でパラメータ名に含まれられません。<code class="docutils literal"><span class="pre">/</span></code> 文字を使いたい場合、以下のように書きます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">GET</span><span class="p">(</span><span class="s">&quot;service/:id/proxy/:*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>以下のパスがマッチされます:</p>
<div class="highlight-python"><div class="highlight"><pre>/service/123/proxy/http://foo.com/bar
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">:*</span></code> を取得:</p>
<div class="highlight-python"><div class="highlight"><pre>val url = param(&quot;*&quot;)  // &quot;http://foo.com/bar&quot;となります
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>アクションへのリンク<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumは型安全指向です。URLは直截記載せずにいかのように参照します:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href={url[ArticlesShow](&quot;id&quot; -&gt; myArticle.id)}&gt;{myArticle.title}&lt;/a&gt;
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>他のアクションへのリダイレクト<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">redirectTo[AnotherAction]()</span></code> を使用します。
リダイレクトについては <a class="reference external" href="http://en.wikipedia.org/wiki/URL_redirection">こちら（英語）</a> を参照してください。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{GET, POST}

@GET(&quot;login&quot;)
class LoginInput extends Action {
  def execute() {...}
}

@POST(&quot;login&quot;)
class DoLogin extends Action {
  def execute() {
    ...
    // After login success
    redirectTo[AdminIndex]()
  }
}

GET(&quot;admin&quot;)
class AdminIndex extends Action {
  def execute() {
    ...
    // Check if the user has not logged in, redirect him to the login page
    redirectTo[LoginInput]()
  }
}
</pre></div>
</div>
<p>また、<code class="docutils literal"><span class="pre">redirecToThis()</span></code> を使用して現在のアクションへリダイレクトさせることも可能です。</p>
</div>
<div class="section" id="id8">
<h3>他のアクションへのフォワード<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">forwardTo[AnotherAction]()</span></code> を使用します。前述の <code class="docutils literal"><span class="pre">redirectTo</span></code> ではブラウザは別のリクエストを送信しますが、
<code class="docutils literal"><span class="pre">forwardTo</span></code> ではリクエストは引き継がれます。</p>
</div>
<div class="section" id="ajax">
<h3>Ajaxリクエストの判定<a class="headerlink" href="#ajax" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">isAjax</span></code> を使用します。</p>
<div class="highlight-python"><div class="highlight"><pre>// In an action
val msg = &quot;A message&quot;
if (isAjax)
  jsRender(&quot;alert(&quot; + jsEscape(msg) + &quot;)&quot;)
else
  respondText(msg)
</pre></div>
</div>
</div>
<div class="section" id="csrf">
<h3>CSRF対策<a class="headerlink" href="#csrf" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>GET以外のリクエストに対して、Xitrumはデフォルトで <a class="reference external" href="http://en.wikipedia.org/wiki/CSRF">Cross-site request forgery</a> 対策を実施します。</p>
<p><code class="docutils literal"><span class="pre">antiCsrfMeta</span></code> Tagsをレイアウト内に記載した場合:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
<p>出力される <code class="docutils literal"><span class="pre">&lt;head&gt;</span></code> は以下のようになります:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    ...
    &lt;meta name=&quot;csrf-token&quot; content=&quot;5402330e-9916-40d8-a3f4-16b271d583be&quot; /&gt;
    ...
  &lt;/head&gt;
  ...
&lt;/html&gt;
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a> をテンプレート内で使用した場合、
このトークンは <code class="docutils literal"><span class="pre">X-CSRF-Token</span></code> ヘッダーとしてGETを除く全てのjQueryによるAjaxリクエストに含まれます。
xitrum.jsは <code class="docutils literal"><span class="pre">jsDefaults</span></code> タグを使用することでロードされます。
もし <code class="docutils literal"><span class="pre">jsDefaults</span></code> を使用したくない場合、以下のようにテンプレートに記載することですることでxitrum.jsをロードすることができます。</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script type=&quot;text/javascript&quot; src={url[xitrum.js]}&gt;&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="csrfcsrf">
<h3>CSRF対策インプットとCSRF対策トークン<a class="headerlink" href="#csrfcsrf" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>XitrumはCSRF対策トークンをリクエストヘッダーの <code class="docutils literal"><span class="pre">X-CSRF-Token</span></code> から取得します。
もしリクエストヘッダーが存在しない場合、Xitrumはリクエストボディの <code class="docutils literal"><span class="pre">csrf-token</span></code> から取得します。
（URLパラメータ内には含まれません。）</p>
<p>前述したメタタグとxitrum.jsを使用せずにformを作成する場合、<code class="docutils literal"><span class="pre">antiCsrfInput</span></code> または
<code class="docutils literal"><span class="pre">antiCsrfToken</span></code> を使用する必要があります。</p>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[AdminAddGroup]})
  != antiCsrfInput
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[AdminAddGroup]})
  input(type=&quot;hidden&quot; name=&quot;csrf-token&quot; value={antiCsrfToken})
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>CSRFチェックの省略<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スマートフォン向けアプリケーションなどでCSRFチェックを省略したい場合、
<code class="docutils literal"><span class="pre">xitrum.SkipCsrfCheck</span></code> を継承してActionを作成します。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SkipCsrfCheck}
import xitrum.annotation.POST

trait Api extends Action with SkipCsrfCheck

@POST(&quot;api/positions&quot;)
class LogPositionAPI extends Api {
  def execute() {...}
}

@POST(&quot;api/todos&quot;)
class CreateTodoAPI extends Api {
  def execute() {...}
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>ルーティングの操作<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumは起動時に自動でルーティングを収集します。
収集されたルーティングにアクセスするには、<a class="reference external" href="http://xitrum-framework.github.io/api/3.17/index.html#xitrum.routing.RouteCollection">xitrum.Config.routes</a> を使用します。</p>
<p>例:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Config, Server}

object Boot {
  def main(args: Array[String]) {
    // サーバーをスタートさせる前にルーティングを操作します。
    val routes = Config.routes

    // クラスを指定してルートを削除する場合
    routes.removeByClass[MyClass]()

    if (demoVersion) {
      // prefixを指定してルートを削除する場合
      routes.removeByPrefix(&quot;premium/features&quot;)

      // &#39;/&#39;が先頭にある場合も同じ効果が得られます
      routes.removeByPrefix(&quot;/premium/features&quot;)
    }

    ...

    Server.start()
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>リクエストコンテンツの取得<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>通常リクエストコンテンツタイプが <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code> 以外の場合、
以下のようにしてリクエストコンテンツを取得することができます。</p>
<p>文字列として取得:</p>
<div class="highlight-python"><div class="highlight"><pre>val body = requestContentString
</pre></div>
</div>
<p>文字列として取得し、JSONへのパース:</p>
<div class="highlight-python"><div class="highlight"><pre>val myMap = requestContentJson[Map[String, Int]]
</pre></div>
</div>
<p>より詳細にリクエストを扱う場合、 <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/FullHttpRequest.html">request.getContent</a> を使用することで
<a class="reference external" href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html">ByteBuf</a> としてリクエストを取得することができます。</p>
</div>
<div class="section" id="swaggerapi">
<h3>SwaggerによるAPIドキュメンテーション<a class="headerlink" href="#swaggerapi" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="https://developers.helloreverb.com/swagger/">Swagger</a> を使用してAPIドキュメントを作成することができます。
<code class="docutils literal"><span class="pre">&#64;Swagger</span></code> アノテーションをドキュメント化したいActionに記述します。
Xitrumはアノテーション情報から <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/API-Declaration">/xitrum/swagger.json</a> を作成します。
このファイルを <a class="reference external" href="https://github.com/wordnik/swagger-ui">Swagger UI</a> で読み込むことでインタラクティブなAPIドキュメンテーションとなります。
XitrumはSwagger UI を内包しており、 <code class="docutils literal"><span class="pre">/xitrum/swagger-ui</span></code> というパスにルーティングします。
例: <a class="reference external" href="http://localhost:8000/xitrum/swagger-ui">http://localhost:8000/xitrum/swagger-ui</a>.</p>
<img alt="_images/swagger.png" src="_images/swagger.png" />
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum-placeholder">サンプル</a> を見てみましょう。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SkipCsrfCheck}
import xitrum.annotation.{GET, Swagger}

@Swagger(
  Swagger.Resource(&quot;image&quot;, &quot;APIs to create images&quot;),
  Swagger.Note(&quot;Dimensions should not be bigger than 2000 x 2000&quot;),
  Swagger.OptStringQuery(&quot;text&quot;, &quot;Text to render on the image, default: Placeholder&quot;),
  Swagger.Produces(&quot;image/png&quot;),
  Swagger.Response(200, &quot;PNG image&quot;),
  Swagger.Response(400, &quot;Width or height is invalid or too big&quot;)
)
trait ImageApi extends Action with SkipCsrfCheck {
  lazy val text = paramo(&quot;text&quot;).getOrElse(&quot;Placeholder&quot;)
}

@GET(&quot;image/:width/:height&quot;)
@Swagger(  // &lt;-- Inherits other info from ImageApi
  Swagger.Nickname(&quot;rect&quot;),
  Swagger.Summary(&quot;Generate rectangle image&quot;),
  Swagger.IntPath(&quot;width&quot;),
  Swagger.IntPath(&quot;height&quot;)
)
class RectImageApi extends Api {
  def execute {
    val width  = param[Int](&quot;width&quot;)
    val height = param[Int](&quot;height&quot;)
    // ...
  }
}

@GET(&quot;image/:width&quot;)
@Swagger(  // &lt;-- Inherits other info from ImageApi
  Swagger.Nickname(&quot;square&quot;),
  Swagger.Summary(&quot;Generate square image&quot;),
  Swagger.IntPath(&quot;width&quot;)
)
class SquareImageApi extends Api {
  def execute {
    val width  = param[Int](&quot;width&quot;)
    // ...
  }
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">/xitrum/swagger</span></code> にアクセスすると
<a class="reference external" href="https://github.com/wordnik/swagger-spec/blob/master/versions/1.2.md">SwaggerのためのJSON</a>
が生成されます。</p>
<p>Swagger UIはこの情報をもとにインタラクティブなAPIドキュメンテーションを作成します。</p>
<p>ここででてきたSwagger.IntPath、Swagger.OptStringQuery以外にも、BytePath, IntQuery, OptStringFormなど
以下の形式でアノテーションを使用することができます。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;Value</span> <span class="pre">type&gt;&lt;Param</span> <span class="pre">type&gt;</span></code> (必須パラメータ)</li>
<li><code class="docutils literal"><span class="pre">Opt&lt;Value</span> <span class="pre">type&gt;&lt;Param</span> <span class="pre">type&gt;</span></code> (オプションパラメータ)</li>
</ul>
<p>Value type: Byte, Int, Int32, Int64, Long, Number, Float, Double, String, Boolean, Date, DateTime</p>
<p>Param type: Path, Query, Body, Header, Form</p>
<p>詳しくは <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/Datatypes">value type</a> 、
<a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/Parameters">param type</a> を参照してください。</p>
</div>
</div>
<span id="document-template_engines"></span><div class="section" id="id1">
<h2>テンプレートエンジン<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="index.html#document-action_view"><em>renderViewやrenderFragment, respondView</em></a> 実行時には
設定ファイルで指定したテンプレートエンジンが使用されます。</p>
<div class="section" id="id2">
<h3>テンプレートエンジンの設定<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a> において
テンプレートエンジンはその種類に応じて以下ように設定することができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">template</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">template</span><span class="o">.</span><span class="n">EngineClassName</span>
</pre></div>
</div>
<p>または:</p>
<div class="highlight-python"><div class="highlight"><pre>template {
  &quot;my.template.EngineClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>デフォルトのテンプレートエンジンは <a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a> です。</p>
</div>
<div class="section" id="id3">
<h3>テンプレートエンジンの削除<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般にRESTfulなAPIのみを持つプロジェクトを作成した場合、renderView、renderFragment、あるいはrespondView
は不要となります。このようなケースではテンプレートエンジンを削除することでプロジェクトを軽量化することができます。
その場合 config/xitrum.conf から <code class="docutils literal"><span class="pre">templateEngine</span></code> の設定をコメントアウトします。</p>
</div>
<div class="section" id="id4">
<h3>テンプレートエンジンの作成<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>独自のテンプレートエンジンを作成する場合、 <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/view/TemplateEngine.scala">xitrum.view.TemplateEngine</a> を継承したクラスを作成します。
そして作成したクラスを config/xitrum.conf にて指定します。</p>
<p>参考例: <a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a></p>
</div>
</div>
<span id="document-postback"></span><div class="section" id="id1">
<h2>ポストバック<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Webアプリケーションには主に以下の2つのユースケースが考えられます。</p>
<ul class="simple">
<li>機械向けのサーバー機能: スマートフォンや他のWebサイトのためのWebサービスとしてRESTfulなAPIを作成する必要があるケース</li>
<li>人間向けのサーバー機能: インタラクティブなWebページを作成する必要があるケース</li>
</ul>
<p>WebフレームワークとしてXitrumはこれら2つのユースケースを簡単に解決することを目指しています。
1つ目のユースケースには、<a class="reference internal" href="index.html#document-restful"><em>RESTful actions</em></a> を適用することで対応し、
2つ目のユースケースには、Ajaxフォームポストバックを適用することで対応します。
ポストバックのアイデアについては以下のリンク（英語）を参照することを推奨します。</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Postback">http://en.wikipedia.org/wiki/Postback</a></li>
<li><a class="reference external" href="http://nitrogenproject.com/doc/tutorial.html">http://nitrogenproject.com/doc/tutorial.html</a></li>
</ul>
<p>Xitrumのポストバック機能は <a class="reference external" href="http://nitrogenproject.com/">Nitrogen</a> を参考にしています。</p>
<div class="section" id="id2">
<h3>レイアウト<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>フォーム<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Articles.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.{GET, POST, First}
import xitrum.validator._

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val id      = param(&quot;id&quot;)
    val article = Article.find(id)
    respondInlineView(
      &lt;h1&gt;{article.title}&lt;/h1&gt;
      &lt;div&gt;{article.body}&lt;/div&gt;
    )
  }
}

@First  // Force this route to be matched before &quot;show&quot;
@GET(&quot;articles/new&quot;)
class ArticlesNew extends AppAction {
  def execute() {
    respondInlineView(
      &lt;form data-postback=&quot;submit&quot; action={url[ArticlesCreate]}&gt;
        &lt;label&gt;Title&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;title&quot; class=&quot;required&quot; /&gt;&lt;br /&gt;

        &lt;label&gt;Body&lt;/label&gt;
        &lt;textarea name=&quot;body&quot; class=&quot;required&quot;&gt;&lt;/textarea&gt;&lt;br /&gt;

        &lt;input type=&quot;submit&quot; value=&quot;Save&quot; /&gt;
      &lt;/form&gt;
    )
  }
}

@POST(&quot;articles&quot;)
class ArticlesCreate extends AppAction {
  def execute() {
    val title   = param(&quot;title&quot;)
    val body    = param(&quot;body&quot;)
    val article = Article.save(title, body)

    flash(&quot;Article has been saved.&quot;)
    jsRedirectTo(show, &quot;id&quot; -&gt; article.id)
  }
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">submit</span></code> イベントがJavaScript上で実行された時、フォームの内容は <code class="docutils literal"><span class="pre">ArticlesCreate</span></code> へポストバックされます。
<code class="docutils literal"><span class="pre">&lt;form&gt;</span></code> の <code class="docutils literal"><span class="pre">action</span></code> 属性は暗号化され、暗号化されたURLはCSRF対策トークンとして機能します。</p>
</div>
<div class="section" id="form">
<h3>formエレメント以外への適用<a class="headerlink" href="#form" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ポストバックはform以外のHTMLエレメントにも適用することができます。</p>
<p>リンク要素への適用例:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot; data-postback=&quot;click&quot; action={url[LogoutAction]}&gt;Logout&lt;/a&gt;
</pre></div>
</div>
<p>リンク要素をクリックした場合LogoutActionへポストバックが行われます。</p>
</div>
<div class="section" id="id4">
<h3>コンファームダイアログ<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンファームダイアログを表する場合:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot; data-postback=&quot;click&quot;
            action={url[LogoutAction]}
            data-confirm=&quot;Do you want to logout?&quot;&gt;Logout&lt;/a&gt;
</pre></div>
</div>
<p>&#8220;キャンセル&#8221;がクリックされた場合、ポストバックの送信は行われません。</p>
</div>
<div class="section" id="id5">
<h3>パラメーターの追加<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>formエレメントに対して  <code class="docutils literal"><span class="pre">&lt;input</span> <span class="pre">type=&quot;hidden&quot;...</span></code> を追加することで追加パラメーターをポストバックリクエストに付与することができます。</p>
<p>formエレメント以外に対しては、以下のように指定します:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot;
   data-postback=&quot;click&quot;
   action={url[ArticlesDestroy](&quot;id&quot; -&gt; item.id)}
   data-params=&quot;_method=delete&quot;
   data-confirm={&quot;Do you want to delete %s?&quot;.format(item.name)}&gt;Delete&lt;/a&gt;
</pre></div>
</div>
<p>または以下のように別のエレメントに指定することも可能です:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;form id=&quot;myform&quot; data-postback=&quot;submit&quot; action={url[SiteSearch]}&gt;
  Search:
  &lt;input type=&quot;text&quot; name=&quot;keyword&quot; /&gt;

  &lt;a class=&quot;pagination&quot;
     href=&quot;#&quot;
     data-postback=&quot;click&quot;
     data-form=&quot;#myform&quot;
     action={url[SiteSearch](&quot;page&quot; -&gt; page)}&gt;{page}&lt;/a&gt;
&lt;/form&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">#myform</span></code> はJQueryのセレクタ形式で追加パラメーターを含むエレメントを指定します。</p>
</div>
<div class="section" id="id6">
<h3>ローディングイメージの表示<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下の様なローディングイメージをAjax通信中に表示する場合、</p>
<img alt="_images/ajax_loading.gif" src="_images/ajax_loading.gif" />
<p>テンプレート内で、<code class="docutils literal"><span class="pre">jsDefault</span></code> (これは <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a> をインクルードするための関数です) の後に次の1行を追加します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">ajaxLoadingImg</span> <span class="o">=</span> <span class="s">&#39;path/to/your/image&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-xml"></span><div class="section" id="xml">
<h2>XML<a class="headerlink" href="#xml" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ScalaではXMLリテラルを記述することが可能です。Xitrumではこの機能をテンプレートエンジンとして利用しています。</p>
<ul class="simple">
<li>ScalaコンパイラによるXMLシンタックスチェックは、Viewの型安全につながります。</li>
<li>ScalaによるXMLの自動的なエスケープは、<a class="reference external" href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a>　攻撃を防ぎます。</li>
</ul>
<p>いくつかのTipsを示します。</p>
<div class="section" id="id1">
<h3>XMLのアンエスケープ<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">scala.xml.Unparsed</span></code> を使用する場合:</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.xml.Unparsed

&lt;script&gt;
  {Unparsed(&quot;if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);&quot;)}
&lt;/script&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:unparsed&gt;</span></code> を使用する場合:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  &lt;xml:unparsed&gt;
    if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);
  &lt;/xml:unparsed&gt;
&lt;/script&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:unparsed&gt;</span></code> は実際の出力には含まれません:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);
&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>XMLエレメントのグループ化<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>&lt;div id=&quot;header&quot;&gt;
  {if (loggedIn)
    &lt;xml:group&gt;
      &lt;b&gt;{username}&lt;/b&gt;
      &lt;a href={url[LogoutAction]}&gt;Logout&lt;/a&gt;
    &lt;/xml:group&gt;
  else
    &lt;xml:group&gt;
      &lt;a href={url[LoginAction]}&gt;Login&lt;/a&gt;
      &lt;a href={url[RegisterAction]}&gt;Register&lt;/a&gt;
    &lt;/xml:group&gt;}
&lt;/div&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:group&gt;</span></code> は実際の出力には含まれません。ユーザーがログイン状態の場合、以下のように出力されます:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;div id=&quot;header&quot;&gt;
  &lt;b&gt;My username&lt;/b&gt;
  &lt;a href=&quot;/login&quot;&gt;Logout&lt;/a&gt;
&lt;/div&gt;
</pre></div>
</div>
</div>
<div class="section" id="xhtml">
<h3>XHTMLの描画<a class="headerlink" href="#xhtml" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>XitrumはviewとレイアウトはXHTMLとして出力します。
レアケースではありますが、もしあなたが直接、出力内容を定義する場合、以下のコードが示す内容に注意してください。</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.xml.Xhtml

val br = &lt;br /&gt;
br.toString            // =&gt; &lt;br&gt;&lt;/br&gt;, この場合ブラウザによってはbrタグが2つあると認識されることがあります。
Xhtml.toXhtml(&lt;br /&gt;)  // =&gt; &quot;&lt;br /&gt;&quot;
</pre></div>
</div>
</div>
</div>
<span id="document-js"></span><div class="section" id="javascript-json">
<h2>JavaScript と JSON<a class="headerlink" href="#javascript-json" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="javascript">
<h3>JavaScript<a class="headerlink" href="#javascript" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>XitrumはjQueryを内包しています。</p>
<p>またいくつかのjsXXXヘルパー関数を提供しています。</p>
<div class="section" id="javascriptview">
<h4>JavaScriptフラグメントをViewに追加する方法<a class="headerlink" href="#javascriptview" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>アクション内では <code class="docutils literal"><span class="pre">jsAddToView</span></code> を呼び出します。（必要であれば何度でも呼び出すことができます）:</p>
<div class="highlight-python"><div class="highlight"><pre>class MyAction extends AppAction {
  def execute() {
    ...
    jsAddToView(&quot;alert(&#39;Hello&#39;)&quot;)
    ...
    jsAddToView(&quot;alert(&#39;Hello again&#39;)&quot;)
    ...
    respondInlineView(&lt;p&gt;My view&lt;/p&gt;)
  }
}
</pre></div>
</div>
<p>レイアウト内では <code class="docutils literal"><span class="pre">jsForView</span></code> を呼び出します:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;flash&quot;&gt;{jsFlash}&lt;/div&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h4>JavaScriptを直接レスポンスする方法<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Javascriptをレスポンスする場合:</p>
<div class="highlight-python"><div class="highlight"><pre>jsRespond(&quot;$(&#39;#error&#39;).html(%s)&quot;.format(jsEscape(&lt;p class=&quot;error&quot;&gt;Could not login.&lt;/p&gt;)))
</pre></div>
</div>
<p>Javascriptでリダイレクトさせる場合:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">jsRedirectTo</span><span class="p">(</span><span class="s">&quot;http://cntt.tv/&quot;</span><span class="p">)</span>
<span class="n">jsRedirectTo</span><span class="p">[</span><span class="n">LoginAction</span><span class="p">]()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="json">
<h3>JSON<a class="headerlink" href="#json" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumは <a class="reference external" href="https://github.com/json4s/json4s">JSON4S</a> を内包しています。
JSONのパースと生成についてはJSON4Sを一読することを推奨します。</p>
<p>ScalaのcaseオブジェクトをJSON文字列に変換する場合:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri

case class Person(name: String, age: Int, phone: Option[String])
val person1 = Person(&quot;Jack&quot;, 20, None)
val json    = SeriDeseri.toJson(person)
val person2 = SeriDeseri.fromJson(json)
</pre></div>
</div>
<p>JSONをレスポンスする場合:</p>
<div class="highlight-python"><div class="highlight"><pre>val scalaData = List(1, 2, 3)  // An example
respondJson(scalaData)
</pre></div>
</div>
<p>JSONはネストした構造が必要な設定ファイルを作成する場合に適しています。</p>
<p>参照 <a class="reference internal" href="index.html#document-howto"><em>設定ファイルの読み込み</em></a></p>
</div>
<div class="section" id="knockout-js">
<h3>Knockout.jsプラグイン<a class="headerlink" href="#knockout-js" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>参照 <a class="reference external" href="https://github.com/xitrum-framework/xitrum-ko">xitrum-ko</a></p>
</div>
</div>
<span id="document-async"></span><div class="section" id="id1">
<h2>非同期レスポンス<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Actionからクライアントへレスポンスを返すには以下のメソッドを使用します</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondView</span></code>: レイアウトファイルを使用または使用せずに、Viewテンプレートファイルを送信します</li>
<li><code class="docutils literal"><span class="pre">respondInlineView</span></code>: レイアウトファイルを使用または使用せずに、インライン記述されたテンプレートを送信します</li>
<li><code class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></code>: レイアウトファイルを使用せずに文字列を送信します</li>
<li><code class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></code>: contentTypeを&#8221;text/html&#8221;として文字列を送信します</li>
<li><code class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>: ScalaオブジェクトをJSONに変換し、contentTypeを&#8221;application/json&#8221;として送信します</li>
<li><code class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></code> contentTypeを&#8221;application/javascript&#8221;として文字列を送信します</li>
<li><code class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></code>: 上記2つの組み合わせをJSONPとして送信します</li>
<li><code class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></code>: contentTypeを&#8221;application/javascript&#8221;として文字列として送信します</li>
<li><code class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></code>: <cite>respondJs</cite> 、 <cite>respondJsonText</cite> の2つの組み合わせをJSONPとして送信します</li>
<li><code class="docutils literal"><span class="pre">respondBinary</span></code>: バイト配列を送信します</li>
<li><code class="docutils literal"><span class="pre">respondFile</span></code>: ディスクからファイルを直接送信します。 <a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a> を使用するため非常に高速です。</li>
<li><code class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></code>: チャンクレスポンスを送信します</li>
</ul>
<p>Xitrumは自動でデフォルトレスポンスを送信しません。自分で明確に上記の``respondXXX``を呼ばなければなりません。
呼ばなければ、XitrumがそのHTTP接続を保持します。あとで``respondXXX``を読んでもいいです。</p>
<p>接続がopen状態になっているかを確認するには``channel.isOpen``を呼びます。<code class="docutils literal"><span class="pre">addConnectionClosedListener</span></code>
でコールバックを登録することもできませす。</p>
<div class="highlight-python"><div class="highlight"><pre>addConnectionClosedListener {
  // 切断されました。
  // リソース開放などをする。
}
</pre></div>
</div>
<p>非同期なのでレスポンスはすぐに送信されません。<code class="docutils literal"><span class="pre">respondXXX</span></code> の戻り値が
<a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html">ChannelFuture</a>
となります。それを使って実際にレスポンスを送信されるコールバックを登録できます。</p>
<p>例えばレスポンスの送信あとに切断するには:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.channel.{ChannelFuture, ChannelFutureListener}

val future = respondText(&quot;Hello&quot;)
future.addListener(new ChannelFutureListener {
  def operationComplete(future: ChannelFuture) {
    future.getChannel.close()
  }
})
</pre></div>
</div>
<p>より短い例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondText</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">addListener</span><span class="p">(</span><span class="n">ChannelFutureListener</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="websocket">
<h3>WebSocket<a class="headerlink" href="#websocket" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import scala.runtime.ScalaRunTime
import xitrum.annotation.WEBSOCKET
import xitrum.{WebSocketAction, WebSocketBinary, WebSocketText, WebSocketPing, WebSocketPong}

@WEBSOCKET(&quot;echo&quot;)
class EchoWebSocketActor extends WebSocketAction {
  def execute() {
    // ここでセッションデータ、リクエストヘッダなどを抽出できますが
    // respondTextやrespondViewなどは使えません。
    // レスポンスするには以下のようにrespondWebSocketXXXを使ってください。

    log.debug(&quot;onOpen&quot;)

    context.become {
      case WebSocketText(text) =&gt;
        log.info(&quot;onTextMessage: &quot; + text)
        respondWebSocketText(text.toUpperCase)

      case WebSocketBinary(bytes) =&gt;
        log.info(&quot;onBinaryMessage: &quot; + ScalaRunTime.stringOf(bytes))
        respondWebSocketBinary(bytes)

      case WebSocketPing =&gt;
        log.debug(&quot;onPing&quot;)

      case WebSocketPong =&gt;
        log.debug(&quot;onPong&quot;)
    }
  }

  override def postStop() {
    log.debug(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>リクエストが来る際に上記のアクターインスタンスが生成されます。次のときにアクターが停止されます:</p>
<ul class="simple">
<li>コネクションが切断されるとき</li>
<li>WebSocketのcloseフレームが受信されるまたは送信されるとき</li>
</ul>
<p>WebSocketフレームを送信するメソッド:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondWebSocketText</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketBinary</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketPing</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketClose</span></code></li>
</ul>
<p><code class="docutils literal"><span class="pre">respondWebSocketPong</span></code> はありません。Xitrumがpingフレームを受信したら自動でpongフレームを
送信するからです。</p>
<p>上記のWebSocketアクションへのURLを取得するには:</p>
<div class="highlight-python"><div class="highlight"><pre>// Scalateテンプレートファイルなどで
val url = webSocketAbsUrl[EchoWebSocketActor]
</pre></div>
</div>
</div>
<div class="section" id="sockjs">
<h3>SockJS<a class="headerlink" href="#sockjs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="https://github.com/sockjs/sockjs-client">SockJS</a> とはWebSocketのようなAPIを提供
するJavaScriptライブラリです。WebSocketを対応しないブラウザで使います。SockJSがブラウザがの
WebSocketの機能の存在を確認し、存在しない場合、他の適切な通信プロトコルへフォルバックします。</p>
<p>WebSocket対応ブラウザ関係なくすべてのブラウザでWebSocket APIを使いたい場合、WebSocketを
直接使わないでSockJSを使ったほうがいいです。</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  var sock = new SockJS(&#39;http://mydomain.com/path_prefix&#39;);
  sock.onopen = function() {
    console.log(&#39;open&#39;);
  };
  sock.onmessage = function(e) {
    console.log(&#39;message&#39;, e.data);
  };
  sock.onclose = function() {
    console.log(&#39;close&#39;);
  };
&lt;/script&gt;
</pre></div>
</div>
<p>XitrumがSockJSライブラリのファイルを含めており、テンプレートなどで以下のように書くだけでいいです:</p>
<div class="highlight-python"><div class="highlight"><pre>...
html
  head
    != jsDefaults
...
</pre></div>
</div>
<p>SockJSは <a class="reference external" href="https://github.com/sockjs/sockjs-protocol">サーバー側の特別処理</a> が必要ですが、
Xitrumがその処理をやってくれるのです。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SockJsAction, SockJsText}
import xitrum.annotation.SOCKJS

@SOCKJS(&quot;echo&quot;)
class EchoSockJsActor extends SockJsAction {
  def execute() {
    // ここでセッションデータ、リクエストヘッダなどを抽出できますが
    // respondTextやrespondViewなどは使えません。
    // レスポンスするには以下のようにrespondSockJsXXXを使ってください。

    log.info(&quot;onOpen&quot;)

    context.become {
      case SockJsText(text) =&gt;
        log.info(&quot;onMessage: &quot; + text)
        respondSockJsText(text)
    }
  }

  override def postStop() {
    log.info(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>新しいSockJSセッションが生成されるとき上記のアクターインスタンスが生成されます。セッションが
停止されるときにアクターが停止されます。</p>
<p>SockJSフレームを送信するには:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondSockJsText</span></code></li>
<li><code class="docutils literal"><span class="pre">respondSockJsClose</span></code></li>
</ul>
<p><a class="reference external" href="https://github.com/sockjs/sockjs-node#various-issues-and-design-considerations">SockJsの注意事項</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>クッキーがSockJsと合わないです。認証を実装するには自分でトークンを生成しSockJsページを埋め込んで、
ブラウザ側からサーバー側へSockJs接続ができたらそのトークンを送信し認証すれば良い。クッキーが
本質的にはそのようなメカニズムで動きます。
</pre></div>
</div>
<p>SockJSクラスタリングを構築するには <a class="reference internal" href="index.html#document-cluster"><em>Akkaでサーバーをクラスタリングする</em></a>
説明をご覧ください。</p>
</div>
<div class="section" id="chunk">
<h3>Chunkレスポンス<a class="headerlink" href="#chunk" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">Chunkレスポンス</a> を送信するには:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">setChunked</span></code> を呼ぶ</li>
<li><code class="docutils literal"><span class="pre">respondXXX</span></code> を呼ぶ（複数回呼んでよい）</li>
<li>最後に <code class="docutils literal"><span class="pre">respondLastChunk</span></code> を呼ぶ</li>
</ol>
<p>Chunkレスポンスはいろいろな応用があります。例えばメモリがかかる大きなCSVファイルを一括で生成
できない場合、生成しながら送信して良い:</p>
<div class="highlight-python"><div class="highlight"><pre>// 「Cache-Control」ヘッダが自動で設定されます:
// 「no-store, no-cache, must-revalidate, max-age=0」
//
// 因みに 「Pragma: no-cache」 ヘッダはレスポンスでなくリクエストのためです:
// http://palizine.plynt.com/issues/2008Jul/cache-control-attributes/
setChunked()

val generator = new MyCsvGenerator

generator.onFirstLine { line =&gt;
  if (channel.isOpen) respondText(header, &quot;text/csv&quot;)
}

generator.onNextLine { line =&gt;
  if (channel.isOpen) respondText(line)
}

generator.onLastLine { line =&gt;
  if (channel.isOpen) {
    respondText(line)
    respondLastChunk()
  }
}

generator.generate()
</pre></div>
</div>
<p>注意:</p>
<ul class="simple">
<li>ヘッダが最初の <code class="docutils literal"><span class="pre">respondXXX</span></code> で送信されます。</li>
<li>末尾ヘッダがオプションで <code class="docutils literal"><span class="pre">respondLastChunk</span></code> に設定できます。</li>
<li><a class="reference internal" href="index.html#document-cache"><em>ページとアクションキャッシュ</em></a> はchunkレスポンスとは使えません。</li>
</ul>
<p>Chunkレスポンスを <code class="docutils literal"><span class="pre">ActorAction</span></code> の組み合わせて
<a class="reference external" href="http://www.cubrid.org/blog/dev-platform/faster-web-page-loading-with-facebook-bigpipe/">Facebook BigPipe</a>
が実装できます。</p>
<div class="section" id="iframe">
<h4>無限iframe<a class="headerlink" href="#iframe" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Chunkレスポンスで <a class="reference external" href="http://en.wikipedia.org/wiki/Comet_%28programming%29">Comet</a> を
実装することが
<a class="reference external" href="http://www.shanison.com/2010/05/10/stop-the-browser-%E2%80%9Cthrobber-of-doom%E2%80%9D-while-loading-comet-forever-iframe/">可能</a>
です。</p>
<p>Iframeを含めるページ:</p>
<div class="highlight-python"><div class="highlight"><pre>...
&lt;script&gt;
  var functionForForeverIframeSnippetsToCall = function() {...}
&lt;/script&gt;
...
&lt;iframe width=&quot;1&quot; height=&quot;1&quot; src=&quot;path/to/forever/iframe&quot;&gt;&lt;/iframe&gt;
...
</pre></div>
</div>
<p>無限 <code class="docutils literal"><span class="pre">&lt;script&gt;</span></code> を生成するアクションで:</p>
<div class="highlight-python"><div class="highlight"><pre>// 準備

setChunked()

// Firefox対応
respondText(&quot;&lt;html&gt;&lt;body&gt;123&quot;, &quot;text/html&quot;)

// curlを含む多くのクライアントが&lt;script&gt;をすぐに出しません。
// 2KB仮データで対応。
for (i &lt;- 1 to 100) respondText(&quot;&lt;script&gt;&lt;/script&gt;\n&quot;)
</pre></div>
</div>
<p>そのあと実際データを送信するには:</p>
<div class="highlight-python"><div class="highlight"><pre>if (channel.isOpen)
  respondText(&quot;&lt;script&gt;parent.functionForForeverIframeSnippetsToCall()&lt;/script&gt;\n&quot;)
else
  // 切断されました。リソースなどを開放。
  // ``addConnectionClosedListener``を使って良い。
</pre></div>
</div>
</div>
<div class="section" id="event-source">
<h4>Event Source<a class="headerlink" href="#event-source" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>参考: <a class="reference external" href="http://dev.w3.org/html5/eventsource/">http://dev.w3.org/html5/eventsource/</a></p>
<p>Event SourceはデータがUTF-8でchunkレスポンスの一種です。</p>
<p>Event Sourceをレスポンスするには <code class="docutils literal"><span class="pre">respondEventSource</span></code> を呼んでください（複数回可）:</p>
<div class="highlight-python"><div class="highlight"><pre>respondEventSource(&quot;data1&quot;, &quot;event1&quot;)  // イベント名が「event1」となります
respondEventSource(&quot;data2&quot;)            // イベント名がデフォルトで「message」となります
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-static"></span><div class="section" id="id1">
<h2>静的ファイル<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id2">
<h3>ディスク上の静的ファイルの配信<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>プロジェクトディレクトリーレイアウト:</p>
<div class="highlight-python"><div class="highlight"><pre>config
public
  favicon.ico
  robots.txt
  404.html
  500.html
  img
    myimage.png
  css
    mystyle.css
  js
    myscript.js
src
build.sbt
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">public</span></code> ディレクトリ内に配置された静的ファイルはXitrumにより自動的に配信されます。
配信されるファイルのURLは以下のようになります。</p>
<div class="highlight-python"><div class="highlight"><pre>/img/myimage.png
/css/mystyle.css
/css/mystyle.min.css
</pre></div>
</div>
<p>プログラムからそのURLを参照するには以下のように指定します:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={publicUrl(&quot;img/myimage.png&quot;)} /&gt;
</pre></div>
</div>
<p>開発環境で非圧縮ファイルをレスポンスし、本番環境でその圧縮ファイルをレスポンスするには(例: 上記の
mystyle.cssとmystyle.min.css):</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={publicUrl(&quot;css&quot;, &quot;mystyle.css&quot;, &quot;mystyle.min.css&quot;)} /&gt;
</pre></div>
</div>
<p>ディスク上の静的ファイルをアクションからレスポンスするには <code class="docutils literal"><span class="pre">respondFile</span></code> を使用します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondFile</span><span class="p">(</span><span class="s">&quot;/absolute/path&quot;</span><span class="p">)</span>
<span class="n">respondFile</span><span class="p">(</span><span class="s">&quot;path/relative/to/the/current/working/directory&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>静的ファイルの配信速度を最適化するため、
ファイル存在チェックを正規表現を使用して回避することができます。
リクエストされたURLが <code class="docutils literal"><span class="pre">pathRegex</span></code> にマッチしない場合、Xitrumはそのリクエストに対して404エラーを返します。</p>
<p>詳しくは <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> の <code class="docutils literal"><span class="pre">pathRegex</span></code> の設定を参照してください。</p>
</div>
<div class="section" id="index-html">
<h3>index.htmlへのフォールバック<a class="headerlink" href="#index-html" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">/foo/bar</span></code> (または <code class="docutils literal"><span class="pre">/foo/bar/</span></code> )へのルートが存在しない場合、
Xitrumは <code class="docutils literal"><span class="pre">public</span></code> ディレクトリ内に、<code class="docutils literal"><span class="pre">public/foo/bar/index.html</span></code> が存在するかチェックします。
もしindex.htmlファイルが存在した場合、Xitrumはクライアントからのリクエストに対してindex.htmlを返します。</p>
</div>
<div class="section" id="id3">
<h3>404 と 500<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">public</span></code> ディレクトリ内の404.htmlと500.htmlはそれぞれ、
マッチするルートが存在しない場合、リクエスト処理中にエラーが発生した場合に使用されます。
独自のエラーハンドラーを使用する場合、以下の様に記述します。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{Error404, Error500}

@Error404
class My404ErrorHandlerAction extends Action {
  def execute() {
    if (isAjax)
      jsRespond(&quot;alert(&quot; + jsEscape(&quot;Not Found&quot;) + &quot;)&quot;)
    else
      renderInlineView(&quot;Not Found&quot;)
  }
}

@Error500
class My500ErrorHandlerAction extends Action {
  def execute() {
    if (isAjax)
      jsRespond(&quot;alert(&quot; + jsEscape(&quot;Internal Server Error&quot;) + &quot;)&quot;)
    else
      renderInlineView(&quot;Internal Server Error&quot;)
  }
}
</pre></div>
</div>
<p>HTTPレスポンスステータスは、アノテーションにより自動的に404または500がセットされるため、
あなたのプログラム上でセットする必要はありません。</p>
</div>
<div class="section" id="webjar">
<h3>WebJarによるクラスパス上のリソースファイルの配信<a class="headerlink" href="#webjar" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="webjars">
<h4>WebJars<a class="headerlink" href="#webjars" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference external" href="http://www.webjars.org/">WebJars</a> はフロントエンドに関わるのライブラリを多く提供しています。
Xitrumプロジェクトではそれらを依存ライブラリとして利用することができます。</p>
<p>例えば <a class="reference external" href="http://underscorejs.org/">Underscore.js</a> を使用する場合、
プロジェクトの <code class="docutils literal"><span class="pre">build.sbt</span></code> に以下のように記述します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;org.webjars&quot;</span> <span class="o">%</span> <span class="s">&quot;underscorejs&quot;</span> <span class="o">%</span> <span class="s">&quot;1.6.0-3&quot;</span>
</pre></div>
</div>
<p>そして.jadeファイルからは以下のように参照します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">script</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="p">{</span><span class="n">webJarsUrl</span><span class="p">(</span><span class="s">&quot;underscorejs/1.6.0&quot;</span><span class="p">,</span> <span class="s">&quot;underscore.js&quot;</span><span class="p">,</span> <span class="s">&quot;underscore-min.js&quot;</span><span class="p">)})</span>
</pre></div>
</div>
<p>開発環境では  <code class="docutils literal"><span class="pre">underscore.js</span></code> が、 本番環境では　<code class="docutils literal"><span class="pre">underscore-min.js</span></code> が、
Xitrumによって自動的に選択されます。</p>
<p>コンパイル結果は以下のようになります:</p>
<div class="highlight-python"><div class="highlight"><pre>/webjars/underscorejs/1.6.0/underscore.js?XOKgP8_KIpqz9yUqZ1aVzw
</pre></div>
</div>
<p>いずれの環境でも同じファイルを使用したい場合:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">script</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="p">{</span><span class="n">webJarsUrl</span><span class="p">(</span><span class="s">&quot;underscorejs/1.6.0/underscore.js&quot;</span><span class="p">)})</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>WebJars形式によるリソースの保存<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>もしあなたがライブラリ開発者で、ライブラリ内のmyimage.pngというファイルを配信したい場合、
<a class="reference external" href="http://www.webjars.org/">WebJars</a> 形式で.jarファイルを作成し
クラスパス上に配置します。 .jarは以下の様な形式となります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">META</span><span class="o">-</span><span class="n">INF</span><span class="o">/</span><span class="n">resources</span><span class="o">/</span><span class="n">webjars</span><span class="o">/</span><span class="n">mylib</span><span class="o">/</span><span class="mf">1.0</span><span class="o">/</span><span class="n">myimage</span><span class="o">.</span><span class="n">png</span>
</pre></div>
</div>
<p>プログラムから参照する場合:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={webJarsUrl(&quot;mylib/1.0/myimage.png&quot;)} /&gt;
</pre></div>
</div>
<p>開発環境、本番環境ともに以下のようにコンパイルされます:</p>
<div class="highlight-python"><div class="highlight"><pre>/webjars/mylib/1.0/myimage.png?xyz123
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>クラスパス上の要素をレスポンスする場合<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference external" href="http://www.webjars.org/">WebJars</a> 形式で保存されていない
クラスパス上の静的ファイル(.jarファイルやディレクトリ)をレスポンスする場合</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;path/relative/to/the/classpath/element&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;akka/actor/Actor.class&quot;</span><span class="p">)</span>
<span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;META-INF/resources/webjars/underscorejs/1.6.0/underscore.js&quot;</span><span class="p">)</span>
<span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;META-INF/resources/webjars/underscorejs/1.6.0/underscore-min.js&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="etagmax-age">
<h3>ETagとmax-ageによるクライアントサイドキャッシュ<a class="headerlink" href="#etagmax-age" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ディスクとクラスパス上にある静的ファイルに対して、Xitrumは自動的に <a class="reference external" href="http://ja.wikipedia.org/wiki/HTTP_ETag">Etag</a> を付加します。</p>
<p>小さなファイルはMD5化してキャッシュされます。
キャッシュエントリーのキーには <code class="docutils literal"><span class="pre">(ファイルパス,</span> <span class="pre">更新日時)</span></code> が使用されます。
ファイルの変更時刻はサーバによって異なる可能性があるため
クラスタ上の各サーバはそれぞれETagキャッシュを保持することになります。</p>
<p>大きなファイルに対しては、更新日時のみがETagに使用されます。
これはサーバ間で異なるETagを保持してしまう可能性があるため完全ではありませんが、
ETagを全く使用しないよりはいくらかマシといえます。</p>
<p><code class="docutils literal"><span class="pre">publicUrl</span></code> と <code class="docutils literal"><span class="pre">resourceUrl</span></code> メソッドは自動的にETagをURLに付加します。:</p>
<div class="highlight-python"><div class="highlight"><pre>resourceUrl(&quot;xitrum/jquery-1.6.4.js&quot;)
=&gt; /resources/public/xitrum/jquery-1.6.4.js?xndGJVH0zA8q8ZJJe1Dz9Q
</pre></div>
</div>
<p>またXitrumは、<code class="docutils literal"><span class="pre">max-age</span></code> と <code class="docutils literal"><span class="pre">Expires</span></code> を <a class="reference external" href="https://developers.google.com/speed/docs/best-practices/caching">一年</a> としてヘッダに設定します。.
ブラウザが最新ファイルを参照しなくなるのではないかと心配する必要はありません。
なぜなら、あなたがディスク上のファイルを変更した場合、その <code class="docutils literal"><span class="pre">更新時刻</span></code> は変化します。
これによって、<code class="docutils literal"><span class="pre">publicUrl</span></code> と <code class="docutils literal"><span class="pre">resourceUrl</span></code> が生成するURLも変わります。
ETagキャッシュもまた、キーが変わったため更新される事になります。</p>
</div>
<div class="section" id="gzip">
<h3>GZIP<a class="headerlink" href="#gzip" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ヘッダーの <code class="docutils literal"><span class="pre">Content-Type</span></code> 属性を元にレスポンスがテキストかどうかを判定し、
<code class="docutils literal"><span class="pre">text/html</span></code>, <code class="docutils literal"><span class="pre">xml/application</span></code> などテキスト形式のレスポンスの場合、Xitrumは自動でgzip圧縮を適用します。</p>
<p>静的なテキストファイルは常にgzipの対象となりますが、動的に生成されたテキストコンテンツに対しては、
パフォーマンス最適化のため1KB以下のものはgzipの対象となりません。</p>
</div>
<div class="section" id="id10">
<h3>サーバーサイドキャッシュ<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ディスクからのファイル読み込みを避けるため、Xitrumは小さな静的ファイルは（テキストファイル以外も）、
LRU(Least Recently Used)キャッシュとしてメモリ上に保持します。</p>
<p>詳しくは <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> の <code class="docutils literal"><span class="pre">small_static_file_size_in_kb</span></code> と <code class="docutils literal"><span class="pre">max_cached_small_static_files</span></code> の設定を参照してください。</p>
</div>
</div>
<span id="document-flash"></span><div class="section" id="flash">
<h2>Flashのソケットポリシーファイル<a class="headerlink" href="#flash" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Flashのソケットポリシーファイルについて:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html">http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html</a></li>
<li><a class="reference external" href="http://www.lightsphere.com/dev/articles/flash_socket_policy.html">http://www.lightsphere.com/dev/articles/flash_socket_policy.html</a></li>
</ul>
<p>FlashのソケットポリシーファイルのプロトコルはHTTPと異なります。</p>
<p>XitrumからFlashのソケットポリシーファイルを返信するには:</p>
<ol class="arabic simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/flash_socket_policy.xml">config/flash_socket_policy.xml</a>
を修正します。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>
を修正し上記ファイルの返信を有効にします。</li>
</ol>
</div>
<span id="document-scopes"></span><div class="section" id="id1">
<h2>スコープ<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id2">
<h3>リクエストスコープ<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="id3">
<h4>リクエストパラメーター<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>リクエストパラメーターには2種類あります:</p>
<ol class="arabic simple">
<li>テキストパラメータ</li>
<li>ファイルアップロードパラメーター（バイナリー）</li>
</ol>
<p>テキストパラメーターは <code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Seq[String]]</span></code> の型をとる3種類があります:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">queryParams</span></code>: URL内の?以降で指定されたパラメーター  例: <code class="docutils literal"><span class="pre">http://example.com/blah?x=1&amp;y=2</span></code></li>
<li><code class="docutils literal"><span class="pre">bodyTextParams</span></code>: POSTリクエストのbodyで指定されたパラメーター</li>
<li><code class="docutils literal"><span class="pre">pathParams</span></code>: URL内に含まれるパラメーター  例: <code class="docutils literal"><span class="pre">GET(&quot;articles/:id/:title&quot;)</span></code></li>
</ol>
<p>これらのパラメーターは上記の順番で、 <code class="docutils literal"><span class="pre">textParams</span></code> としてマージされます。
（後からマージされるパラメーターは上書きとなります。）</p>
<p><code class="docutils literal"><span class="pre">bodyFileParams</span></code> は <code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Seq[</span></code> <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/multipart/FileUpload.html">FileUpload</a> <code class="docutils literal"><span class="pre">]]</span></code> の型をとります。</p>
</div>
<div class="section" id="id4">
<h4>パラメーターへのアクセス<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>アクションからは直接、またはアクセサメソッドを使用して上記のパラメーターを取得することができます。</p>
<p><code class="docutils literal"><span class="pre">textParams</span></code> にアクセスする場合:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">param(&quot;x&quot;)</span></code>: <code class="docutils literal"><span class="pre">String</span></code> を返却します。xが存在しないエクセプションがスローされます。</li>
<li><code class="docutils literal"><span class="pre">paramo(&quot;x&quot;)</span></code>: <code class="docutils literal"><span class="pre">Option[String]</span></code> を返却します。</li>
<li><code class="docutils literal"><span class="pre">params(&quot;x&quot;)</span></code>: <code class="docutils literal"><span class="pre">Seq[String]</span></code> を返却します。 xが存在しない場合``Seq.empty``を返却します。</li>
</ul>
<p><code class="docutils literal"><span class="pre">param[Int](&quot;x&quot;)</span></code> や <code class="docutils literal"><span class="pre">params[Int](&quot;x&quot;)</span></code> と型を指定することでテキストパラメーターを別の型として取得することができます。
テキストパラメーターを独自の型に変換する場合、 <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala-2.11/xitrum/scope/request/ParamAccess.scala">convertTextParam</a> をオーバーライドすることで可能となります。</p>
<p>ファイルアップロードに対しては、<code class="docutils literal"><span class="pre">param[FileUpload](&quot;x&quot;)</span></code> や <code class="docutils literal"><span class="pre">params[FileUpload](&quot;x&quot;)</span></code> でアクセスすることができます。
詳しくは <a class="reference internal" href="index.html#document-upload"><em>ファイルアップロードの章</em></a> を参照してください。</p>
</div>
<div class="section" id="at">
<h4>&#8220;at&#8221;<a class="headerlink" href="#at" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>リクエストの処理中にパラメーターを受け渡し(例えばアクションからViewやレイアウトファイルへ）を行う場合、
<code class="docutils literal"><span class="pre">at</span></code> を使用することで実現できます。 <code class="docutils literal"><span class="pre">at</span></code> は <code class="docutils literal"><span class="pre">scala.collection.mutable.HashMap[String,</span> <span class="pre">Any]</span></code> の型となります。
<code class="docutils literal"><span class="pre">at</span></code> はRailsにおける <code class="docutils literal"><span class="pre">&#64;</span></code> と同じ役割を果たします。</p>
<p>Articles.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val (title, body) = ...  // Get from DB
    at(&quot;title&quot;) = title
    respondInlineView(body)
  }
}
</pre></div>
</div>
<p>AppAction.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;{if (at.isDefinedAt(&quot;title&quot;)) &quot;My Site - &quot; + at(&quot;title&quot;) else &quot;My Site&quot;}&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="atjson">
<h4>&#8220;atJson&#8221;<a class="headerlink" href="#atjson" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><code class="docutils literal"><span class="pre">atJson</span></code> は <code class="docutils literal"><span class="pre">at(&quot;key&quot;)</span></code> を自動的にJSONに変換するヘルパーメソッドです。
ScalaからJavascriptへのモデルの受け渡しに役立ちます。</p>
<p><code class="docutils literal"><span class="pre">atJson(&quot;key&quot;)</span></code> は <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.toJson(at(&quot;key&quot;))</span></code> と同等です。</p>
<p>Action.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>case class User(login: String, name: String)

...

def execute() {
  at(&quot;user&quot;) = User(&quot;admin&quot;, &quot;Admin&quot;)
  respondView()
}
</pre></div>
</div>
<p>Action.ssp:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script type=&quot;text/javascript&quot;&gt;
  var user = ${atJson(&quot;user&quot;)};
  alert(user.login);
  alert(user.name);
&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="requestvar">
<h4>RequestVar<a class="headerlink" href="#requestvar" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>前述の <code class="docutils literal"><span class="pre">at</span></code> はどのような値もmapとして保存できるため型安全ではありません。
より型安全な実装を行うには、 <code class="docutils literal"><span class="pre">at</span></code> のラッパーである <code class="docutils literal"><span class="pre">RequestVar</span></code> を使用します。</p>
<p>RVar.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.RequestVar

object RVar {
  object title extends RequestVar[String]
}
</pre></div>
</div>
<p>Articles.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val (title, body) = ...  // Get from DB
    RVar.title.set(title)
    respondInlineView(body)
  }
}
</pre></div>
</div>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;{if (RVar.title.isDefined) &quot;My Site - &quot; + RVar.title.get else &quot;My Site&quot;}&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h3>クッキー<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クッキーの仕組みについては <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie">Wikipedia</a> を参照してください。</p>
<p>アクション内では <code class="docutils literal"><span class="pre">requestCookies</span></code> を使用することで、ブラウザから送信されたクッキーを <code class="docutils literal"><span class="pre">Map[String,</span> <span class="pre">String]</span></code> として取得できます。</p>
<div class="highlight-python"><div class="highlight"><pre>requestCookies.get(&quot;myCookie&quot;) match {
  case None         =&gt; ...
  case Some(string) =&gt; ...
}
</pre></div>
</div>
<p>ブラウザにクッキーを送信するには、<a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/DefaultCookie.html">DefaultCookie</a> インスタンスを生成し、<a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/Cookie.html">Cookie</a> を含む <code class="docutils literal"><span class="pre">ArrayBuffer</span></code> である、 <code class="docutils literal"><span class="pre">responseCookies</span></code> にアペンドします。</p>
<div class="highlight-python"><div class="highlight"><pre>val cookie = new DefaultCookie(&quot;name&quot;, &quot;value&quot;)
cookie.setHttpOnly(true)  // true: JavaScript cannot access this cookie
responseCookies.append(cookie)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">cookie.setPath(cookiePath)</span></code> でパスをセットせずにクッキーを使用した場合、
クッキーのパスはサイトルート(<code class="docutils literal"><span class="pre">xitrum.Config.withBaseUrl(&quot;/&quot;)</span></code>)が設定されます。</p>
<p>ブラウザから送信されたクッキーを削除するには、&#8221;max-age&#8221;を0にセットした同じ名前のクッキーをサーバーから送信することで、
ブラウザは直ちにクッキーを消去します。</p>
<p>ブラウザがウィンドウを閉じた際にクッキーが消去されるようにするには、&#8221;max-age&#8221;に <code class="docutils literal"><span class="pre">Long.MinValue</span></code> をセットします:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cookie</span><span class="o">.</span><span class="n">setMaxAge</span><span class="p">(</span><span class="n">Long</span><span class="o">.</span><span class="n">MinValue</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference external" href="http://mrcoles.com/blog/cookies-max-age-vs-expires/">Internet Explorer は &#8220;max-age&#8221; をサポートしていません</a> 。
しかし、Nettyが適切に判断して &#8220;max-age&#8221; または &#8220;expires&#8221; を設定してくれるので心配する必要はありません！</p>
<p>ブラウザはクッキーの属性をサーバーに送信することはありません。
ブラウザは <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie#Cookie_attributes">name-value pairs</a> のみを送信します。</p>
<p>署名付きクッキーを使用して、クッキーの改ざんを防ぐには、
<code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.toSecureUrlSafeBase64</span></code> と <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.fromSecureUrlSafeBase64</span></code> を使用します。
詳しくは <a class="reference internal" href="index.html#document-howto"><em>データの暗号化</em></a> を参照してください。</p>
<div class="section" id="id6">
<h4>クッキーに使用可能な文字<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>クッキーには <a class="reference external" href="http://stackoverflow.com/questions/1969232/allowed-characters-in-cookies">任意の文字</a> を使用することができます。
例えば、UTF-8の文字として使用する場合、UTF-8にエンコードする必要があります。
エンコーディング処理には <code class="docutils literal"><span class="pre">xitrum.utill.UrlSafeBase64</span></code> または <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri</span></code> を使用することができます。</p>
<p>クッキー書き込みの例:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.util.CharsetUtil
import xitrum.util.UrlSafeBase64

val value   = &quot;&quot;&quot;{&quot;identity&quot;:&quot;example@gmail.com&quot;,&quot;first_name&quot;:&quot;Alexander&quot;}&quot;&quot;&quot;
val encoded = UrlSafeBase64.noPaddingEncode(value.getBytes(CharsetUtil.UTF_8))
val cookie  = new DefaultCookie(&quot;profile&quot;, encoded)
responseCookies.append(cookie)
</pre></div>
</div>
<p>クッキー読み込みの例:</p>
<div class="highlight-python"><div class="highlight"><pre>requestCookies.get(&quot;profile&quot;).foreach { encoded =&gt;
  UrlSafeBase64.autoPaddingDecode(encoded).foreach { bytes =&gt;
    val value = new String(bytes, CharsetUtil.UTF_8)
    println(&quot;profile: &quot; + value)
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h3>セッション<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>セッションの保存、破棄、暗号化などはXitrumが自動的に行いますので、頭を悩ます必要はありません。</p>
<p>アクション内で、 <code class="docutils literal"><span class="pre">session</span></code> を使用することができます。 セッションは <code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Any]</span></code> のインスタンスです。 <code class="docutils literal"><span class="pre">session</span></code> に保存されるものはシリアライズ可能である必要があります。</p>
<p>ログインユーザーに対してユーザー名をセッションに保存する例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">session</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">userId</span>
</pre></div>
</div>
<p>ユーザーがログインしているかどうかを判定するには、
セッションにユーザーネームが保存されているかをチェックするだけですみます:</p>
<div class="highlight-python"><div class="highlight"><pre>if (session.isDefinedAt(&quot;userId&quot;)) println(&quot;This user has logged in&quot;)
</pre></div>
</div>
<p>ユーザーIDをセッションに保存し、アクセス毎にデータベースからユーザー情報を取得するやり方は多くの場合推奨されます。
アクセス毎にユーザーが更新(権限や認証を含む)されているかを知ることができます。</p>
<div class="section" id="session-clear">
<h4>session.clear()<a class="headerlink" href="#session-clear" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>1行のコードで <a class="reference external" href="http://guides.rubyonrails.org/security.html#session-fixation">session fixation</a> の脅威からアプリケーションを守ることができます。</p>
<p>session fixation については上記のリンクを参照してください。session fixation攻撃を防ぐには、
ユーザーログインを行うアクションにて、 <code class="docutils literal"><span class="pre">session.clear()</span></code> を呼び出します。</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;login&quot;)
class LoginAction extends Action {
  def execute() {
    ...
    session.clear()  // Reset first before doing anything else with the session
    session(&quot;userId&quot;) = userId
  }
}
</pre></div>
</div>
<p>ログアウト処理においても同様に <code class="docutils literal"><span class="pre">session.clear()</span></code> を呼び出しましょう。</p>
</div>
<div class="section" id="sessionvar">
<h4>SessionVar<a class="headerlink" href="#sessionvar" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><code class="docutils literal"><span class="pre">RequestVar</span></code> と同じく、より型安全な実装を提供します。
例では、ログイン後にユーザー名をセッションに保存します。</p>
<p>SessionVarの定義:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.SessionVar

object SVar {
  object username extends SessionVar[String]
}
</pre></div>
</div>
<p>ログイン処理成功後:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SVar</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
</pre></div>
</div>
<p>ユーザー名の表示:</p>
<div class="highlight-python"><div class="highlight"><pre>if (SVar.username.isDefined)
  &lt;em&gt;{SVar.username.get}&lt;/em&gt;
else
  &lt;a href={url[LoginAction]}&gt;Login&lt;/a&gt;
</pre></div>
</div>
<ul class="simple">
<li>SessionVarの削除方法: <code class="docutils literal"><span class="pre">SVar.username.remove()</span></code></li>
<li>セッション全体のクリア方法: <code class="docutils literal"><span class="pre">session.clear()</span></code></li>
</ul>
</div>
<div class="section" id="id9">
<h4>セッションストア<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Xitrumはセッションストアを3種類提供しています。
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a> において、セッションストアを設定することができます。</p>
<p>CookieSessionStore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Store sessions on client side</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">xitrum</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">CookieSessionStore</span>
</pre></div>
</div>
<p>LruSessionStore:</p>
<div class="highlight-python"><div class="highlight"><pre># Simple in-memory server side session store
store {
  &quot;xitrum.local.LruSessionStore&quot; {
    maxElems = 10000
  }
}
</pre></div>
</div>
<p>クラスター環境で複数のサーバーを起動する場合、<a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast</a> をクラスタ間で共有するセッションストアとして使用することができます。</p>
<p>CookieSessionStore やHazelcastを使用する場合、セッションに保存するデータはシリアライズ可能である必要があります。
シリアライズできないデータを保存しなければいけない場合、 LruSessionStore を使用してください。
LruSessionStore を使用して、クラスタ環境で複数のサーバーを起動する場合、
スティッキーセッションをサポートしたロードバランサーを使用する必要があります。</p>
<p>一般的に、上記のデフォルトセッションストアのいずれかで事足りることですが、
もし特殊なセッションストアを独自に実装する場合
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/scope/session/SessionStore.scala">SessionStore</a>
または
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/scope/session/ServerSessionStore.scala">ServerSessionStore</a>
を継承し、抽象メソッドを実装してください。</p>
<p>設定ファイルには、使用するセッションストアに応じて以下のように設定できます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">store</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">StoreClassName</span>
</pre></div>
</div>
<p>または:</p>
<div class="highlight-python"><div class="highlight"><pre>store {
  &quot;my.session.StoreClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>スケーラブルにする場合、できるだけセッションはクライアントサイドのクッキーに保存しましょう
（リアライズ可能かつ`4KB以下 &lt;<a class="reference external" href="http://stackoverflow.com/questions/640938/what-is-the-maximum-size-of-a-web-browsers-cookies-key">http://stackoverflow.com/questions/640938/what-is-the-maximum-size-of-a-web-browsers-cookies-key</a>&gt;`_）。
サーバーサイド（メモリ上やDB）には必要なときだけセッションを保存しましょう。</p>
<p>参考（英語）:
<a class="reference external" href="http://www.technicalinfo.net/papers/WebBasedSessionManagement.html">Web Based Session Management - Best practices in managing HTTP-based client sessions</a>.</p>
</div>
</div>
<div class="section" id="object-vs-val">
<h3>object vs. val<a class="headerlink" href="#object-vs-val" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">val</span></code> の代わりに <code class="docutils literal"><span class="pre">object</span></code> を使用してください。</p>
<p><strong>以下のような実装は推奨されません</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre>object RVar {
  val title    = new RequestVar[String]
  val category = new RequestVar[String]
}

object SVar {
  val username = new SessionVar[String]
  val isAdmin  = new SessionVar[Boolean]
}
</pre></div>
</div>
<p>上記のコードはコンパイルには成功しますが、正しく動作しません。
なぜなら valは内部ではルックアップ時にクラス名が使用されます。
<code class="docutils literal"><span class="pre">title</span></code> と <code class="docutils literal"><span class="pre">category</span></code> が <code class="docutils literal"><span class="pre">val</span></code> を使用して宣言された場合、いずれもクラス名は &#8220;xitrum.RequestVar&#8221; となります。
同じことは <code class="docutils literal"><span class="pre">username</span></code> と <code class="docutils literal"><span class="pre">isAdmin</span></code> にも当てはまります。</p>
</div>
</div>
<span id="document-validation"></span><div class="section" id="id1">
<h2>バリデーション<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Xitrumは、クライアントサイドでのバリデーション用に <a class="reference external" href="http://bassistance.de/jquery-plugins/jquery-plugin-validation/">jQuery Validation plugin</a> を内包し、サーバーサイドにおけるバリデーション用のいくつかのヘルパーを提供します。</p>
<div class="section" id="id2">
<h3>デフォルトバリデーター<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.validator</span></code> パッケージには以下の3つのメソッドが含まれます:</p>
<div class="highlight-python"><div class="highlight"><pre>check(value): Boolean
message(name, value): Option[String]
exception(name, value)
</pre></div>
</div>
<p>もしバリデーション結果が <code class="docutils literal"><span class="pre">false</span></code> である場合、
<code class="docutils literal"><span class="pre">message</span></code> は <code class="docutils literal"><span class="pre">Some(error,</span> <span class="pre">message)</span></code> を返却します。
<code class="docutils literal"><span class="pre">exception</span></code> メソッドは <code class="docutils literal"><span class="pre">xitrum.exception.InvalidInput(error</span> <span class="pre">message)</span></code> をスローします。</p>
<p>バリデーターは何処ででも使用することができます。</p>
<p>Actionで使用する例:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.validator.Required

@POST(&quot;articles&quot;)
class CreateArticle {
  def execute() {
    val title = param(&quot;tite&quot;)
    val body  = param(&quot;body&quot;)
    Required.exception(&quot;Title&quot;, title)
    Required.exception(&quot;Body&quot;,  body)

    // Do with the valid title and body...
  }
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">try</span></code> 、 <code class="docutils literal"><span class="pre">catch</span></code> ブロックを使用しない場合において、バリデーションエラーとなると、
xitrumは自動でエラーをキャッチし、クライアントに対してエラーメッセージを送信します。
これはクライアントサイドでバリデーションを正しく書いている場合や、webAPIを作成する場合において便利なやり方と言えます。</p>
<p>Modelで使用する例:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.validator.Required

case class Article(id: Int = 0, title: String = &quot;&quot;, body: String = &quot;&quot;) {
  def isValid           = Required.check(title)   &amp;&amp;     Required.check(body)
  def validationMessage = Required.message(title) orElse Required.message(body)
}
</pre></div>
</div>
<p>デフォルトバリデーターの一覧については　<a class="reference external" href="https://github.com/xitrum-framework/xitrum/tree/master/src/main/scala/xitrum/validator">xitrum.validator パッケージ</a> を参照してください。</p>
</div>
<div class="section" id="id3">
<h3>カスタムバリデーターの作成<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/validator/Validator.scala">xitrum.validator.Validator</a> を継承し、
<code class="docutils literal"><span class="pre">check</span></code> メソッドと、 <code class="docutils literal"><span class="pre">message</span></code> メソッドのみ実装することでカスタムバリデーターとして使用できます。</p>
<p>また、 <a class="reference external" href="http://commons.apache.org/proper/commons-validator/">Commons Validator</a> を使用することもできます。</p>
</div>
</div>
<span id="document-upload"></span><div class="section" id="id1">
<h2>ファイルアップロード<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="index.html#document-scopes"><em>スコープ</em></a> についてもご覧ください。</p>
<p>ファイルアップロードformで <code class="docutils literal"><span class="pre">enctype</span></code> を <code class="docutils literal"><span class="pre">multipart/form-data</span></code> に設定します。</p>
<p>MyUpload.scalate:</p>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[MyUpload]} enctype=&quot;multipart/form-data&quot;)
  != antiCsrfInput

  label ファイルを選択してください:
  input(type=&quot;file&quot; name=&quot;myFile&quot;)

  button(type=&quot;submit&quot;) アップロード
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">MyUpload</span></code> アクション:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.handler.codec.http.multipart.FileUpload

val myFile = param[FileUpload](&quot;myFile&quot;)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">myFile</span></code> が <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/multipart/FileUpload.html">FileUpload</a>
のインスタンスとなります。そのメソッドを使ってファイル名の取得やファイル移動などができます。</p>
<p>小さいファイル (16KB未満)はメモリへ保存されます。大きいファイルはシステムのテンポラリ・ディレクトリ
または xitrum.conf の <code class="docutils literal"><span class="pre">xitrum.request.tmpUploadDir</span></code> に設定したディレクトリへ一時的に保存されます。
一時ファイルはコネクション切断やレスポンス送信のあとに削除されます。</p>
<div class="section" id="ajax">
<h3>Ajax風ファイルアップロード<a class="headerlink" href="#ajax" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>世の中にはAjax風ファイルアップロードJavaScriptライブラリがいっぱいあります。その動作としては
隠しiframeやFlashなどで上記の <code class="docutils literal"><span class="pre">multipart/form-data</span></code> をサーバー側へ送ります。
ファイルが具体的にどんなパラメータで送信されるかはXitrumアクセスログで確認できます。</p>
</div>
</div>
<span id="document-filter"></span><div class="section" id="id1">
<h2>アクションフィルター<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="before">
<h3>Beforeフィルター<a class="headerlink" href="#before" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Beforeフィルターが関数でアクションの実行前に実行されます。</p>
<ul class="simple">
<li>入力: なし</li>
<li>出力: true/false</li>
</ul>
<p>Beforeフィルターを複数設定できます。その中、ーつのbeforeフィルターが何かrespondするとき、その
フィルターの後ろのフィルターとアクションの実行が中止されます。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;before_filter&quot;)
class MyAction extends Action {
  beforeFilter {
    log.info(&quot;我行くゆえに我あり&quot;)
  }

  // This method is run after the above filters
  def execute() {
    respondInlineView(&quot;Beforeフィルターが実行されました。ログを確認してください。&quot;)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="after">
<h3>Afterフィルター<a class="headerlink" href="#after" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Afterフィルターが関数でアクションの実行後に実行されます。</p>
<ul class="simple">
<li>入力: なし</li>
<li>出力: 無視されます</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;after_filter&quot;)
class MyAction extends Action {
  afterFilter {
    log.info(&quot;実行時刻: &quot; + System.currentTimeMillis())
  }

  def execute() {
    respondText(&quot;Afterフィルターが実行されました。ログを確認してください。&quot;)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="around">
<h3>Aroundフィルター<a class="headerlink" href="#around" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;around_filter&quot;)
class MyAction extends Action {
  aroundFilter { action =&gt;
    val begin = System.currentTimeMillis()
    action()
    val end   = System.currentTimeMillis()
    val dt    = end - begin
    log.info(s&quot;アクション実行時間: $dt [ms]&quot;)
  }

  def execute() {
    respondText(&quot;Around filter should have been run, please check the log&quot;)
  }
}
</pre></div>
</div>
<p>Aroundフィルターが複数あるとき、それらは外・内の構成でネストされます。</p>
</div>
<div class="section" id="id2">
<h3>フィルターの実行順番<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li>Beforeフィルター -&gt; aroundフィルター -&gt; afterフィルター。</li>
<li>あるbeforeフィルタがfalseを返すと、残りフィルターが実行されません。</li>
<li>Aroundフィルターが実行されると、すべてのafterフィルター実行されます。</li>
<li>外のaround filterフィルターが <code class="docutils literal"><span class="pre">action</span></code> 引数を呼ばないと、内のaroundフィルターが実行されません。</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>before1 -true-&gt; before2 -true-&gt; +--------------------+ --&gt; after1 --&gt; after2
                                | around1 (1 of 2)   |
                                |   around2 (1 of 2) |
                                |     action         |
                                |   around2 (2 of 2) |
                                | around1 (2 of 2)   |
                                +--------------------+
</pre></div>
</div>
</div>
</div>
<span id="document-cache"></span><div class="section" id="id1">
<h2>サーバーサイドキャッシュ<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="index.html#document-cluster"><em>クラスタリング</em></a> の章についても参照してください。</p>
<p>より高速なレスポンスの実現のために、Xitrumはクライアントサイドとサーバーサイドにおける広範なキャッシュ機能を提供します。</p>
<p>サーバーサイドレイヤーでは、小さなファイルはメモリ上にキャッシュされ、大きなファイルはNIOのゼロコピーを使用して送信されます。
Xitrumの静的ファイルの配信速度は <a class="reference external" href="https://gist.github.com/3293596">Nginxと同等</a> です。</p>
<p>Webフレームワークのレイヤーでは、Railsのスタイルでページやアクション、オブジェクトをキャッシュすることができます。</p>
<p><a class="reference external" href="http://code.google.com/speed/page-speed/docs/rules_intro.html">All Google&#8217;s best practices（英語）</a>
にあるように、条件付きGETリクエストはクライアントサイドでキャッシュされます。</p>
<p>動的なコンテンツに対しては、もしファイルが作成されてから変更されない場合、クライアントに積極的にキャッシュするように
ヘッダーをセットする必要があります。
このケースでは、<code class="docutils literal"><span class="pre">setClientCacheAggressively()</span></code> をアクションにて呼び出すことで実現できます。</p>
<p>クライアントにキャッシュさせたくない場合もあるでしょう、
そういったケースでは、 <code class="docutils literal"><span class="pre">setNoClientCache()</span></code> をアクションにて呼び出すことで実現できます。</p>
<p>サーバーサイドキャッシュについては以下のサンプルでより詳しく説明します。</p>
<div class="section" id="id2">
<h3>ページまたはアクションのキャッシュ<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{GET, CacheActionMinute, CachePageMinute}

@GET(&quot;articles&quot;)
@CachePageMinute(1)
class ArticlesIndex extends Action {
  def execute() {
    ...
  }
}

@GET(&quot;articles/:id&quot;)
@CacheActionMinute(1)
class ArticlesShow extends Action {
  def execute() {
    ...
  }
}
</pre></div>
</div>
<p>&#8220;page cache&#8221; と &#8220;acation cache&#8221; の期間設定は <a class="reference external" href="http://guides.rubyonrails.org/caching_with_rails.html">Ruby on Rails</a> を参考にしています。</p>
<p>リクエスト処理プロセスの順番は以下のようになります。</p>
<ol class="arabic simple">
<li>リクエスト -&gt; (2) Beforeフィルター -&gt; (3) アクション execute method -&gt; (4) レスポンス</li>
</ol>
<p>初回のリクエスト時に、Xitrumはレスポンスを指定された期間だけキャッシュします。
<code class="docutils literal"><span class="pre">&#64;CachePageMinute(1)</span></code> や <code class="docutils literal"><span class="pre">&#64;CacheActionMinute(1)</span></code> は1分間キャッシュすることを意味します。
Xitrumはレスポンスステータスが &#8220;200 OK&#8221; の場合のみキャッシュします。
そのため、レスポンスステータスが &#8220;500 Internal Server Error&#8221; や &#8220;302 Found&#8221; (リダイレクト) となるレスポンスはキャッシュされせん。</p>
<p>同じアクションに対する2回目以降のリクエストは、もし、キャッシュされたレスポンスが有効期間内の場合、
Xitrumはすぐにキャッシュされたレスポンスを返却します:</p>
<ul class="simple">
<li>ページキャッシュの場合、 処理プロセスは、　(1) -&gt; (4) となります。</li>
<li>アクションキャッシュの場合、 (1) -&gt; (2) -&gt; (4), またはBeforeフィルターが&#8221;false&#8221;を返した場合 (1) -&gt; (2) となります。</li>
</ul>
<p>すなわち、actionキャッシュとpageキャッシュとの違いは、Beforeフィルターを実施するか否かになります。</p>
<p>一般に、ページキャッシュは全てのユーザーに共通なレスポンスの場合に使用します。
アクションキャッシュは、Beforeフィルターを通じて、例えばユーザーのログイン状態チェックなどを行い、キャッシュされたレスポンスを &#8220;ガード&#8221; する場合に用います:</p>
<ul class="simple">
<li>ログインしている場合、キャッシュされたレスポンスにアクセス可能。</li>
<li>ログインしていない場合、ログインページヘリダイレクト。</li>
</ul>
</div>
<div class="section" id="id3">
<h3>オブジェクトのキャッシュ<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="http://xitrum-framework.github.io/api/3.17/index.html#xitrum.Cache">xitrum.Cache</a> のインスタンスである、
<code class="docutils literal"><span class="pre">xitrum.Config.xitrum.cache</span></code> を使用することができます。</p>
<p>明示的な有効期限を設定しない場合:</p>
<ul class="simple">
<li>put(key, value)</li>
</ul>
<p>有効期限を設定する場合:</p>
<ul class="simple">
<li>putSecond(key, value, seconds)</li>
<li>putMinute(key, value, minutes)</li>
<li>putHour(key, value, hours)</li>
<li>putDay(key, value, days)</li>
</ul>
<p>存在しない場合のみキャッシュする方法:</p>
<ul class="simple">
<li>putIfAbsent(key, value)</li>
<li>putIfAbsentSecond(key, value, seconds)</li>
<li>putIfAbsentMinute(key, value, minutes)</li>
<li>putIfAbsentHour(key, value, hours)</li>
<li>putIfAbsentDay(key, value, days)</li>
</ul>
</div>
<div class="section" id="id4">
<h3>キャッシュの削除<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ページまたはアクションキャッシュの削除:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">removeAction</span><span class="p">[</span><span class="n">MyAction</span><span class="p">]</span>
</pre></div>
</div>
<p>オブジェクトキャッシュの削除:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>指定したプレフィックスで始まるキー全てを削除:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">removePrefix</span><span class="p">(</span><span class="n">keyPrefix</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">removePrefix</span></code> を使用することで、プレフィックスを使用した階層的なキャッシュを構築することができます。</p>
<p>例えば、記事に関連する要素をキャッシュしたい場合、記事が変更された時に関連するキャッシュは以下の方法で全てクリアできます。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Config.xitrum.cache

// prefixを使用してキャッシュします。
val prefix = &quot;articles/&quot; + article.id
cache.put(prefix + &quot;/likes&quot;, likes)
cache.put(prefix + &quot;/comments&quot;, comments)

// articleに関連する全てのキャッシュを削除したい場合は以下のようにします。
cache.remove(prefix)
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>キャッシュエンジンの設定<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumのキャッシュ機能はキャッシュエンジンによって提供されます。
キャッシュエンジンはプロジェクトの必要に応じて選択することができます。
キャッシュエンジンの設定は、<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a> において、使用するエンジンに応じて以下の2通りの記載方法で設定できます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cache</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">EngineClassName</span>
</pre></div>
</div>
<p>または:</p>
<div class="highlight-python"><div class="highlight"><pre>cache {
  &quot;my.cache.EngineClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>Xitrumは以下のエンジンを内包しています:</p>
<div class="highlight-python"><div class="highlight"><pre>cache {
  # Simple in-memory cache
  &quot;xitrum.local.LruCache&quot; {
    maxElems = 10000
  }
}
</pre></div>
</div>
<p>もし、クラスタリングされたサーバーを使用する場合、キャッシュエンジンには、<a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast</a> を使用することができます。</p>
<p>独自のキャッシュエンジンを使用する場合、<code class="docutils literal"><span class="pre">xitrum.Cache</span></code> の <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Cache.scala">interface</a> を実装してください。</p>
</div>
<div class="section" id="id6">
<h3>キャッシュ動作の仕組み<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>入力方向（Inbound）:</p>
<div class="highlight-python"><div class="highlight"><pre>               アクションのレスポンスが
               キャッシュ対象かつ
request        キャッシュが存在している
-------------------------+---------------NO---------------&gt;
                         |
&lt;---------YES------------+
  キャッシュからレスポンス
</pre></div>
</div>
<p>出力方向（Outbound）:</p>
<div class="highlight-python"><div class="highlight"><pre>               アクションのレスポンスが
               キャッシュ対象かつ
               キャッシュがまだ存在していない 　          response
&lt;---------NO-------------+---------------------------------
                         |
&lt;---------YES------------+
  store response to cache
</pre></div>
</div>
</div>
<div class="section" id="xitrum-util-locallrucache">
<h3>xitrum.util.LocalLruCache<a class="headerlink" href="#xitrum-util-locallrucache" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上記で述べたキャッシュエンジンは、システム全体で共有されるキャッシュとなります。
もし小さくで簡易なキャッシュエンジンのみ必要な場合、<code class="docutils literal"><span class="pre">xitrum.util.LocalLruCache</span></code> を使用します。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.LocalLruCache

// LRU (Least Recently Used) キャッシュは1000要素まで保存できます
// キーとバリューは両方String型となります
val cache = LocalLruCache[String, String](1000)
</pre></div>
</div>
<p>使用できる <code class="docutils literal"><span class="pre">cache</span></code> は <a class="reference external" href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html">java.util.LinkedHashMap</a> のインスタンスであるため、
<code class="docutils literal"><span class="pre">LinkedHashMap</span></code> のメソッドを使用して扱う事ができます。</p>
</div>
</div>
<span id="document-i18n"></span><div class="section" id="i18n">
<h2>I18n<a class="headerlink" href="#i18n" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>GNU gettext を使用します。gettextは他の国際化方法と異なり、複数形をサポートしています。</p>
<img alt="_images/poedit.png" src="_images/poedit.png" />
<div class="section" id="id1">
<h3>ソースコード内への国際化メッセージの記載<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.Action</span></code> は <code class="docutils literal"><span class="pre">xitrum.I18n</span></code> を継承しており以下の2つのメソッドを持ちます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span><span class="p">(</span><span class="s">&quot;Message&quot;</span><span class="p">)</span>
<span class="n">tc</span><span class="p">(</span><span class="s">&quot;Context&quot;</span><span class="p">,</span> <span class="s">&quot;Message&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>actionの中では、それらのメソッドを直接呼び出すことができます。
modelのようにaction以外の場所では、<code class="docutils literal"><span class="pre">xitrum.I18n</span></code> オブジェクトをインポートし、 <code class="docutils literal"><span class="pre">t</span></code> または <code class="docutils literal"><span class="pre">tc</span></code> メソッドを呼び出します:</p>
<div class="highlight-python"><div class="highlight"><pre>// In an action
respondText(MyModel.hello(this))

// In the model
import xitrum.I18n
object MyModel {
  def hello(i18n: I18n) = i18n.t(&quot;Hello World&quot;)
}
</pre></div>
</div>
</div>
<div class="section" id="pot">
<h3>potファイルへのメッセージの展開<a class="headerlink" href="#pot" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>空のi18n.potファイルをプロジェクトのルートディレクトリに作成し、
プロジェクト全体を再コンパイルします。</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt clean
rm i18n.pot
touch i18n.pot
sbt/sbt compile
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span></code> で全ての.classファイルを削除し、SBTにプロジェクト全体の再コンパイルを実施します。
<code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span></code> の後、SBTはコンパイル時に全ての <a class="reference internal" href="index.html#document-deps"><em>依存ライブラリ</em></a> を再ダウンロードを行いますので、
より時間を節約するには <code class="docutils literal"><span class="pre">find</span> <span class="pre">target</span> <span class="pre">-name</span> <span class="pre">*.class</span> <span class="pre">-delete</span></code> と実施することで
同じように <code class="docutils literal"><span class="pre">target</span></code> ディレクトリ内の.classファイルを削除することができます。</p>
<p>リコンパイル実施後、ソースコードから抽出されたメッセージがi18n.potファイルにgettext形式で出力されます。
この魔法のような動作は <a class="reference external" href="http://www.scala-lang.org/node/140">Scala compiler plugin technique</a> により実現されています。</p>
<p>ただし一つ注意点があります。このメソッドはScalaのコードからのみメッセージを抽出します。
もしプロジェクト内にJavaファイルがある場合、 <code class="docutils literal"><span class="pre">xgettext</span></code> コマンドを使用してメッセージを抽出します:</p>
<div class="highlight-python"><div class="highlight"><pre>xgettext -kt -ktc:1c,2 -ktn:1,2 -ktcn:1c,2,3 -o i18n_java.pot --from-code=UTF-8 $(find src/main/java -name &quot;*.java&quot;)
</pre></div>
</div>
<p>出力されたi18n_java.potはi18n.potにマージする必要があります。</p>
</div>
<div class="section" id="po">
<h3>po ファイルの保存先<a class="headerlink" href="#po" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>i18n.potはテンプレートであるため、各言語に対応させるにはi18n.potファイルをコピーして、&lt;language&gt;.po として保存し翻訳を開始します。</p>
<p>Xitrumはクラスパス中の <code class="docutils literal"><span class="pre">i18n</span></code> という名前のディレクトリを監視します。
もしそのディレクトリ内の &lt;language&gt;.po ファイルに変更があった場合
Xitrumは自動的に &lt;language&gt;.po ファイルをリロードします。</p>
<div class="highlight-python"><div class="highlight"><pre>src
  main
    scala
    view
    resources
      i18n
        ja.po
        vi.po
        ...
</pre></div>
</div>
<p>poファイルを編集やマージには <a class="reference external" href="http://www.poedit.net/">Poedit</a> のようなツールを使用することができます。</p>
<img alt="_images/update_from_pot.png" src="_images/update_from_pot.png" />
<p>poファイルは複数のJARに含めることができ、Xitrumはそれらを自動的にマージします。</p>
<div class="highlight-python"><div class="highlight"><pre>mylib.jar
  i18n
    ja.po
    vi.po
        ...

another.jar
  i18n
    ja.po
    vi.po
        ...
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>言語の設定<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li>ブラウザからのリクエストに含まれる <code class="docutils literal"><span class="pre">Accept-Language</span></code> リクエストヘッダーを取得するには、
<code class="docutils literal"><span class="pre">browserLanguages</span></code> を実行します。結果はブラウザによって送信された優先順位の高い順にソートされて取得できます。</li>
<li>デフォルト値は &#8220;en&#8221; です。現在の言語を日本語に変更するには、 <code class="docutils literal"><span class="pre">language</span> <span class="pre">=</span> <span class="pre">&quot;ja&quot;</span></code> と実行します。</li>
<li>適切な言語を言語リソースから自動でセットするには
<code class="docutils literal"><span class="pre">autosetLanguage(resourceLanguages)</span></code> を実行します。
<code class="docutils literal"><span class="pre">resourceLanguages</span></code> は <code class="docutils literal"><span class="pre">resources/i18n</span></code> ディレクトリーとJARファイル内に含まれる言語リソースのリストを指定します。
もし指定された言語リソースが存在しない場合、言語設定は&#8221;en&#8221;が使用されます。</li>
<li>設定された言語を確認するには、<code class="docutils literal"><span class="pre">language</span></code> 変数にセットされた値を参照します。</li>
</ul>
<p>一般的にアクションではビフォアフィルターにおいて言語を設定します:</p>
<div class="highlight-python"><div class="highlight"><pre>beforeFilter {
  val lango: Option[String] = yourMethodToGetUserPreferenceLanguageInSession()
  lango match {
    case None       =&gt; autosetLanguage(&quot;ja&quot;, &quot;vi&quot;)
    case Some(lang) =&gt; language = lang
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>バリデーションメッセージ<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>jQuery Validation プラグインは <a class="reference external" href="https://github.com/jzaefferer/jquery-validation/tree/master/src/localization">i18n error messages</a> を提供しています。
Xitrumは現在の言語に対応するメッセージファイルを自動的にインポートします。</p>
<p><code class="docutils literal"><span class="pre">xitrum.validator</span></code> パッケージが提供するサーバサイドバリデーションにおいても、
Xitrumはそれらの翻訳を提供しています。</p>
</div>
<div class="section" id="id4">
<h3>複数形への対応<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tn</span><span class="p">(</span><span class="s">&quot;Message&quot;</span><span class="p">,</span> <span class="s">&quot;Plural form&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">tcn</span><span class="p">(</span><span class="s">&quot;Context&quot;</span><span class="p">,</span> <span class="s">&quot;Message&quot;</span><span class="p">,</span> <span class="s">&quot;Plural form&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Xitrumは以下の仕様に沿って複数形の単語を翻訳します。</p>
<ul class="simple">
<li><a class="reference external" href="http://www.gnu.org/software/gettext/manual/html_node/Plural-forms.html#Plural-forms">What are plural forms</a></li>
<li><a class="reference external" href="http://www.gnu.org/software/gettext/manual/html_node/Translating-plural-forms.html#Translating-plural-forms">Translating plural forms</a></li>
</ul>
<p>複数形の単語は以下のいずれかの書式に従う必要があります:</p>
<div class="highlight-python"><div class="highlight"><pre>nplurals=1; plural=0
nplurals=2; plural=n != 1
nplurals=2; plural=n&gt;1
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2
nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2
nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 &gt; 0 &amp;&amp; n%100 &lt; 20)) ? 1 : 2
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=3; plural=(n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2
nplurals=3; plural=n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=4; plural=n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>日付と数値のフォーマット<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もしScalateテンプレートエンジンを使用している場合、日付と数値のフォーマットは現在のアクションの言語設定に従うことになります。</p>
<p>異なるフォーマットを使用する場合:</p>
<div class="highlight-python"><div class="highlight"><pre>import java.text.{DateFormat, NumberFormat}

val myDateFormat   = ...
val myNumberFormat = ...
val options        = Map(&quot;date&quot; -&gt; myDateFormat, &quot;number&quot; -&gt; myNumberFormat)
respondView(options)
</pre></div>
</div>
</div>
</div>
<span id="document-log"></span><div class="section" id="id1">
<h2>ログ<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="xitrum-log">
<h3>xitrum.Logオブジェクトを直接使用する<a class="headerlink" href="#xitrum-log" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xitrum.Logはどこからでも直接使用することができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;My debug msg&quot;</span><span class="p">)</span>
<span class="n">xitrum</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;My info msg&quot;</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>xitrum.Logトレイトを直接使用する<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ログが生成された場所(クラス)を明確に知りたい場合、
xitrum.Logトレイトを継承します。</p>
<div class="highlight-python"><div class="highlight"><pre>package my_package
import xitrum.Log

object MyModel extends Log {
  log.debug(&quot;My debug msg&quot;)
  log.info(&quot;My info msg&quot;)
  ...
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">log/xitrum.log</span></code> にはメッセージが <code class="docutils literal"><span class="pre">MyModel</span></code> から出力されていることがわかります。</p>
<p>Xitrumのアクションはxitrum.Logトレイトを継承しており、どのactionからでも以下のようにログを出力することができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>ログレベルをチェックする必要はありません<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.Log</span></code> は <a class="reference external" href="http://slf4s.org/">SLF4S</a> (<a class="reference external" href="http://slf4s.org/api/1.7.7/">API</a>) を使用しており、
SLF4Sは <a class="reference external" href="http://www.slf4j.org/">SLF4J</a> の上に構築されています。</p>
<p>ログに出力時の計算によるCPU負荷を減らす目的で、ログ出力前にログレベルをチェックする伝統的な手法がありますが、
<a class="reference external" href="https://github.com/mattroberts297/slf4s/blob/master/src/main/scala/org/slf4s/Logger.scala">SLF4Sが自動でチェックしてくれる</a> ため、
あなたが気にする必要はありません。</p>
<p>これまで (このコードは Xitrum 3.13 以降では動作しません):</p>
<div class="highlight-python"><div class="highlight"><pre>if (log.isTraceEnabled) {
  val result = heavyCalculation()
  log.trace(&quot;Output: {}&quot;, result)
}
</pre></div>
</div>
<p>現行:</p>
<div class="highlight-python"><div class="highlight"><pre>log.trace(s&quot;Output: #{heavyCalculation()}&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>ログレベル、ログファイル等の設定<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>build.sbtに以下の1行があります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;ch.qos.logback&quot;</span> <span class="o">%</span> <span class="s">&quot;logback-classic&quot;</span> <span class="o">%</span> <span class="s">&quot;1.1.2&quot;</span>
</pre></div>
</div>
<p>これはデフォルトで <a class="reference external" href="http://logback.qos.ch/">Logback</a> が使用されていることを意味します。
Logbackの設定ファイルは <code class="docutils literal"><span class="pre">config/logback.xml</span></code> になります。</p>
<p>Logback以外の <a class="reference external" href="http://www.slf4j.org/">SLF4J</a> 対応ライブラリに置き換えることも可能です。</p>
</div>
<div class="section" id="fluentd">
<h3>Fluentd へのログ出力<a class="headerlink" href="#fluentd" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ログコレクターとして有名な <a class="reference external" href="http://www.fluentd.org/">Fluentd</a> というソフトウェアがあります。
Logbackの設定を変更することでFluentdサーバにXitrumのログを（複数の箇所から）転送することができます。</p>
<p>利用するにはまず、プロジェクトの依存ライブラリに <a class="reference external" href="https://github.com/sndyuk/logback-more-appenders">logback-more-appenders</a> を追加します:</p>
<div class="highlight-python"><div class="highlight"><pre>libraryDependencies += &quot;org.fluentd&quot; % &quot;fluent-logger&quot; % &quot;0.2.11&quot;

resolvers += &quot;Logback more appenders&quot; at &quot;http://sndyuk.github.com/maven&quot;

libraryDependencies += &quot;com.sndyuk&quot; % &quot;logback-more-appenders&quot; % &quot;1.1.0&quot;
</pre></div>
</div>
<p>そして <code class="docutils literal"><span class="pre">config/logback.xml</span></code> を編集します:</p>
<div class="highlight-python"><div class="highlight"><pre>...

&lt;appender name=&quot;FLUENT&quot; class=&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;&gt;
  &lt;tag&gt;mytag&lt;/tag&gt;
  &lt;label&gt;mylabel&lt;/label&gt;
  &lt;remoteHost&gt;localhost&lt;/remoteHost&gt;
  &lt;port&gt;24224&lt;/port&gt;
  &lt;maxQueueSize&gt;20000&lt;/maxQueueSize&gt;  &lt;!-- Save to memory when remote server is down --&gt;
&lt;/appender&gt;

&lt;root level=&quot;DEBUG&quot;&gt;
  &lt;appender-ref ref=&quot;FLUENT&quot;/&gt;
  &lt;appender-ref ref=&quot;OTHER_APPENDER&quot;/&gt;
&lt;/root&gt;

...
</pre></div>
</div>
</div>
</div>
<span id="document-deploy"></span><div class="section" id="id1">
<h2>プロダクション環境へのデプロイ<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Xitrumを直接動かすことができます:</p>
<div class="highlight-python"><div class="highlight"><pre>ブラウザ ------ Xitrum インスタンス
</pre></div>
</div>
<p>HAProxyのようなロードバランサーや、ApacheやNginxのようなリバースプロキシの背後で動かすこともできます:</p>
<div class="highlight-python"><div class="highlight"><pre>ブラウザ ------ ロードバランサー/リバースプロキシ   -+---- Xitrum インスタンス1
                                            　+---- Xitrum インスタンス2
</pre></div>
</div>
<div class="section" id="id2">
<h3>ディレクトリのパッケージ化<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">xitrum-package</span></code> を実行することで、プロダクション環境へデプロイ可能な <code class="docutils literal"><span class="pre">target/xitrum</span></code> ディレクトリが生成されます:</p>
<div class="highlight-python"><div class="highlight"><pre>target/xitrum
  config
    [config files]
  public
    [static public files]
  lib
    [dependencies and packaged project file]
  script
    runner
    runner.bat
    scalive
    scalive.jar
    scalive.bat
</pre></div>
</div>
</div>
<div class="section" id="xitrum-package">
<h3>xitrum-packageのカスタマイズ<a class="headerlink" href="#xitrum-package" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルトでは <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">xitrum-package</span></code> コマンドは、</p>
<p><code class="docutils literal"><span class="pre">config</span></code> 、 <code class="docutils literal"><span class="pre">public</span></code> および <code class="docutils literal"><span class="pre">script</span></code> ディレクトリを <code class="docutils literal"><span class="pre">target/xitrum</span></code> 以下にコピーします。
コピーするディレクトリを追加したい場合は、以下のように <code class="docutils literal"><span class="pre">build.sbt</span></code> を編集します:</p>
<div class="highlight-python"><div class="highlight"><pre>XitrumPackage.copy(&quot;config&quot;, &quot;public, &quot;script&quot;, &quot;doc/README.txt&quot;, &quot;etc.&quot;)
</pre></div>
</div>
<p>詳しくは <a class="reference external" href="https://github.com/xitrum-framework/xitrum-package">xitrum-packageのサイト</a> を参照ください。</p>
</div>
<div class="section" id="jvmscala">
<h3>稼働中のJVMプロセスに対するScalaコンソール接続<a class="headerlink" href="#jvmscala" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>プロダクション環境においても特別な準備をすることなく、<a class="reference external" href="https://github.com/xitrum-framework/scalive">Scalive</a> を使用することで、
稼働中のJVMプロセスに対してScalaコンソールを接続してデバッギングを行うことができます。</p>
<p><code class="docutils literal"><span class="pre">script</span></code> ディレクトリの <code class="docutils literal"><span class="pre">scalive</span></code> コマンドを実行します:</p>
<div class="highlight-python"><div class="highlight"><pre>script
  runner
  runner.bat
  scalive
  scalive.jar
  scalive.bat
</pre></div>
</div>
</div>
<div class="section" id="centosubuntuoraclejdk">
<h3>CentOSまたはUbuntuへのOracleJDKインストール<a class="headerlink" href="#centosubuntuoraclejdk" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ここではJavaのインストール方法についての簡単なガイドを紹介します。
パッケージマネージャを使用してJavaをインストールすることも可能です。</p>
<p>現在インストールされているJavaの確認:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --list java
</pre></div>
</div>
<p>出力例:</p>
<div class="highlight-python"><div class="highlight"><pre>/usr/lib/jvm/jdk1.7.0_15/bin/java
/usr/lib/jvm/jdk1.7.0_25/bin/java
</pre></div>
</div>
<p>サーバ環境の確認 (32 bit または 64 bit):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">init</span>
</pre></div>
</div>
<p>出力例:</p>
<div class="highlight-python"><div class="highlight"><pre>/sbin/init: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x4efe732752ed9f8cc491de1c8a271eb7f4144a5c, stripped
</pre></div>
</div>
<p>JDKを <a class="reference external" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">Oracle</a> のサイトからダウンロードします。
ブラウザを介さないでダウンロードするにはちょっとした <a class="reference external" href="http://stackoverflow.com/questions/10268583/how-to-automate-download-and-instalation-of-java-jdk-on-linux">工夫</a> が必要です:</p>
<div class="highlight-python"><div class="highlight"><pre>wget --no-cookies --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/7u45-b18/jdk-7u45-linux-x64.tar.gz&quot;
</pre></div>
</div>
<p>ダウンロードしたアーカイブを解凍して移動します:</p>
<div class="highlight-python"><div class="highlight"><pre>tar -xzvf jdk-7u45-linux-x64.tar.gz
sudo mv jdk1.7.0_45 /usr/lib/jvm/jdk1.7.0_45
</pre></div>
</div>
<p>コマンドを登録します:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/java&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javac&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javap&quot; &quot;javap&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javap&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javaws&quot; 1
</pre></div>
</div>
<p>対話型のシェルで新しいパスを指定します:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --config java
</pre></div>
</div>
<p>出力例:</p>
<div class="highlight-python"><div class="highlight"><pre>There are 3 choices for the alternative java (providing /usr/bin/java).

  Selection    Path                               Priority   Status
------------------------------------------------------------
* 0            /usr/lib/jvm/jdk1.7.0_25/bin/java   50001     auto mode
  1            /usr/lib/jvm/jdk1.7.0_15/bin/java   50000     manual mode
  2            /usr/lib/jvm/jdk1.7.0_25/bin/java   50001     manual mode
  3            /usr/lib/jvm/jdk1.7.0_45/bin/java   1         manual mode

Press enter to keep the current choice[*], or type selection number: 3
update-alternatives: using /usr/lib/jvm/jdk1.7.0_45/bin/java to provide /usr/bin/java (java) in manual mode
</pre></div>
</div>
<p>バージョンを確認します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">java</span> <span class="o">-</span><span class="n">version</span>
</pre></div>
</div>
<p>出力例:</p>
<div class="highlight-python"><div class="highlight"><pre>java version &quot;1.7.0_45&quot;
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
</pre></div>
</div>
<p>javac等も同様に行います:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --config javac
sudo update-alternatives --config javap
sudo update-alternatives --config javaws
</pre></div>
</div>
</div>
<div class="section" id="xitrum">
<h3>システム起動時にXitrumをスタートさせる<a class="headerlink" href="#xitrum" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">script/runner</span></code> （<a href="#id5"><span class="problematic" id="id6">*</span></a>nix環境向け）と <code class="docutils literal"><span class="pre">script/runner.bat</span></code> （Windows環境向け）はオブジェクトの <code class="docutils literal"><span class="pre">main</span></code> メソッドを実行するためのスクリプトになります。
プロダクション環境ではこのスクリプトを使用してWebサーバを起動します:</p>
<div class="highlight-python"><div class="highlight"><pre>script/runner quickstart.Boot
</pre></div>
</div>
<p><a class="reference external" href="http://www.oracle.com/technetwork/java/hotspotfaq-138619.html">JVM設定</a> を調整するには、
<code class="docutils literal"><span class="pre">runner</span></code> （または <code class="docutils literal"><span class="pre">runner.bat</span></code>）を修正します。
また、<code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> も参照してください。</p>
<p>Linux環境でシステム起動時にXitrumをバックグラウンドでスタートさせるには、一番簡単な方法は
<code class="docutils literal"><span class="pre">/etc/rc.local</span></code> に一行を追加します:</p>
<div class="highlight-python"><div class="highlight"><pre>su - user_foo_bar -c /path/to/the/runner/script/above &amp;
</pre></div>
</div>
<p>他には <a class="reference external" href="http://cr.yp.to/daemontools.html">daemontools</a> が便利です。
CentOSへのインストール手順は <a class="reference external" href="http://whomwah.com/2008/11/04/installing-daemontools-on-centos5-x86_64/">こちらの手順</a> を参照してください。
あるいは <a class="reference external" href="http://supervisord.org/">Supervisord</a> を使用することもできます。</p>
<p><code class="docutils literal"><span class="pre">/etc/supervisord.conf</span></code> の例:</p>
<div class="highlight-python"><div class="highlight"><pre>[program:my_app]
directory=/path/to/my_app
command=/path/to/my_app/script/runner quickstart.Boot
autostart=true
autorestart=true
startsecs=3
user=my_user
redirect_stderr=true
stdout_logfile=/path/to/my_app/log/stdout.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=7
stdout_capture_maxbytes=1MB
stdout_events_enabled=false
environment=PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/opt/aws/bin:~/bin
</pre></div>
</div>
<p>その他のツール:</p>
<ul class="simple">
<li><a class="reference external" href="http://smarden.org/runit/">runit</a></li>
<li><a class="reference external" href="http://upstart.ubuntu.com/">upstart</a></li>
</ul>
</div>
<div class="section" id="id8">
<h3>ポートフォワーディングの設定<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルトではXitrumは8000ポートと4430ポートを使用します。
これらのポート番号は <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> で設定することができます。</p>
<p><code class="docutils literal"><span class="pre">/etc/sysconfig/iptables</span></code> を以下のコマンドで修正することによって、
80から8000へ、443から4430へポートフォワーディングを行うことができます:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo su - root
chmod 700 /etc/sysconfig/iptables
iptables-restore &lt; /etc/sysconfig/iptables
iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8000
iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 4430
iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 80 -j REDIRECT --to-ports 8000
iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 443 -j REDIRECT --to-ports 4430
iptables-save -c &gt; /etc/sysconfig/iptables
chmod 644 /etc/sysconfig/iptables
</pre></div>
</div>
<p>もしApacheが80ポート、443ポートを使用している場合、停止する必要があります:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo /etc/init.d/httpd stop
sudo chkconfig httpd off
</pre></div>
</div>
<p>Iptablesについての参考情報:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.frozentux.net/iptables-tutorial/chunkyhtml/">Iptables チュートリアル</a></li>
</ul>
</div>
<div class="section" id="linux">
<h3>大量コネクションに対するLinux設定<a class="headerlink" href="#linux" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Macの場合、JDKは <a class="reference external" href="https://groups.google.com/forum/#!topic/spray-user/S-SNR2m0BWU">IO (NIO) に関わるパフォーマンスの問題</a> が存在します。</p>
<p>参考情報(英語):</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.basho.com/riak/latest/ops/tuning/linux/">Linux Performance Tuning (Riak)</a></li>
<li><a class="reference external" href="http://docs.basho.com/riak/latest/ops/tuning/aws/">AWS Performance Tuning (Riak)</a></li>
<li><a class="reference external" href="http://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/">Ipsysctl tutorial</a></li>
<li><a class="reference external" href="http://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/tcpvariables.html">TCP variables</a></li>
</ul>
<div class="section" id="id9">
<h4>ファイルディスクリプタ数の上限設定<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>各コネクションはLinuxにとってオープンファイルとしてみなされます。
1プロセスが同時オープン可能なファイルディスクリプタ数は、デフォルトで1024となっています。
この上限を変更するには <code class="docutils literal"><span class="pre">/etc/security/limits.conf</span></code> を編集します:</p>
<div class="highlight-python"><div class="highlight"><pre>*  soft  nofile  1024000
*  hard  nofile  1024000
</pre></div>
</div>
<p>変更を適用するには一度ログアウトして、再度ログインする必要があります。
一時的に適用するには <code class="docutils literal"><span class="pre">ulimit</span> <span class="pre">-n</span></code> と実行します。</p>
</div>
<div class="section" id="id10">
<h4>カーネルのチューニング<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference external" href="http://www.metabrew.com/article/a-million-user-comet-application-with-mochiweb-part-1">A Million-user Comet Application with Mochiweb（英語）</a> に紹介されているように、<code class="docutils literal"><span class="pre">/etc/sysctl.conf</span></code> を編集します:</p>
<div class="highlight-python"><div class="highlight"><pre># General gigabit tuning
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216

# This gives the kernel more memory for TCP
# which you need with many (100k+) open socket connections
net.ipv4.tcp_mem = 50576 64768 98152

# Backlog
net.core.netdev_max_backlog = 2048
net.core.somaxconn = 1024
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_syncookies = 1

# If you run clients
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 10
</pre></div>
</div>
<p>変更を適用するため、 <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">sysctl</span> <span class="pre">-p</span></code> を実行します。
リブートの必要はありません。これでカーネルは大量のコネクションを扱うことができるようになります。</p>
</div>
<div class="section" id="id11">
<h4>バックログについて<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>TCPはコネクション確立のために3種類のハンドシェイクを行います。
リモートクライアントがサーバに接続するとき、クライアントはSYNパケットを送信します。
そしてサーバ側のOSはSYN-ACKパケットを返信します。
その後リモートクライアントは再びACKパケットを送信してコネクションが確立します。
Xitrumはコネクションが完全に確立した時にそれを取得します。</p>
<p><a class="reference external" href="https://sites.google.com/site/beingroot/articles/apache/socket-backlog-tuning-for-apache">Socket backlog tuning for Apache（英語）</a> によると、
コネクションタイムアウトは、WebサーバのバックログキューがSYN−ACKパケット送信で溢れてしまった際に、SYNパケットが失われることによって発生します。</p>
<p><a class="reference external" href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/configtuning-kernel-limits.html">FreeBSD Handbook（英語）</a> によると
デフォルトの128という設定は、高負荷なサーバ環境にとって、新しいコネクションを確実に受け付けるには低すぎるとあります。
そのような環境では、1024以上に設定することが推奨されています。
キューサイズを大きくすることはDoS攻撃を避ける意味でも効果があります。</p>
<p>Xitrumはバックログサイズを1024(memcachedと同じ値)としています。
しかし、前述のカーネルのチューニングをすることも忘れないで下さい。</p>
<p>バックログ設定値の確認方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cat</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">net</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">somaxconn</span>
</pre></div>
</div>
<p>または:</p>
<div class="highlight-python"><div class="highlight"><pre>sysctl net.core.somaxconn
</pre></div>
</div>
<p>一時的な変更方法:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo sysctl -w net.core.somaxconn=1024
</pre></div>
</div>
</div>
</div>
<div class="section" id="haproxy-tips">
<h3>HAProxy tips<a class="headerlink" href="#haproxy-tips" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>HAProxyをSockJSのために設定するには、<a class="reference external" href="https://github.com/sockjs/sockjs-node/blob/master/examples/haproxy.cfg">こちらのサンプル</a> を参照してください。
HAProxyを再起動せずに設定ファイルをロードするには、<a class="reference external" href="http://serverfault.com/questions/165883/is-there-a-way-to-add-more-backend-server-to-haproxy-without-restarting-haproxy">こちらのディスカッション</a> を参照してください。</p>
<p>HAProxyはNginxより簡単に使うことができます。
<a class="reference internal" href="index.html#document-cache"><em>キャッシュについての章</em></a> にあるように、Xitrumは <a class="reference external" href="https://gist.github.com/3293596">静的ファイルの配信に優れている</a> ため、
静的ファイルの配信にNginxを用意する必要はありません。その点からHAProxyはXitrumととても相性が良いと言えます。</p>
</div>
<div class="section" id="nginx-tips">
<h3>Nginx tips<a class="headerlink" href="#nginx-tips" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Nginx 1.2 の背後でXitrumを動かす場合、XitrumのWebSocketやSockJSの機能を使用するには、
<a class="reference external" href="https://github.com/yaoweibin/nginx_tcp_proxy_module">nginx_tcp_proxy_module</a> を使用する必要があります。
Nginx 1.3+ 以上はネイティブでWebSocketをサポートしています。</p>
<p>Nginxはデフォルトでは、HTTP 1.0をリバースプロキシのプロトコルとして使用します。
チャンクレスポンスを使用する場合、Nginxに HTTP 1.1をプロトコルとして使用することを伝える必要があります:</p>
<div class="highlight-python"><div class="highlight"><pre>location / {
  proxy_http_version 1.1;
  proxy_set_header Connection &quot;&quot;;
  proxy_pass http://127.0.0.1:8000;
}
</pre></div>
</div>
<p>http keepaliveについての <a class="reference external" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive">ドキュメント</a> にあるように、 <code class="docutils literal"><span class="pre">proxy_set_header</span> <span class="pre">Connection</span> <span class="pre">&quot;&quot;</span></code> と設定する必要もあります。</p>
</div>
<div class="section" id="heroku">
<h3>Herokuへのデプロイ<a class="headerlink" href="#heroku" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumは <a class="reference external" href="https://www.heroku.com/">Heroku</a> 上で動かすこともできます。</p>
<div class="section" id="id17">
<h4>サインアップとリポジトリの作成<a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference external" href="https://devcenter.heroku.com/articles/quickstart">公式ドキュメント</a> に沿って、サインアップしリポジトリを作成します。</p>
</div>
<div class="section" id="procfile">
<h4>Procfileの作成<a class="headerlink" href="#procfile" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Procfileを作成し、プロジェクトのルートディレクトリに保存します。
Herokuはこのファイルをもとに、起動時コマンドを実行します。</p>
<div class="highlight-python"><div class="highlight"><pre>web: target/xitrum/script/runner &lt;YOUR_PACKAGE.YOUR_MAIN_CLASS&gt;
</pre></div>
</div>
</div>
<div class="section" id="port">
<h4>Port設定の変更<a class="headerlink" href="#port" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>ポート番号はHerokuによって動的にアサインされるため、以下のように設定する必要があります。</p>
<p>config/xitrum.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>port {
  http              = ${PORT}
  # https             = 4430
  # flashSocketPolicy = 8430  # flash_socket_policy.xml will be returned
}
</pre></div>
</div>
<p>SSLを使用するには、<a class="reference external" href="https://addons.heroku.com/ssl">アドオン</a> が必要となります。</p>
</div>
<div class="section" id="id20">
<h4>ログレベルの設定<a class="headerlink" href="#id20" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>config/logback.xml:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;root level=&quot;INFO&quot;&gt;
  &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
&lt;/root&gt;
</pre></div>
</div>
<p>Herokuで稼働するアプリのログをtailするには:</p>
<div class="highlight-python"><div class="highlight"><pre>heroku logs -tail
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4><code class="docutils literal"><span class="pre">xitrum-package</span></code> のエイリアス作成<a class="headerlink" href="#id21" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>デプロイ実行時にHerokuは、<code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span> <span class="pre">compile</span> <span class="pre">stage</span></code> を実行します。
そのため、 <code class="docutils literal"><span class="pre">xitrum-package</span></code> に対するエイリアスを作成する必要があります。</p>
<p>build.sbt:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">addCommandAlias</span><span class="p">(</span><span class="s">&quot;stage&quot;</span><span class="p">,</span> <span class="s">&quot;;xitrum-package&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h4>Herokuへのプッシュ<a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>デプロイプロセスは git push にふっくされます:</p>
<div class="highlight-python"><div class="highlight"><pre>git push heroku master
</pre></div>
</div>
<p>詳しくはHerokuの <a class="reference external" href="https://devcenter.heroku.com/articles/getting-started-with-scala">公式ドキュメント for Scala</a> を参照してください.</p>
</div>
</div>
<div class="section" id="openshift">
<h3>OpenShiftへのデプロイ<a class="headerlink" href="#openshift" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumは <a class="reference external" href="https://developers.openshift.com/">OpenShift</a> 上で動かすこともできます。</p>
<div class="section" id="id24">
<h4>サインアップとリポジトリの作成<a class="headerlink" href="#id24" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference external" href="https://developers.openshift.com/en/getting-started-overview.html">公式ガイド</a> に沿って、サインアップしリポジトリを作成します。
カートリッジには <a class="reference external" href="https://developers.openshift.com/en/diy-overview.html">DIY</a> を指定します。</p>
<div class="highlight-python"><div class="highlight"><pre>rhc app create myapp diy
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h4>プロジェクト構成<a class="headerlink" href="#id26" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>sbtを使用してXitrumアプリケーションをコンパイル、起動するために、<a class="reference external" href="http://stackoverflow.com/questions/23826770/play-openshift-deployment-sbt-using-some-directories-behind-the-scenes">いくつかの準備</a> が必要となります。
rhcコマンドで作成したプロジェクトディレクトリ内に`app`ディレクトリを作成し、xitrumアプリケーションのソースコードを配置します。
また、空の`static`と`fakehome`ディレクトリを作成します、
プロジェクトツリーは以下のようになります。</p>
<div class="highlight-python"><div class="highlight"><pre>├── .openshift
│   ├── README.md
│   ├── action_hooks
│   │   ├── README.md
│   │   ├── start
│   │   └── stop
│   ├── cron
│   └── markers
├── README.md
├── app
├── fakehome
├── misc
└── static
</pre></div>
</div>
</div>
<div class="section" id="action-hooks">
<h4>action_hooksの作成<a class="headerlink" href="#action-hooks" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>openshiftへpush時に実行されるスクリプトを以下のように修正します。</p>
<p>.openshift/action_hooks/start:</p>
<div class="highlight-python"><div class="highlight"><pre>#!/bin/bash
IVY_DIR=$OPENSHIFT_DATA_DIR/.ivy2
mkdir -p $IVY_DIR
chown $OPENSHIFT_GEAR_UUID.$OPENSHIFT_GEAR_UUID -R &quot;$IVY_DIR&quot;
cd $OPENSHIFT_REPO_DIR/app
sbt/sbt xitrum-package
nohup $OPENSHIFT_REPO_DIR/app/target/xitrum/script/runner quickstart.Boot &gt;&gt; nohup.out 2&gt;&amp;1 &amp; echo $! &gt; $OPENSHIFT_REPO_DIR/xitrum.pid &amp;
</pre></div>
</div>
<p>.openshift/action_hooks/top:</p>
<div class="highlight-python"><div class="highlight"><pre>#!/bin/bash
source $OPENSHIFT_CARTRIDGE_SDK_BASH

# The logic to stop your application should be put in this script.
if [ -z &quot;$(ps -ef | grep `cat $OPENSHIFT_REPO_DIR/xitrum.pid` | grep -v grep)&quot; ]
then
    client_result &quot;Application is already stopped&quot;
else
    cat $OPENSHIFT_REPO_DIR/xitrum.pid | xargs kill
fi
</pre></div>
</div>
</div>
<div class="section" id="ip-port">
<h4>IP:Port設定の変更<a class="headerlink" href="#ip-port" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>IPとポート番号はopenshiftによって動的にアサインされるため、以下のように設定する必要があります。</p>
<p>config/xitrum.conf:</p>
<div class="highlight-python"><div class="highlight"><pre># Use opensift&#39;s Environment Variables
interface = ${OPENSHIFT_DIY_IP}

# Comment out the one you don&#39;t want to start.
port {
  http  = ${OPENSHIFT_DIY_PORT}
</pre></div>
</div>
</div>
<div class="section" id="sbt">
<h4>sbt引数の修正<a class="headerlink" href="#sbt" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>opensift上でsbtが動かすために、sbt起動スクリプトに以下のオプションを追加します。</p>
<p>sbt/sbt:</p>
<div class="highlight-python"><div class="highlight"><pre>-Duser.home=$OPENSHIFT_REPO_DIR/fakehome -Dsbt.ivy.home=$OPENSHIFT_DATA_DIR/.ivy2 -Divy.home=$OPENSHIFT_DATA_DIR/.ivy2
</pre></div>
</div>
</div>
<div class="section" id="openshiftpush">
<h4>openshiftへのpush<a class="headerlink" href="#openshiftpush" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>アプリケーションを起動するにはopensiftへソースコードをプッシュします。</p>
<div class="highlight-python"><div class="highlight"><pre>git push
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-cluster"></span><div class="section" id="akkahazelcast">
<h2>AkkaとHazelcastでサーバーをクラスタリングする<a class="headerlink" href="#akkahazelcast" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Xitrumがプロキシサーバーやロードバランサーの後ろでクラスタ構成で動けるように設計されています。</p>
<div class="highlight-python"><div class="highlight"><pre>                                / Xitrumインスタンス1
プロキシサーバー・ロードバランサー ---- Xitrumインスタンス2
                                \ Xitrumインスタンス3
</pre></div>
</div>
<p><a class="reference external" href="http://akka.io/">Akka</a> と <a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast</a>
のクラスタリング機能を使ってキャッシュ、セッション、SockJSセッションをクラスタリングできます。</p>
<p>Hazelcastを使えばXitrumインスタンスがプロセス内メモリキャッシュサーバーとなります。
Memcacheのような追加サーバーは不要です。</p>
<p>AkkaとHazelcastクラスタリングを設定するには <code class="docutils literal"><span class="pre">config/akka.conf</span></code> 、 <a class="reference external" href="http://akka.io/docs/">Akka ドキュメント</a>、
<a class="reference external" href="http://hazelcast.org/documentation/">Hazelcast ドキュメント</a> を参考にしてください。</p>
<p>メモ: セッションは <a class="reference internal" href="index.html#document-scopes"><em>クライアント側のクッキーへ保存</em></a> することができます。</p>
</div>
<span id="document-handler"></span><div class="section" id="netty">
<h2>Nettyハンドラ<a class="headerlink" href="#netty" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この章はXitrumを普通に使用する分には読む必要はありません。
理解するには <a class="reference external" href="http://netty.io/">Netty</a> の経験が必要です。</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Rack_(Web_server_interface)">Rack</a> 、
<a class="reference external" href="http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a> 、
<a class="reference external" href="http://en.wikipedia.org/wiki/PSGI">PSGI</a> にはミドルウェア構成があります。
<a class="reference external" href="http://netty.io/">Netty</a> には同じようなハンドラ構成があります。
XitrumはNettyの上で構築され、ハンドラ追加作成やハンドラのパイプライン変更などができ、
特定のユースケースにサーバーのパフォーマンスを最大化することができます。</p>
<p>この章では次の内容を説明します:</p>
<ul class="simple">
<li>Nettyハンドラ構成</li>
<li>Xitrumが提供するハンドラ一覧とそのデフォルト順番</li>
<li>ハンドラ一の追加作成と使用方法</li>
</ul>
<div class="section" id="id3">
<h3>Nettyハンドラの構成<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>それぞれのコネクションには、入出力データを処理するパイプラインがーつあります。
チャネルパイプラインは複数のハンドラによって構成され、ハンドラには以下の2種類あります:</p>
<ul class="simple">
<li>入力方向(Inbound): リクエスト方向クライアント -&gt; サーバー</li>
<li>出力方向(Inbound): レスポンス方向サーバー -&gt; クライアント</li>
</ul>
<p><a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html">ChannelPipeline</a>
の資料を参考にしてください。</p>
<div class="highlight-python"><div class="highlight"><pre>                                               I/O Request
                                          via Channel or
                                      ChannelHandlerContext
                                                    |
+---------------------------------------------------+---------------+
|                           ChannelPipeline         |               |
|                                                  \|/              |
|    +---------------------+            +-----------+----------+    |
|    | Inbound Handler  N  |            | Outbound Handler  1  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
|               |                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  .               |
|               .                                   .               |
| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
|        [ method call]                       [method call]         |
|               .                                   .               |
|               .                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
|               |                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler  1  |            | Outbound Handler  M  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
+---------------+-----------------------------------+---------------+
                |                                  \|/
+---------------+-----------------------------------+---------------+
|               |                                   |               |
|       [ Socket.read() ]                    [ Socket.write() ]     |
|                                                                   |
|  Netty Internal I/O Threads (Transport Implementation)            |
+-------------------------------------------------------------------+
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>ハンドラの追加作成<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumを起動する際に自由に
<a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelInitializer.html">ChannelInitializer</a>
が設定できます:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Server

object Boot {
  def main(args: Array[String]) {
    Server.start(myChannelInitializer)
  }
}
</pre></div>
</div>
<p>HTTPSサーバーの場合、Xitrumが自動でパイプラインの先頭にSSLハンドラを追加します。
Xitrumが提供するハンドラを自分のパイプラインに再利用することも可能です。</p>
</div>
<div class="section" id="xitrum">
<h3>Xitrumが提供するハンドラ<a class="headerlink" href="#xitrum" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/handler/DefaultHttpChannelInitializer.scala">xitrum.handler.DefaultHttpChannelInitializer</a>
を参照してください。</p>
<p>共有可能なハンドラ（複数のコネクションで同じインスタンスを共有できるハンドラ）は上記
<code class="docutils literal"><span class="pre">DefaultHttpChannelInitializer</span></code> オブジェクトに置かれてあります。
使いたいXitrumハンドラを選択し自分のパイプラインに簡単に設定できます。</p>
<p>例えば、Xitrumのrouting/dispatcherは使用せずに独自のディスパッチャを使用して、
Xitrumからは静的ファイルのハンドラのみを利用する場合</p>
<p>以下のハンドラのみ設定します:</p>
<p>入力方向(Inbound):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HttpRequestDecoder</span></code></li>
<li><code class="docutils literal"><span class="pre">PublicFileServer</span></code></li>
<li>独自のrouting/dispatcher</li>
</ul>
<p>出力方向(Outbound):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HttpResponseEncoder</span></code></li>
<li><code class="docutils literal"><span class="pre">ChunkedWriteHandler</span></code></li>
<li><code class="docutils literal"><span class="pre">XSendFile</span></code></li>
</ul>
</div>
</div>
<span id="document-metrics"></span><div class="section" id="id1">
<h2>メトリクス<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>XitrumはあなたのアプリケーションのJVMのヒープメモリーとCPUの使用量、
そしてアクションの実行ステータスをAkkaクラスタ上の各ノードから収集します。
それらのデータはメトリクスとしてJSONデータで配信する事ができます。
またメトリクスをカスタマイズすることも可能です。</p>
<p>この機能は <a class="reference external" href="http://metrics.codahale.com/">Coda Hale Metrics</a> を使用しています。</p>
<div class="section" id="id2">
<h3>メトリクスの収集<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="cpu">
<h4>ヒープメモリとCPU<a class="headerlink" href="#cpu" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>JVMのヒープメモリとCPUはAkkaのactor systemの各ノードから <a class="reference external" href="http://doc.akka.io/api/akka/2.3.0/index.html#akka.cluster.NodeMetrics">NodeMetrics</a> として収集されます。</p>
<p>ヒープメモリ:</p>
<img alt="_images/metrics_heapmemory.png" src="_images/metrics_heapmemory.png" />
<p>CPU: プロセッサ数とロードアベレージ</p>
<img alt="_images/metrics_cpu.png" src="_images/metrics_cpu.png" />
</div>
<div class="section" id="id3">
<h4>アクションの実行ステータス<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Xitrumは各ノードにおける各アクションの実行ステータスを <a class="reference external" href="http://metrics.codahale.com/getting-started/#histograms">Histogram</a> として収集します。
アクションの実行回数や実行時間についてをここから知ることができます。</p>
<img alt="_images/metrics_action_count.png" src="_images/metrics_action_count.png" />
<p>特定のアクションの最新の実行時間:</p>
<img alt="_images/metrics_action_time.png" src="_images/metrics_action_time.png" />
</div>
<div class="section" id="id4">
<h4>カスタムメトリクスの収集<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>上記のメトリクスに加えて収集するメトリクスをカスタムすることができます。
<code class="docutils literal"><span class="pre">xitrum.Metrics</span></code> は <code class="docutils literal"><span class="pre">gauge</span></code>, <code class="docutils literal"><span class="pre">counter</span></code>, <code class="docutils literal"><span class="pre">meter</span></code>, <code class="docutils literal"><span class="pre">timer</span></code> そして <code class="docutils literal"><span class="pre">histogram</span></code> にアクセスするためのショートカットです。
これらの使い方は <a class="reference external" href="http://metrics.codahale.com/">Coda Hale Metrics</a> と <a class="reference external" href="https://github.com/erikvanoosten/metrics-scala">そのScala実装</a> を参照ください。</p>
<p>例 Timer:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, Metrics}
import xitrum.annotation.GET

object MyAction {
  lazy val myTimer = Metrics.timer(&quot;myTimer&quot;)
}

@GET(&quot;my/action&quot;)
class MyAction extends Action {
  import MyAction._

  def execute() {
    myTimer.time {
      // Something that you want to measure execution time
      ...
    }
    ...
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id6">
<h3>メトリクスの配信<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumは最新のメトリクスをJSONフォーマットで定期的に配信します。
収集されたデータは揮発性であり、永続的に保存はされません。</p>
<p>ヒープメモリー:</p>
<div class="highlight-python"><div class="highlight"><pre>{
  &quot;TYPE&quot;      : &quot;heapMemory&quot;,
  &quot;SYSTEM&quot;    : akka.actor.Address.system,
  &quot;HOST&quot;      : akka.actor.Address.host,
  &quot;PORT&quot;      : akka.actor.Address.port,
  &quot;HASH&quot;      : akka.actor.Address.hashCode,
  &quot;TIMESTAMP&quot; : akka.cluster.NodeMetrics.timestamp,
  &quot;USED&quot;      : Number as byte,
  &quot;COMMITTED&quot; : Number as byte,
  &quot;MAX&quot;       : Number as byte
}
</pre></div>
</div>
<p>CPU:</p>
<div class="highlight-python"><div class="highlight"><pre>{
  &quot;TYPE&quot;              : &quot;cpu&quot;,
  &quot;SYSTEM&quot;            : akka.actor.Address.system,
  &quot;HOST&quot;              : akka.actor.Address.host,
  &quot;PORT&quot;              : akka.actor.Address.port,
  &quot;HASH&quot;              : akka.actor.Address.hashCode,
  &quot;TIMESTAMP&quot;         : akka.cluster.NodeMetrics.timestamp
  &quot;SYSTEMLOADAVERAGE&quot; : Number,
  &quot;CPUCOMBINED&quot;       : Number,
  &quot;PROCESSORS&quot;        : Number
}
</pre></div>
</div>
<p>メトリクスレジストリは <a class="reference external" href="http://metrics.codahale.com/manual/json/">metrics-json</a> によってパースされます。.</p>
<div class="section" id="xitrum">
<h4>Xitrumデフォルトビューア<a class="headerlink" href="#xitrum" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Xitrumはデフォルトで次のURLにメトリクスビューアを提供します。<code class="docutils literal"><span class="pre">/xitrum/metrics/viewer?api_key=&lt;xitrum.confの中のキー&gt;</span></code>
このURLでは上記のような <a class="reference external" href="http://d3js.org/">D3.js</a> によって生成されたグラフを参照することができます。</p>
<p>URLが動的に算出できます:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Config
import xitrum.metrics.XitrumMetricsViewer

url[XitrumMetricsViewer](&quot;api_key&quot; -&gt; Config.xitrum.metrics.get.apiKey)
</pre></div>
</div>
</div>
<div class="section" id="jconsole">
<h4>Jconsoleビューア<a class="headerlink" href="#jconsole" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference external" href="http://metrics.codahale.com/getting-started/#reporting-via-jmx">JVM Reporter</a> を使用することも可能です。</p>
<img alt="_images/metrics_jconsole.png" src="_images/metrics_jconsole.png" />
<p>JVM Reporterの開始方法:</p>
<div class="highlight-python"><div class="highlight"><pre>import com.codahale.metrics.JmxReporter

object Boot {
  def main(args: Array[String]) {
    Server.start()
    JmxReporter.forRegistry(xitrum.Metrics).build().start()
  }
}
</pre></div>
</div>
<p>アプリケーション起動後 <a class="reference external" href="http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">jconsole</a> コマンドをターミナルから実行します。</p>
</div>
<div class="section" id="id8">
<h4>カスタムビューア<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>メトリクスはJSONとしてSockJS URL <code class="docutils literal"><span class="pre">xitrum/metrics/channel</span></code> から取得する事ができます。
<code class="docutils literal"><span class="pre">jsAddMetricsNameSpace</span></code> はそのURLへ接続するためのJavaScriptスニペットをビューに出力します。
JavaScriptでJSONハンドラを実装し、<code class="docutils literal"><span class="pre">initMetricsChannel</span></code> を呼び出してください。</p>
<p>例:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.GET
import xitrum.metrics.MetricsViewer

@GET(&quot;my/metrics/viewer&quot;)
class MySubscriber extends MetricsViewer {
  def execute() {
    jsAddMetricsNameSpace(&quot;window&quot;)
    jsAddToView(&quot;&quot;&quot;
      function onValue(json) {
        console.log(json);
      }
      function onClose(){
        console.log(&quot;channel closed&quot;);
      }
      window.initMetricsChannel(onValue, onClose);
    &quot;&quot;&quot;)
    respondView()
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>メトリクスの保存<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>メモリ消費を抑制するため、Xitrumは過去のメトリクス情報について保持することはありません。
データベースやファイルへの書き出しが必要な場合、独自のサブスクライバーを実装する必要があります。</p>
<p>例:</p>
<div class="highlight-python"><div class="highlight"><pre>import akka.actor.Actor
import xitrum.metrics.PublisherLookUp

class MySubscriber extends Actor with PublisherLookUp {
  override def preStart() {
    lookUpPublisher()
  }

  def receive = {
    case _ =&gt;
  }

  override def doWithPublisher(globalPublisher: ActorRef) = {
    context.become {
      // When run in multinode environment
      case multinodeMetrics: Set[NodeMetrics] =&gt;
        // Save to DB or write to file.

      // When run in single node environment
      case nodeMetrics: NodeMetrics =&gt;
        // Save to DB or write to file.

      case Publish(registryAsJson) =&gt;
        // Save to DB or write to file.

      case _ =&gt;
    }
  }
}
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-howto"></span><div class="section" id="howto">
<h2>HOWTO<a class="headerlink" href="#howto" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この章ではいくつかの小さなtipsを紹介します。</p>
<div class="section" id="id1">
<h3>ベーシック認証<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サイト全体や特定のアクションに <a class="reference external" href="http://ja.wikipedia.org/wiki/Basic%E8%AA%8D%E8%A8%BC">ベーシック認証</a> を適用することができます。</p>
<p><a class="reference external" href="http://ja.wikipedia.org/wiki/Digest%E8%AA%8D%E8%A8%BC">ダイジェスト認証</a> についてはman-in-the-middle攻撃に対して脆弱であることから、
Xitrumではサポートしていません。</p>
<p>よりセキュアなアプリケーションとするには、HTTPSを使用することを推奨します。（XitrumはApacheやNginxをリバースプロキシとして使用することなく、単独でHTTPSサーバを構築する事ができます。）</p>
<div class="section" id="id4">
<h4>サイト全体のベーシック認証設定<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> に以下を記載:</p>
<div class="highlight-python"><div class="highlight"><pre>&quot;basicAuth&quot;: {
  &quot;realm&quot;:    &quot;xitrum&quot;,
  &quot;username&quot;: &quot;xitrum&quot;,
  &quot;password&quot;: &quot;xitrum&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>特定のアクションのベーシック認証設定<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action

class MyAction extends Action {
  beforeFilter {
    basicAuth(&quot;Realm&quot;) { (username, password) =&gt;
      username == &quot;username&quot; &amp;&amp; password == &quot;password&quot;
    }
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id6">
<h3>設定ファイルのロード<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="json">
<h4>JSONファイル<a class="headerlink" href="#json" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>JSONはネストした設定を記載するのに適した構造をしています。</p>
<p><code class="docutils literal"><span class="pre">config</span></code> ディレクトリに設定ファイルを保存します。
このディレクトリは、デベロップメントモードではbuild.sbtによって、プロダクションモードでは、<code class="docutils literal"><span class="pre">script/runner</span></code> (または <code class="docutils literal"><span class="pre">script/runner.bat</span></code> ) によって
自動的にクラスパスに含められます。</p>
<p>myconfig.json:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span>
  <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="s">&quot;God&quot;</span><span class="p">,</span>
  <span class="s">&quot;password&quot;</span><span class="p">:</span> <span class="s">&quot;Does God need a password?&quot;</span><span class="p">,</span>
  <span class="s">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="s">&quot;Eva&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ロード方法:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Loader

case class MyConfig(username: String, password: String, children: Seq[String])
val myConfig = Loader.jsonFromClasspath[MyConfig](&quot;myconfig.json&quot;)
</pre></div>
</div>
<p>備考:</p>
<ul class="simple">
<li>キーと文字列はダブルコーテーションで囲まれている必要があります。</li>
<li>現時点でJSONファイルにコメントを記載することはできません。</li>
</ul>
</div>
<div class="section" id="id7">
<h4>プロパティファイル<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>プロパティファイルを使用することもできます。
プロパティファイルは型安全ではないこと、UTF-8をサポートしてないこと、ネスト構造をサポートしていないことから、
JSONファイルを使用することができるのであれば、JSONを使用することをお勧めします。</p>
<p>myconfig.properties:</p>
<div class="highlight-python"><div class="highlight"><pre>username = God
password = Does God need a password?
children = Adam, Eva
</pre></div>
</div>
<p>ロード方法:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Loader

// Here you get an instance of java.util.Properties
val properties = Loader.propertiesFromClasspath(&quot;myconfig.properties&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>型安全な設定ファイル<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>XitrumはAkkaを内包しています。Akkaには <a class="reference external" href="http://typesafe.com/company">Typesafe社</a> 製の <a class="reference external" href="https://github.com/typesafehub/config">config</a> というライブラリをが含まれており、設定ファイルロードについて、よりベターやり方を提供してくれます。</p>
<p>myconfig.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>username = God
password = Does God need a password?
children = [&quot;Adam&quot;, &quot;Eva&quot;]
</pre></div>
</div>
<p>ロード方法:</p>
<div class="highlight-python"><div class="highlight"><pre>import com.typesafe.config.{Config, ConfigFactory}

val config   = ConfigFactory.load(&quot;myconfig.conf&quot;)
val username = config.getString(&quot;username&quot;)
val password = config.getString(&quot;password&quot;)
val children = config.getStringList(&quot;children&quot;)
</pre></div>
</div>
</div>
</div>
<div class="section" id="id9">
<h3>シリアライズとデシリアライズ<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Array[Byte]</span></code> へのシリアライズ:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri
val bytes = SeriDeseri.toBytes(&quot;my serializable object&quot;)
</pre></div>
</div>
<p>バイト配列からのデシリアライズ:</p>
<div class="highlight-python"><div class="highlight"><pre>val option = SeriDeseri.fromBytes[MyType](bytes)  // Option[MyType]
</pre></div>
</div>
<p>ファイルへの保存:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">xitrum.util.Loader</span>
<span class="n">Loader</span><span class="o">.</span><span class="n">bytesToFile</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="s">&quot;myObject.bin&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>ファイルからの読み込み:</p>
<div class="highlight-python"><div class="highlight"><pre>val bytes = Loader.bytesFromFile(&quot;myObject.bin&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>データの暗号化<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>復号化する必要がないデータの暗号化にはMD5等を使用することができます。
復号化する必要があるデータを暗号化する場合、<code class="docutils literal"><span class="pre">xitrum.util.Secure</span></code> を使用します。</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Secure

// Array[Byte]
val encrypted = Secure.encrypt(&quot;my data&quot;.getBytes)

// Option[Array[Byte]]
val decrypted = Secure.decrypt(encrypted)
</pre></div>
</div>
<p>レスポンスするHTMLに埋め込むなど、バイナリデータを文字列にエンコード/デコードする場合、
<code class="docutils literal"><span class="pre">xitrum.util.UrlSafeBase64</span></code> を使用します。</p>
<div class="highlight-python"><div class="highlight"><pre>// cookieなどのURLに含まれるデータをエンコード
val string = UrlSafeBase64.noPaddingEncode(encrypted)

// Option[Array[Byte]]
val encrypted2 = UrlSafeBase64.autoPaddingDecode(string)
</pre></div>
</div>
<p>上記の操作の組み合わせを1度に行う場合:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri

val mySerializableObject = new MySerializableClass

// String
val encrypted = SeriDeseri.toSecureUrlSafeBase64(mySerializableObject)

// Option[MySerializableClass]
val decrypted = SeriDeseri.fromSecureUrlSafeBase64[MySerializableClass](encrypted)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">SeriDeseri</span></code> はシリアライズとデシリアライズに <a class="reference external" href="https://github.com/twitter/chill">Twitter Chill</a> を使用しています。
シリアライズ対象のデータはシリアライズ可能なものである必要があります。</p>
<p>暗号化キーの指定方法:</p>
<div class="highlight-python"><div class="highlight"><pre>val encrypted = Secure.encrypt(&quot;my data&quot;.getBytes, &quot;my key&quot;)
val decrypted = Secure.decrypt(encrypted, &quot;my key&quot;)
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>val encrypted = SeriDeseri.toSecureUrlSafeBase64(mySerializableObject, &quot;my key&quot;)
val decrypted = SeriDeseri.fromSecureUrlSafeBase64[MySerializableClass](encrypted, &quot;my key&quot;)
</pre></div>
</div>
<p>キーが指定されない場合、<code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> に記載された <code class="docutils literal"><span class="pre">secureKey</span></code> が使用されます。</p>
</div>
<div class="section" id="id11">
<h3>同一ドメイン配下における複数サイトの構成<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>同一ドメイン配下に、Nginx等のリバースプロキシを動かして、以下の様な複数のサイトを構成する場合、</p>
<div class="highlight-python"><div class="highlight"><pre>http://example.com/site1/...
http://example.com/site2/...
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> にて、 <code class="docutils literal"><span class="pre">baseUrl</span></code> を設定することができます。</p>
<p>JavaScriptからAjaxリクエスを行う正しいURLを取得するには、<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a> の、<code class="docutils literal"><span class="pre">withBaseUrl</span></code> メソッドを使用します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 現在のサイトのbaseUrlが &quot;site1&quot; の場合、</span>
<span class="c"># 結果は /site1/path/to/my/action になります。</span>
<span class="n">xitrum</span><span class="o">.</span><span class="n">withBaseUrl</span><span class="p">(</span><span class="s">&#39;/path/to/my/action&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="markdownhtml">
<h3>MarkdownからHTMLへの変換<a class="headerlink" href="#markdownhtml" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>テンプレートエンジンとして、<a class="reference internal" href="index.html#document-template_engines"><em>Scalate</em></a> を使用するプロジェクトの場合:</p>
<div class="highlight-python"><div class="highlight"><pre>import org.fusesource.scalamd.Markdown
val html = Markdown(&quot;input&quot;)
</pre></div>
</div>
<p>Scalateを使用しない場合、
build.sbtに以下の依存ライブラリを追記する必要があります:</p>
<div class="highlight-python"><div class="highlight"><pre>libraryDependencies += &quot;org.fusesource.scalamd&quot; %% &quot;scalamd&quot; % &quot;1.6&quot;
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>ファイル監視<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ファイルやディレクトリの <a class="reference external" href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/StandardWatchEventKinds.html">StandardWatchEventKinds</a> に対してコールバックを設定することができます。</p>
<div class="highlight-python"><div class="highlight"><pre>import java.nio.file.Paths
import xitrum.util.FileMonitor

val target = Paths.get(&quot;absolute_path_or_path_relative_to_application_directory&quot;).toAbsolutePath
FileMonitor.monitor(FileMonitor.MODIFY, target, { path =&gt;
  // コールバックでは path を使用することができます
  println(s&quot;File modified: $path&quot;)

  // 監視が不要な場合
  FileMonitor.unmonitor(FileMonitor.MODIFY, target)
})
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">FileMonitor</span></code> は <a class="reference external" href="https://github.com/lloydmeta/schwatcher">Schwatcher</a> を使用しています。</p>
</div>
<div class="section" id="id13">
<h3>一時ディレクトリ<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルト( <code class="docutils literal"><span class="pre">xitrum.conf</span></code> の <code class="docutils literal"><span class="pre">tmpDir</span></code> の設定内容)では、カレントディレクトリ内の <code class="docutils literal"><span class="pre">tmp</span></code> というディレクトリが
一時ディレクトリとして、Scalateによってい生成された .scalaファイルや、大きなファイルのアップロードなどに使用されます。</p>
<p>プログラムから一時ディレクトリを使用する場合:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">Config</span><span class="o">.</span><span class="n">xitrum</span><span class="o">.</span><span class="n">tmpDir</span><span class="o">.</span><span class="n">getAbsolutePath</span>
</pre></div>
</div>
<p>新規ファイルやディレクトリを一時ディレクトリに作成する場合:</p>
<div class="highlight-python"><div class="highlight"><pre>val file = new java.io.File(xitrum.Config.xitrum.tmpDir, &quot;myfile&quot;)

val dir = new java.io.File(xitrum.Config.xitrum.tmpDir, &quot;mydir&quot;)
dir.mkdirs()
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>ビデオストリーミング<a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ビデオをストリーミングする方法はいくつかあります。
最も簡単な方法は:</p>
<ul class="simple">
<li>インターリーブされた.mp4ファイルをサーバに配置することで、ユーザーはダウンロード中にビデオを再生することができます。</li>
<li>そして、Xitrumのように <a class="reference external" href="http://en.wikipedia.org/wiki/Byte_serving">range requests</a> をサポートしたHTTPサーバーを用いることで、
ユーザーはダウンロードされていない部分をスキップしてビデオを利用することができます。</li>
</ul>
<p><a class="reference external" href="http://gpac.wp.mines-telecom.fr/mp4box/">MP4Box</a> を利用することで、
動画ファイルを500ミリ秒毎のチャンクにインターリーブすることができます:</p>
<div class="highlight-python"><div class="highlight"><pre>MP4Box -inter 500 movie.mp4
</pre></div>
</div>
</div>
</div>
<span id="document-deps"></span><div class="section" id="id1">
<h2>依存関係<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id2">
<h3>依存ライブラリ<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Xitrumは以下のライブラリにが依存しています。
つまりあなたのXitrumプロジェクトはこれらのライブラリを直接使用することができます。</p>
<img alt="_images/deps.png" src="_images/deps.png" />
<p>主な依存ライブラリ:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.scala-lang.org/">Scala</a>:
XitrumはScalaで書かれています。</li>
<li><a class="reference external" href="https://netty.io/">Netty</a>:
WebSocketやゼロコピーファイルサービングなど
Xitrumの非同期HTTP(S)サーバの多くの機能はNettyの機能を元に実現しています。</li>
<li><a class="reference external" href="http://akka.io/">Akka</a>:
主にSockJSのために。Akkaは <a class="reference external" href="https://github.com/typesafehub/config">Typesafe Config</a>
に依存しており、Xitrumもまたそれを使用しています。</li>
</ul>
<p>その他の主な依存ライブラリ:</p>
<ul class="simple">
<li><a class="reference external" href="http://commons.apache.org/lang/">Commons Lang</a>:
JSONデータのエスケープに使用しています。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/glokka">Glokka</a>:
SockJS アクターのクラスタリングに使用しています。</li>
<li><a class="reference external" href="https://github.com/json4s/json4s">JSON4S</a>:
JSONのパースと生成のために使用します。
JSON4Sは <a class="reference external" href="http://paranamer.codehaus.org/">Paranamer</a> を依存ライブラリとして使用しています。</li>
<li><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Rhino">Rhino</a>:
Scalate内でCoffeeScriptをJavaScriptにコンパイルするために使用しています。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/sclasner">Sclasner</a>:
クラスファイルとjarファイルからHTTPルートをスキャンするために使用しています。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/scaposer">Scaposer</a>:
国際化対応のために使用しています。</li>
<li><a class="reference external" href="https://github.com/twitter/chill">Twitter Chill</a>:
クッキーとセッションのシリアライズ・デシリアライズに使用しています。
Chillは <a class="reference external" href="http://code.google.com/p/kryo/">Kryo</a> を元にしています。</li>
<li><a class="reference external" href="http://slf4s.org/">SLF4S</a>, <a class="reference external" href="http://logback.qos.ch/">Logback</a>:
ロギングに使用しています。</li>
</ul>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">Xitrum プロジェクトスケルトン</a> は</p>
<p>以下のツールを梱包しています:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/scala-xgettext">scala-xgettext</a>:
コンパイル時に .scala ファイルから <a class="reference internal" href="index.html#document-i18n"><em>国際化対応</em></a> 文字列を展開します。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-package">xitrum-package</a>:
本番環境へデプロイするために <a class="reference internal" href="index.html#document-deploy"><em>プロジェクトをパッケージング</em></a> します。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/scalive">Scalive</a>:
ScalaコンソールからJVMプロセスに接続し、動的なデバッギングを可能にします。</li>
</ul>
</div>
<div class="section" id="id3">
<h3>関連プロジェクト<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デモ:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">xitrum-new</a>:
新規Xitrumプロジェクトのスケルトン。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-demos">xitrum-demos</a>:
Xitrumの各機能のデモプロジェクト。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-placeholder">xitrum-placeholder</a>:
Xitrumによる画像イメージアプリのデモ。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/comy">comy</a>:
XitrumによるURLショートナーアプリのデモ。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-multimodule-demo">xitrum-multimodule-demo</a>:
<a class="reference external" href="http://www.scala-sbt.org/">SBT</a> マルチモジュールプロジェクトのデモ。</li>
</ul>
<p>プラグイン:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a>:
Xitrumのデフォルトテンプレートエンジン。<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">Xitrum プロジェクトスケルトン</a> で使用しています。
別のテンプレートエンジンを使用することも、また必要がなければプロジェクトから削除してしまうことも可能です。
xitrum-scalateは <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a> と <a class="reference external" href="https://github.com/chirino/scalamd">Scalamd</a> に依存しています。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">xitrum-hazelcast</a>:
キャッシュとサーバーサイドセッションのクラスタリングを行うプラグイン。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-ko">xitrum-ko</a>:
<a class="reference external" href="http://knockoutjs.com/">Knockoutjs</a> を簡単に使うためのプラグイン。</li>
</ul>
<p>その他のプロジェクト:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-doc">xitrum-doc</a>:
<a class="reference external" href="http://xitrum-framework.github.io/guide.html">Xitrum Guide</a> のソースコード。</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-framework.github.io">xitrum-hp</a>:
<a class="reference external" href="http://xitrum-framework.github.io/">Xitrum Homepage</a> のソースコード。</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html#document-index">目次</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro">はじめに</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">特徴</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">貢献者</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-tutorial">チュートリアル</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum">Xitrumプロジェクトの作成</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">起動</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#eclipse">Eclipseプロジェクトの作成</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#intellij-idea">IntelliJ IDEAプロジェクトの作成</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">自動リロード</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#ide">IDEを使用する場合</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id7">SBTを使用する場合</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dcevm">DCEVM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ignore">ignoreファイルの設定</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-action_view">Action と view</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#futureaction">FutureAction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#actoraction">ActorAction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">クライアントへのレスポンス送信</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#view">テンプレートViewファイルのレスポンス</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#currentaction">currentActionのキャスト</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id2">Mustache</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#coffeescript">CoffeeScript</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">レイアウト</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id5">独立したレイアウトファイルを使用しないパターン</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#respondview">respondViewにレイアウトを直接指定するパターン</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#respondinlineview">respondInlineView</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#renderfragment">renderFragment</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">別のアクションに紐付けられたViewをレスポンスする場合</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id7">ひとつのアクションに複数のViewを紐付ける方法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#component">Component</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-restful">RESTful APIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">ルートのキャッシング</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#firstlast">ルートの優先順位(first、last)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#action">Actionへの複数パスの関連付け</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">ドットを含むルート</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">正規表現によるルーティング</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">パスの残り部分の取得</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">アクションへのリンク</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">他のアクションへのリダイレクト</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">他のアクションへのフォワード</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax">Ajaxリクエストの判定</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#csrf">CSRF対策</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#csrfcsrf">CSRF対策インプットとCSRF対策トークン</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">CSRFチェックの省略</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">ルーティングの操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id11">リクエストコンテンツの取得</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#swaggerapi">SwaggerによるAPIドキュメンテーション</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-template_engines">テンプレートエンジン</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">テンプレートエンジンの設定</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">テンプレートエンジンの削除</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">テンプレートエンジンの作成</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-postback">ポストバック</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">レイアウト</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">フォーム</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#form">formエレメント以外への適用</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">コンファームダイアログ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">パラメーターの追加</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">ローディングイメージの表示</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-xml">XML</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">XMLのアンエスケープ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">XMLエレメントのグループ化</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xhtml">XHTMLの描画</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-js">JavaScript と JSON</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#javascript">JavaScript</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#javascriptview">JavaScriptフラグメントをViewに追加する方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id1">JavaScriptを直接レスポンスする方法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#json">JSON</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#knockout-js">Knockout.jsプラグイン</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-async">非同期レスポンス</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#websocket">WebSocket</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#sockjs">SockJS</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#chunk">Chunkレスポンス</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#iframe">無限iframe</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#event-source">Event Source</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-static">静的ファイル</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">ディスク上の静的ファイルの配信</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#index-html">index.htmlへのフォールバック</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">404 と 500</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#webjar">WebJarによるクラスパス上のリソースファイルの配信</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#webjars">WebJars</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id5">WebJars形式によるリソースの保存</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id7">クラスパス上の要素をレスポンスする場合</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#etagmax-age">ETagとmax-ageによるクライアントサイドキャッシュ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#gzip">GZIP</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">サーバーサイドキャッシュ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-flash">Flashのソケットポリシーファイル</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-scopes">スコープ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">リクエストスコープ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">リクエストパラメーター</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id4">パラメーターへのアクセス</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#at">&#8220;at&#8221;</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#atjson">&#8220;atJson&#8221;</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#requestvar">RequestVar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">クッキー</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id6">クッキーに使用可能な文字</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">セッション</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#session-clear">session.clear()</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sessionvar">SessionVar</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">セッションストア</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#object-vs-val">object vs. val</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-validation">バリデーション</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">デフォルトバリデーター</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">カスタムバリデーターの作成</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-upload">ファイルアップロード</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax">Ajax風ファイルアップロード</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-filter">アクションフィルター</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#before">Beforeフィルター</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#after">Afterフィルター</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#around">Aroundフィルター</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">フィルターの実行順番</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cache">サーバーサイドキャッシュ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">ページまたはアクションのキャッシュ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">オブジェクトのキャッシュ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">キャッシュの削除</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">キャッシュエンジンの設定</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">キャッシュ動作の仕組み</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-util-locallrucache">xitrum.util.LocalLruCache</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-i18n">I18n</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">ソースコード内への国際化メッセージの記載</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#pot">potファイルへのメッセージの展開</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#po">po ファイルの保存先</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">言語の設定</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">バリデーションメッセージ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">複数形への対応</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">日付と数値のフォーマット</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-log">ログ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-log">xitrum.Logオブジェクトを直接使用する</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">xitrum.Logトレイトを直接使用する</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">ログレベルをチェックする必要はありません</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">ログレベル、ログファイル等の設定</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#fluentd">Fluentd へのログ出力</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deploy">プロダクション環境へのデプロイ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">ディレクトリのパッケージ化</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-package">xitrum-packageのカスタマイズ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#jvmscala">稼働中のJVMプロセスに対するScalaコンソール接続</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#centosubuntuoraclejdk">CentOSまたはUbuntuへのOracleJDKインストール</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum">システム起動時にXitrumをスタートさせる</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">ポートフォワーディングの設定</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#linux">大量コネクションに対するLinux設定</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">ファイルディスクリプタ数の上限設定</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id10">カーネルのチューニング</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id11">バックログについて</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#haproxy-tips">HAProxy tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nginx-tips">Nginx tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#heroku">Herokuへのデプロイ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id17">サインアップとリポジトリの作成</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#procfile">Procfileの作成</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#port">Port設定の変更</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id20">ログレベルの設定</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id21"><code class="docutils literal"><span class="pre">xitrum-package</span></code> のエイリアス作成</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id22">Herokuへのプッシュ</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#openshift">OpenShiftへのデプロイ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id24">サインアップとリポジトリの作成</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id26">プロジェクト構成</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#action-hooks">action_hooksの作成</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#ip-port">IP:Port設定の変更</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sbt">sbt引数の修正</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#openshiftpush">openshiftへのpush</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cluster">AkkaとHazelcastでサーバーをクラスタリングする</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-handler">Nettyハンドラ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Nettyハンドラの構成</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">ハンドラの追加作成</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum">Xitrumが提供するハンドラ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-metrics">メトリクス</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">メトリクスの収集</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#cpu">ヒープメモリとCPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">アクションの実行ステータス</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id4">カスタムメトリクスの収集</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">メトリクスの配信</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#xitrum">Xitrumデフォルトビューア</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#jconsole">Jconsoleビューア</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id8">カスタムビューア</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">メトリクスの保存</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-howto">HOWTO</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">ベーシック認証</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id4">サイト全体のベーシック認証設定</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id5">特定のアクションのベーシック認証設定</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">設定ファイルのロード</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#json">JSONファイル</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id7">プロパティファイル</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id8">型安全な設定ファイル</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">シリアライズとデシリアライズ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">データの暗号化</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id11">同一ドメイン配下における複数サイトの構成</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#markdownhtml">MarkdownからHTMLへの変換</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id12">ファイル監視</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id13">一時ディレクトリ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id14">ビデオストリーミング</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deps">依存関係</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">依存ライブラリ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">関連プロジェクト</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li><a href="index.html#document-index">Xitrum Scala Web Framework Guide 3.22 ドキュメント</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2010, Ngoc Dao.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b2 で生成しました。
    </div>
  </body>
</html>