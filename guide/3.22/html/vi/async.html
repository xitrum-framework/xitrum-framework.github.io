<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Async response &mdash; Xitrum Scala Web Framework Guide 3.22 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.22',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Xitrum Scala Web Framework Guide 3.22 documentation" href="index.html" />
    <link rel="next" title="Các tệp tĩnh" href="static.html" />
    <link rel="prev" title="JavaScript and JSON" href="js.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="static.html" title="Các tệp tĩnh"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="js.html" title="JavaScript and JSON"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Xitrum Scala Web Framework Guide 3.22 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="async-response">
<h1>Async response<a class="headerlink" href="#async-response" title="Permalink to this headline">¶</a></h1>
<p>Danh sách các method responding thông thường:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">respondView</span></tt>: respond tệp view, có hoặc không có layout.</li>
<li><tt class="docutils literal"><span class="pre">respondInlineView</span></tt>: respond template đã được nhúng(không tách rời các tệp template), có
hoặc không có layout.</li>
<li><tt class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></tt>: respond một string, không có layout</li>
<li><tt class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></tt>: như trên, với content type đặt là &#8220;text/html&#8221;</li>
<li><tt class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></tt>: convert Scala object thành JSON object sau đó respond</li>
<li><tt class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></tt>: kết hợp cả 2 method ở trên</li>
<li><tt class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">respondBinary</span></tt>: respond một mảng byte</li>
<li><tt class="docutils literal"><span class="pre">respondFile</span></tt>: send một tệp trực tiếp từ đĩa với tốc độ cao, sử dụng
<a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a>
(aka send-file)</li>
<li><tt class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></tt></li>
</ul>
<p>Xitrum không tự động gửi bất kỳ response nào.
Bạn phải gọi method <tt class="docutils literal"><span class="pre">respondXXX</span></tt> ở trên để gửi response.
Nếu bạn không gọi <tt class="docutils literal"><span class="pre">respondXXX</span></tt>, Xitrum sẽ giữ kết nối HTTP, và bạn có thể
gọi <tt class="docutils literal"><span class="pre">respondXXX</span></tt> sau.</p>
<p>Để kiểm tra kết nối còn mở hay không, gọi <tt class="docutils literal"><span class="pre">channel.isOpen</span></tt>.
Bạn cũng có thể sử dụng <tt class="docutils literal"><span class="pre">addConnectionClosedListener</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>addConnectionClosedListener {
  // The connection has been closed
  // Unsubscribe from events, release resources etc.
}
</pre></div>
</div>
<p>Vì tính năng async response không được gửi ngay lập tức.
<tt class="docutils literal"><span class="pre">respondXXX</span></tt> trả về
<a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html">ChannelFuture</a>.
Bạn có thể sử dụng nó để thực hiện action khi response đã thực sự được gửi đi.</p>
<p>Ví dụ, bạn muốn đóng kết nối sau khi response đã được gửi đi:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.channel.{ChannelFuture, ChannelFutureListener}

val future = respondText(&quot;Hello&quot;)
future.addListener(new ChannelFutureListener {
  def operationComplete(future: ChannelFuture) {
    future.getChannel.close()
  }
})
</pre></div>
</div>
<p>hoặc ngắn hơn:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondText</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">addListener</span><span class="p">(</span><span class="n">ChannelFutureListener</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="websocket">
<h2>WebSocket<a class="headerlink" href="#websocket" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre>import scala.runtime.ScalaRunTime
import xitrum.annotation.WEBSOCKET
import xitrum.{WebSocketAction, WebSocketBinary, WebSocketText, WebSocketPing, WebSocketPong}

@WEBSOCKET(&quot;echo&quot;)
class EchoWebSocketActor extends WebSocketAction {
  def execute() {
    // Here you can extract session data, request headers etc.
    // but do not use respondText, respondView etc.
    // To respond, use respondWebSocketXXX like below.

    log.debug(&quot;onOpen&quot;)

    context.become {
      case WebSocketText(text) =&gt;
        log.info(&quot;onTextMessage: &quot; + text)
        respondWebSocketText(text.toUpperCase)

      case WebSocketBinary(bytes) =&gt;
        log.info(&quot;onBinaryMessage: &quot; + ScalaRunTime.stringOf(bytes))
        respondWebSocketBinary(bytes)

      case WebSocketPing =&gt;
        log.debug(&quot;onPing&quot;)

      case WebSocketPong =&gt;
        log.debug(&quot;onPong&quot;)
    }
  }

  override def postStop() {
    log.debug(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>Một actor sẽ được tạo khi có một request. Actor sẽ được dừng lại khi một trong các điều kiện sau
xảy ra:</p>
<ul class="simple">
<li>Kết nối bị đóng.</li>
<li>WebSocket close frame được nhận hoặc gửi đi</li>
</ul>
<p>Sử dụng các method sau để gửi WebSocket frames:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">respondWebSocketText</span></tt></li>
<li><tt class="docutils literal"><span class="pre">respondWebSocketBinary</span></tt></li>
<li><tt class="docutils literal"><span class="pre">respondWebSocketPing</span></tt></li>
<li><tt class="docutils literal"><span class="pre">respondWebSocketClose</span></tt></li>
</ul>
<p>Không có respondWebSocketPong, vì Xitrum sẽ tự động gửi pong frame
khi nó nhận được ping frame.</p>
<p>Để lấy URL cho WebSocket action ở trên:</p>
<div class="highlight-python"><div class="highlight"><pre>// Probably you want to use this in Scalate view etc.
val url = webSocketAbsUrl[EchoWebSocketActor]
</pre></div>
</div>
</div>
<div class="section" id="sockjs">
<h2>SockJS<a class="headerlink" href="#sockjs" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/sockjs/sockjs-client">SockJS</a> là một thư viện trình duyệt
JavaScript cung cấp một WebSocket-like object, dành cho các trình duyệt không hỗ
trợ WebSocket. Đầu tiên SockJS thử sử dụng WebSocket. Nếu không thành công, nó có thể sử dụng một số cách nhưng vẫn đưa về sử dụng WebSocket-like object.</p>
<p>Nếu bạn muốn làm việc với WebSocket API trên mọi trình duyệt, bạn nên sử dụng
SockJS và tránh sử dụng trực tiếp WebSocket directly.</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  var sock = new SockJS(&#39;http://mydomain.com/path_prefix&#39;);
  sock.onopen = function() {
    console.log(&#39;open&#39;);
  };
  sock.onmessage = function(e) {
    console.log(&#39;message&#39;, e.data);
  };
  sock.onclose = function() {
    console.log(&#39;close&#39;);
  };
&lt;/script&gt;
</pre></div>
</div>
<p>Xitrum bao gồm các tệp JavaScript của SockJS.
Trong view template, chỉ cần viết như sau:</p>
<div class="highlight-python"><div class="highlight"><pre>...
html
  head
    != jsDefaults
...
</pre></div>
</div>
<p>SockJS đòi hỏi một <a class="reference external" href="https://github.com/sockjs/sockjs-protocol">server counterpart</a>.
Xitrum sẽ tự động cung cấp.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SockJsAction, SockJsText}
import xitrum.annotation.SOCKJS

@SOCKJS(&quot;echo&quot;)
class EchoSockJsActor extends SockJsAction {
  def execute() {
    // To respond, use respondSockJsXXX like below

    log.info(&quot;onOpen&quot;)

    context.become {
      case SockJsText(text) =&gt;
        log.info(&quot;onMessage: &quot; + text)
        respondSockJsText(text)
    }
  }

  override def postStop() {
    log.info(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>Một actor sẽ được tạo khi có một SockJS session mới. Nó sẽ dừng lại khi SockJS session này
đóng lại.</p>
<p>Sử dụng các method sau để gửi các send SockJS frames:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">respondSockJsText</span></tt></li>
<li><tt class="docutils literal"><span class="pre">respondSockJsClose</span></tt></li>
</ul>
<p>Xem <a class="reference external" href="https://github.com/sockjs/sockjs-node#various-issues-and-design-considerations">Various issues and design considerations</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>Về cơ bản, cookie không phù hợp với mô hình SockJS. Nếu bạn muốn authorize cho một
session, cũng cấp một token đặc biệt trên một page, gửi chúng như những thứ đầu tiên
qua kết nối SockJS và validate nó ở server. Về cơ bản thì đây là cách thức hoạt động của
cookie
</pre></div>
</div>
<p>Để cấu hình SockJS clustering, xem <a class="reference internal" href="cluster.html"><em>Clustering với Akka</em></a>.</p>
</div>
<div class="section" id="chunked-response">
<h2>Chunked response<a class="headerlink" href="#chunked-response" title="Permalink to this headline">¶</a></h2>
<p>Để gửi <a class="reference external" href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked response</a>:</p>
<ol class="arabic simple">
<li>Gọi <tt class="docutils literal"><span class="pre">setChunked</span></tt></li>
<li>Gọi <tt class="docutils literal"><span class="pre">respondXXX</span></tt> bao nhiêu lần bạn muốn</li>
<li>Cuối cùng, gọi <tt class="docutils literal"><span class="pre">respondLastChunk</span></tt></li>
</ol>
<p>Chunked response có nhiều use cases. Ví dụ, khi bạn cần generate một tệp CSV lớn hơn bộ nhớ, bạn có thể generate chunk by chunk và gửi chúng khi bạn generate:</p>
<div class="highlight-python"><div class="highlight"><pre>// &quot;Cache-Control&quot; header will be automatically set to:
// &quot;no-store, no-cache, must-revalidate, max-age=0&quot;
//
// Note that &quot;Pragma: no-cache&quot; is linked to requests, not responses:
// http://palizine.plynt.com/issues/2008Jul/cache-control-attributes/
setChunked()

val generator = new MyCsvGenerator

generator.onFirstLine { line =&gt;
  if (channel.isOpen) respondText(header, &quot;text/csv&quot;)
}

generator.onNextLine { line =&gt;
  if (channel.isOpen) respondText(line)
}

generator.onLastLine { line =&gt;
  if (channel.isOpen) {
    respondText(line)
    respondLastChunk()
  }
}

generator.generate()
</pre></div>
</div>
<p>Ghi nhớ:</p>
<ul class="simple">
<li>Header được gửi ở lần gọi <tt class="docutils literal"><span class="pre">respondXXX</span></tt> đầu tiên.</li>
<li>Bạn có thể gửi các optional trailing header tại <tt class="docutils literal"><span class="pre">respondLastChunk</span></tt></li>
<li><a class="reference internal" href="cache.html"><em>Page và action cache</em></a> không thế sử dụng với chunked response.</li>
</ul>
<p>Với việc sử dụng chunked response cùng với <tt class="docutils literal"><span class="pre">ActorAction</span></tt>, bạn có thể dễ dàng implement
<a class="reference external" href="http://www.cubrid.org/blog/dev-platform/faster-web-page-loading-with-facebook-bigpipe/">Facebook BigPipe</a>.</p>
<div class="section" id="forever-iframe">
<h3>Forever iframe<a class="headerlink" href="#forever-iframe" title="Permalink to this headline">¶</a></h3>
<p>Chunked response <a class="reference external" href="http://www.shanison.com/2010/05/10/stop-the-browser-%E2%80%9Cthrobber-of-doom%E2%80%9D-while-loading-comet-forever-iframe/">có thể được sử dụng</a>
cho <a class="reference external" href="http://en.wikipedia.org/wiki/Comet_%28programming%29">Comet</a>.</p>
<p>Page nhúng iframe:</p>
<div class="highlight-python"><div class="highlight"><pre>...
&lt;script&gt;
  var functionForForeverIframeSnippetsToCall = function() {...}
&lt;/script&gt;
...
&lt;iframe width=&quot;1&quot; height=&quot;1&quot; src=&quot;path/to/forever/iframe&quot;&gt;&lt;/iframe&gt;
...
</pre></div>
</div>
<p>Action respond <tt class="docutils literal"><span class="pre">&lt;script&gt;</span></tt> snippets mãi mãi:</p>
<div class="highlight-python"><div class="highlight"><pre>// Prepare forever iframe

setChunked()

// Need something like &quot;123&quot; for Firefox to work
respondText(&quot;&lt;html&gt;&lt;body&gt;123&quot;, &quot;text/html&quot;)

// Most clients (even curl!) do not execute &lt;script&gt; snippets right away,
// we need to send about 2KB dummy data to bypass this problem
for (i &lt;- 1 to 100) respondText(&quot;&lt;script&gt;&lt;/script&gt;\n&quot;)
</pre></div>
</div>
<p>Sau đo, bất cứ khi nào bạn muốn truyền dữ liệu đến trình duyệt, chỉ cần gửi một snippet:</p>
<div class="highlight-python"><div class="highlight"><pre>if (channel.isOpen)
  respondText(&quot;&lt;script&gt;parent.functionForForeverIframeSnippetsToCall()&lt;/script&gt;\n&quot;)
else
  // The connection has been closed, unsubscribe from events etc.
  // You can also use ``addConnectionClosedListener``.
</pre></div>
</div>
</div>
<div class="section" id="event-source">
<h3>Event Source<a class="headerlink" href="#event-source" title="Permalink to this headline">¶</a></h3>
<p>Xem <a class="reference external" href="http://dev.w3.org/html5/eventsource/">http://dev.w3.org/html5/eventsource/</a></p>
<p>Event Source response là một loại chunked response đặc biệt.
Dữ liệu phải là kiểu UTF-8.</p>
<p>Để respond event source, gọi <tt class="docutils literal"><span class="pre">respondEventSource</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>respondEventSource(&quot;data1&quot;, &quot;event1&quot;)  // Event name is &quot;event1&quot;
respondEventSource(&quot;data2&quot;)            // Event name is set to &quot;message&quot; by default
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Async response</a><ul>
<li><a class="reference internal" href="#websocket">WebSocket</a></li>
<li><a class="reference internal" href="#sockjs">SockJS</a></li>
<li><a class="reference internal" href="#chunked-response">Chunked response</a><ul>
<li><a class="reference internal" href="#forever-iframe">Forever iframe</a></li>
<li><a class="reference internal" href="#event-source">Event Source</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="js.html"
                        title="previous chapter">JavaScript and JSON</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="static.html"
                        title="next chapter">Các tệp tĩnh</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/async.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="static.html" title="Các tệp tĩnh"
             >next</a> |</li>
        <li class="right" >
          <a href="js.html" title="JavaScript and JSON"
             >previous</a> |</li>
        <li><a href="index.html">Xitrum Scala Web Framework Guide 3.22 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Ngoc Dao.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>