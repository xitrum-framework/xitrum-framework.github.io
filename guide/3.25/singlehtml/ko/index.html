<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Xitrum Scala Web Framework Guide 3.25.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.25.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="None" href="index.html#document-index" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">Xitrum Scala Web Framework Guide 3.25.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="xitrum">
<h1>Xitrum 가이드<a class="headerlink" href="#xitrum" title="제목 주소">¶</a></h1>
<p><a class="reference external" href="http://xitrum-framework.github.io/guide.html">Xitrum는 영어, 일본어, 러시아어, 베트남어 버전 형태로도 주문 가능합니다.</a></p>
<div class="toctree-wrapper compound">
<span id="document-intro"></span><p>소개
===</p>
<div class="highlight-python"><div class="highlight"><pre>+--------------------+
|      Clients       |
+--------------------+
          |
+--------------------+
|       Netty        |
+--------------------+
|       Xitrum       |
| +----------------+ |
| | HTTP(S) Server | |
| |----------------| |
| | Web framework  | |  &lt;- Akka, Hazelcast -&gt; Other instances
| +----------------+ |
+--------------------+
|      Your app      |
+--------------------+
</pre></div>
</div>
<p>Xitrum은 <a class="reference external" href="http://netty.io/">Netty</a> 와 <a class="reference external" href="http://akka.io/">Akka</a> 를 기반으로 구축된 비동기 적으로 확장가능한 HTTP(S) Web 프레임웍입니다.</p>
<blockquote>
<div><p>Xitrum <a class="reference external" href="https://groups.google.com/group/xitrum-framework/msg/d6de4865a8576d39">사용자</a> 로 부터:</p>
<blockquote>
<div><p>이것은 정말 인상적인 작품으로, 아마도 Lift를 제외하고 가장 완벽한 (그리고 아주 쉬운) Scala 프레임웍 입니다.</p>
<p><a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> 은 Web 프레임웍의 기본 기능을 모두 충족하는 풀 스택의 Web 프레임웍입니다.
정말 다행스러운건 ETags, 정적 파일 캐쉬, 자동 gzip 압축, 내장된 JSON 변환기, 인터셉터, 리퀘스트, 세션, 쿠키, 플래시 스코프, 서버와 클라이언트의 통합 검증, 내장된 캐쉬 (<a class="reference external" href="http://www.hazelcast.org/">Hazelcast</a>), 그리고 Netty가 내장된, 이러한 기능을 바로 사용할 수 있습니다. 와우</p>
</div></blockquote>
</div></blockquote>
<p>기능
&#8212;</p>
<ul class="simple">
<li>Scala 사상에 기초한 Type-Safe. 모든API는 Type-Safe하도록 디자인 되어 있습니다..</li>
<li>Netty 사상에 기초한 비동기처리. 요청의 처리결과에 대한 액션을 곧바로 반환할 필요가 없습니다 .
Long polling, chunked response (스트리밍), WebSocket, and SockJS을 지원합니다.징</li>
<li><a class="reference external" href="http://netty.io/">Netty</a> 에 내장된 고속HTTP(S) 서버.
(HTTPS는Java엔진과 OpenSSL을 선택할 수 있습니다.)
Xitrum의 정적파일 전송속도는 <a class="reference external" href="https://gist.github.com/3293596">Nginx</a> 와 비슷합니다.</li>
<li>빠른응답을 위한 광범위한 서버와 클라이언트 캐쉬.웹 서버측 에서는 작은 파일은 메모리에 캐쉬되고 큰 파일은 NIO의 zero copy를 사용하여 전송됩니다.
웹 프레임웍 측에서는 Rails스타일 처럼 page, action 그리고 object cache를 사용합니 .
<a class="reference external" href="http://code.google.com/speed/page-speed/docs/rules_intro.html">All Google&#8217;s best practices</a> 에 있는것 처럼、
조건적으로 GET 에대해 클라이언트측 Cache가 적용됩니다.
물론 브라우저에 강제로 요청 및 재선송을 할 수 있습니다 .</li>
<li>정적 파일에 대한 <a class="reference external" href="http://en.wikipedia.org/wiki/Byte_serving">Range requests</a> 지원.
이 기능、모바일에 동영상 전송이나、모든 클라이언트에게 파일 전송을 중지하거나 다시 시작할 수 있습니다.</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a> 지원.</li>
<li>JAX-RS 와 Rails엔진의 사상에 기초한 자동 라우트 수집.모든 루트에 대해서 하나의 파일에 선언할 필요가 없습니다.
이 기능은 분산 라우팅을 위해 고려되었습니다.이 기능으로 인해 어플리케이션을 다른 어플리케이션에 통합이 가능합니다.
만약 당신이 블로그엔진을 만든다면 그것을 JAR처럼 다른 어플리케이션으로 통합하는 즉시 블로그 기능을 사용할 수 있게 합니다.
라우팅에는 두가지 특징이 있습니다.
Type-Safe 한 방법으로 URL을 재생성 하거나（리버스 라우팅)、
<a class="reference external" href="http://swagger.wordnik.com/">Swagger Doc</a> 을 이용하여 문서화 할 수 있습니다.</li>
<li>Develop Mode에서는 클래스 파일과 라우트 정보는 자동으로 갱신됩니다 .</li>
<li>View는 독립적인 <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a> 템플릿이나、
Scala 의 인라인 XML로 작성되고 、모두 Type-Safe합니다.</li>
<li>Cookie에 의한（더 확장가능한）、<a class="reference external" href="http://www.hazelcast.org/">Hazelcast</a> 클러스터를 이용한 (보다 안전한) 세션관리.
Hazelcast는（매우 빠르고、쉬운）프로세스간 분산 Cache도 제공합니다.
굳이 다른 캐시 서버를 준비 할 필요는 없습니다.Akka 의 pubsub 기능과도 같습니다.</li>
<li><a class="reference external" href="http://jqueryvalidation.org/">jQuery Validation</a> 를 이용한 브라우저와 서버의 양쪽 검증.</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/GNU_gettext">GNU gettext</a> 를 사용한 국제화.
텍스트의 추출과 번역이 자동으로 이루어져서、번잡한 속성파일은 필요하지 않습니다.
번역과 통합작업에는 <a class="reference external" href="http://www.poedit.net/screenshots.php">Poedit</a> 와 같은 강력한 도구를 사용할 수 있습니.
gettext는、대부분의 다른 솔루션과 달리、단수와 복수 두 형식을 모두 지원하고 있습니다.</li>
</ul>
<p>Xitrum은 <a class="reference external" href="https://github.com/scalatra/scalatra">Scalatra</a> 와、
<a class="reference external" href="http://liftweb.net/">Lift</a> 두 가지 특징을 모두 사용하려고 합니다 : Scalatra 보다 강력하고 Lift 보다 사용하기 쉬운것이 특입니다.
<a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> 은 많은 개발자에게 친숙한 controller-first를 사용하기 위해  Scalatra 의 controller-first 를 、Lift 의 <a class="reference external" href="http://www.assembla.com/wiki/show/liftweb/View_First">view-first</a> 를 적용하지 않았습니다.
.</p>
<p><a class="reference internal" href="index.html#document-deps"><em>연관된 프로젝트</em></a> 샘플, 플러그인 등의 프로젝트 목록을 참고하세요.</p>
<div class="section" id="id5">
<h2>기여자들<a class="headerlink" href="#id5" title="제목 주소">¶</a></h2>
<p><a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> 은 <a class="reference external" href="https://github.com/xitrum-framework/xitrum">오픈소</a> 오픈소스입니다.
<a class="reference external" href="http://groups.google.com/group/xitrum-framework">Google group</a>. 에 가입하세요.</p>
<p>기여자들은 <a class="reference external" href="https://github.com/xitrum-framework/xitrum/graphs/contributors">공헌한 날</a> 의 순서대로 되어있습니다:</p>
<p>(*): 현재 코어 개발자들ー</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/ngocdaothanh">Ngoc Dao (*)</a></li>
<li><a class="reference external" href="https://github.com/alide">Linh Tran</a></li>
<li><a class="reference external" href="https://github.com/earldouglas">James Earl Douglas</a></li>
<li><a class="reference external" href="https://github.com/caiiiycuk">Aleksander Guryanov</a></li>
<li><a class="reference external" href="https://github.com/georgeOsdDev">Takeharu Oshida (*)</a></li>
<li><a class="reference external" href="https://github.com/kimkha">Nguyen Kim Kha</a></li>
<li><a class="reference external" href="https://github.com/murz">Michael Murray</a></li>
</ul>
</div>
<span id="document-tutorial"></span><div class="section" id="id1">
<h2>튜토리얼<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p>이 장에서는 Xitrum 프로젝트를 만들고 실행하는데 까지를 간단하게 소개합니다.</p>
<p><strong>이 과정은 Java 가 설치된 Linux 환경을 가정하고 있습니다.</strong></p>
<div class="section" id="xitrum">
<h3>Xitrum 프로젝트 만들기<a class="headerlink" href="#xitrum" title="제목 주소">¶</a></h3>
<p>새 프로젝트를 만들려면
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/archive/master.zip">xitrum-new.zip</a> 를다운로드 합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>wget -O xitrum-new.zip https://github.com/xitrum-framework/xitrum-new/archive/master.zip
</pre></div>
</div>
<p>또는:</p>
<div class="highlight-python"><div class="highlight"><pre>curl -L -o xitrum-new.zip https://github.com/xitrum-framework/xitrum-new/archive/master.zip
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>시작하기<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<p>Scala 빌드 도구로써 사실상 표준인 <a class="reference external" href="https://github.com/harrah/xsbt/wiki/Setup">SBT</a> 를 사용합니다.
방금 다운로드한 프로젝트에는 이미 SBT 0.13 이 <code class="docutils literal"><span class="pre">sbt</span></code> 디렉토리에 포함되어 있습니다.
SBT를 직접설치 하려면 、SBT의  <a class="reference external" href="https://github.com/harrah/xsbt/wiki/Setup">설치가이드</a> 를 참고하세요.</p>
<p>생성한 프로젝트의 루트 디렉토리에 <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">run</span></code> 을 실행하면 Xitrum 이 시작됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>unzip xitrum-new.zip
cd xitrum-new
sbt/sbt run
</pre></div>
</div>
<p>이 명령은 의존 라이브러리( <a class="reference internal" href="index.html#document-deps"><em>dependencies</em></a> )의 다운로드 및 프로젝트 컴파일 후에
<code class="docutils literal"><span class="pre">quickstart.Boot</span></code> 클래스가 실행되고、WEB서버가 시작됩니다.
콘솔에는 다음과 같은 라우팅 정보가 표시됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] Load routes.cache or recollect routes...
[INFO] Normal routes:
GET  /  quickstart.action.SiteIndex
[INFO] SockJS routes:
xitrum/metrics/channel  xitrum.metrics.XitrumMetricsChannel  websocket: true, cookie_needed: false
[INFO] Error routes:
404  quickstart.action.NotFoundError
500  quickstart.action.ServerError
[INFO] Xitrum routes:
GET        /webjars/swagger-ui/2.0.17/index                            xitrum.routing.SwaggerUiVersioned
GET        /xitrum/xitrum.js                                           xitrum.js
GET        /xitrum/metrics/channel                                     xitrum.sockjs.Greeting
GET        /xitrum/metrics/channel/:serverId/:sessionId/eventsource    xitrum.sockjs.EventSourceReceive
GET        /xitrum/metrics/channel/:serverId/:sessionId/htmlfile       xitrum.sockjs.HtmlFileReceive
GET        /xitrum/metrics/channel/:serverId/:sessionId/jsonp          xitrum.sockjs.JsonPPollingReceive
POST       /xitrum/metrics/channel/:serverId/:sessionId/jsonp_send     xitrum.sockjs.JsonPPollingSend
WEBSOCKET  /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocket
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr            xitrum.sockjs.XhrPollingReceive
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr_send       xitrum.sockjs.XhrSend
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr_streaming  xitrum.sockjs.XhrStreamingReceive
GET        /xitrum/metrics/channel/info                                xitrum.sockjs.InfoGET
WEBSOCKET  /xitrum/metrics/channel/websocket                           xitrum.sockjs.RawWebSocket
GET        /xitrum/metrics/viewer                                      xitrum.metrics.XitrumMetricsViewer
GET        /xitrum/metrics/channel/:iframe                             xitrum.sockjs.Iframe
GET        /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocketGET
POST       /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocketPOST
[INFO] HTTP server started on port 8000
[INFO] HTTPS server started on port 4430
[INFO] Xitrum started in development mode
</pre></div>
</div>
<p>처음 실행시에는 、모든 라우팅을 수집하여 로그에 기록합니다.
이 정보는 어플리케이션의 RESTful API에 대한 문서를 작성하는 경우 이 정보는 매우 유용하게 사용될 수 있습니다.</p>
<p>브라우저에서 <a class="reference external" href="http://localhost:8000/">http://localhost:8000</a> 또는 <a class="reference external" href="http://localhost:4430/">https://localhost:4430</a> 에 접근하게 되면.
다음과 같은 요청정보를 확인 할수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] GET quickstart.action.SiteIndex, 1 [ms]
</pre></div>
</div>
</div>
<div class="section" id="eclipse">
<h3>Eclipse 프로젝트로 만들기<a class="headerlink" href="#eclipse" title="제목 주소">¶</a></h3>
<blockquote>
<div><a class="reference external" href="http://scala-ide.org/">Eclipse</a> 개발환경 을 사용하는 경우</div></blockquote>
<p>프로젝트 디렉토리에서 다음 명령을 실행합니다 :</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt eclipse
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">build.sbt</span></code> 에 기재된 프로젝트 설정에 따라 Eclipse용  <code class="docutils literal"><span class="pre">.project</span></code> 파일이 생성됩니다.
Eclipse를 열고 프로젝트를 임포트 합니다.</p>
</div>
<div class="section" id="intellij-idea">
<h3>IntelliJ IDEA프로젝트 만들기<a class="headerlink" href="#intellij-idea" title="제목 주소">¶</a></h3>
<blockquote>
<div><a class="reference external" href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> 개발환경을 사용하는 경우</div></blockquote>
<p>프로젝트 디렉토리에서 다음 명령을 실행합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt gen-idea
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">build.sbt</span></code> 에 기재된 프로젝트 설정에 따라 InteliJ용``.idea`` 파일이 생성됩니.
IntelliJ를 열고 프로젝트를 임포트 합니다.</p>
</div>
<div class="section" id="id6">
<h3>자동 리로드<a class="headerlink" href="#id6" title="제목 주소">¶</a></h3>
<p>프로그램을 다시 시작하지 않고 .class파일을 다시 로드（핫 스왑)할 수 있습니다.
그러나、프로그램의 성능과 안정성을 위하여、자동 리로드는 개발시에만 사용하는것을 권장합니다.</p>
<div class="section" id="ide">
<h4>IDE를 사용하는 경우<a class="headerlink" href="#ide" title="제목 주소">¶</a></h4>
<p>최신의 Eclipse 나 IntelliJ와 같은 IDE를 사용하여 개발하여 시작하는 경우、
기본적으로 IDE가 소스코드의 변경을 감지하고、변경이 있을경우 자동으로 컴파일 해줍니.</p>
</div>
<div class="section" id="id7">
<h4>SBT를 사용하는 경우<a class="headerlink" href="#id7" title="제목 주소">¶</a></h4>
<p>SBT를 사용하는 경우、2가지의 콘솔창을 준비하여야 합니다:</p>
<ul class="simple">
<li>하나는 <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">run</span></code> 을 실행합니다. 이 명령은 프로그램을 실행하여、 .class 파일에 변경이 있을경우 다시 로드합니다.</li>
<li>다른 하나는  <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">~compile</span></code> 를 실행합니다. 다이 명령은 소스 코드의 변경을 감지하여 、변경이 있을경우 .class 파일로 컴파일합니다.</li>
</ul>
<p>sbt디렉토리 <a class="reference external" href="https://github.com/xitrum-framework/agent7">agent7.jar</a> 이 포함되어 있습니다.
이 라이브러리는、현재 디렉토리（및 하위 디렉토리)의 .class 파일 리로드를 담당합니다.
<code class="docutils literal"><span class="pre">sbt/sbt</span></code> 스크립트 중에 <code class="docutils literal"><span class="pre">-javaagent:agent7.jar</span></code> 로 사용되고 있습니다.</p>
</div>
<div class="section" id="dcevm">
<h4>DCEVM<a class="headerlink" href="#dcevm" title="제목 주소">¶</a></h4>
<p>일반JVM은 클래스 파일이 다시 로드 되었을때、메소드의 바디부분만 변경이 반영됩니다.
오픈소스인 <a class="reference external" href="https://github.com/dcevm/dcevm">DCEVM</a> 의 Java HotSpot VM 를 사용하여、
로드된 클래스의 재정의를 보다 유연하게 할 수 있습니다.</p>
<p>DCEVM은 다음의 두가지 방법으로 설치 할 수 있습니:</p>
<ul class="simple">
<li>이미 설치된 Java에  <a class="reference external" href="https://github.com/dcevm/dcevm/releases">Patch</a> 하는 방법</li>
<li><a class="reference external" href="http://dcevm.nentjes.com/">prebuilt</a> 버전설치 (이 쪽이 간단합니다)</li>
</ul>
<p>패치를 사용하여 설치하는 경우:</p>
<ul class="simple">
<li>DCEVM를 항상 활성화 할 수 있습니.</li>
<li>또는 DCEVM 를 &#8220;alternative&#8221; JVM 으로 적용할 수 있습니다.
이 경우、<code class="docutils literal"><span class="pre">java</span></code> 명령에 <code class="docutils literal"><span class="pre">-XXaltjvm=dcevm</span></code> 옵션을 지정하여 DCEVM를 사용할 수 있습니.
예를 들어、 <code class="docutils literal"><span class="pre">sbt/sbt</span></code> 스크립트 파일에 <code class="docutils literal"><span class="pre">-XXaltjvm=dcevm</span></code> 를 추가해야 합니다.</li>
</ul>
<p>Eclipse나 IntelliJ와 같은 IDE를 사용하는 경우 、DCEVM은 프로젝트의 실행 JVM를 지정해야 합니다.</p>
<p>SBT를 사용하는 경우、 <code class="docutils literal"><span class="pre">java</span></code> 명령이 DCEVM를 사용할 수 있도록  <code class="docutils literal"><span class="pre">PATH</span></code> 환경변수를 지정해 줘야 합니다.
DCEVM는 자체 클래스의 변경을 지원하지만、새로고침을 하지 않기 때문에 、DCEVM를 사용하는 경우에도  <code class="docutils literal"><span class="pre">javaagent</span></code> 가 필요합니다.</p>
<p>자세한 내용은 <a class="reference external" href="http://javainformed.blogspot.jp/2014/01/jrebel-free-alternative.html">DCEVM - A JRebel free alternative</a> 를 참고하세요.</p>
</div>
</div>
<div class="section" id="id9">
<h3>무시되는 파일들<a class="headerlink" href="#id9" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="index.html#document-tutorial"><em>튜토리얼</em></a> 에 따라 프로젝트를 만든경우 <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/.gitignore">ignored</a> 를 참고 하여 ignore 파일을 작성하세요.</p>
<div class="highlight-python"><div class="highlight"><pre>.*
log
project/project
project/target
target
tmp
</pre></div>
</div>
</div>
</div>
<span id="document-action_view"></span><div class="section" id="action-view">
<h2>Action 과 view<a class="headerlink" href="#action-view" title="제목 주소">¶</a></h2>
<p>유연함을 위해, Xitrum은 3가지 형태의 Action을 제공합니다.
보통``Action``、<code class="docutils literal"><span class="pre">FutureAction</span></code>、그리고``ActorAction``입니다.</p>
<div class="section" id="normal-action">
<h3>Normal Action<a class="headerlink" href="#normal-action" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends Action {
  def execute() {
    respondText(&quot;Hello&quot;)
  }
}
</pre></div>
</div>
<p>요청은 Netty의 IO스레드로 직접로 처리되므로、시간이 걸리는 처리（블록처리）를 포함하면 안됩니다.
Netty 의 IO쓰레드 를 오래 사용하게 되면 Netty는 새로운 연결을 할 수 없거나 응답을 회신할 수 없게 되기 때문입니다.</p>
</div>
<div class="section" id="futureaction">
<h3>FutureAction<a class="headerlink" href="#futureaction" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.FutureAction
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends FutureAction {
  def execute() {
    respondText(&quot;hi&quot;)
  }
}
</pre></div>
</div>
<p>요청은 Netty의 스레드 풀과는 별개로 다음의``ActorAction`` 과 같은 스레드 풀에서 처리됩니다.</p>
</div>
<div class="section" id="actor-action">
<h3>Actor Action<a class="headerlink" href="#actor-action" title="제목 주소">¶</a></h3>
<p>Action 을 Akka actor 처럼 정의하려면 、<a href="#id1"><span class="problematic" id="id2">``</span></a>ActorAction``을 상속하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.concurrent.duration._

import xitrum.ActorAction
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends ActorAction {
  def execute() {
    // See Akka doc about scheduler
    import context.dispatcher
    context.system.scheduler.scheduleOnce(3 seconds, self, System.currentTimeMillis())

    // See Akka doc about &quot;become&quot;
    context.become {
      case pastTime =&gt;
        respondInlineView(s&quot;It&#39;s $pastTime Unix ms 3s ago.&quot;)
    }
  }
}
</pre></div>
</div>
<p>Actor 인스턴스는 요청이 발생할때 생성됩니다. 이 actor 인스턴스는 연결이 끊어지거나、
<code class="docutils literal"><span class="pre">respondText</span></code>, <a href="#id3"><span class="problematic" id="id4">``</span></a>respondView``등의 메소드를 통해 응답을 얻을때 중지됩니다.
청크응답의 경우 즉시 중지되지 않고、마지막 청크가 전송된 시점에서 중지됩니다.</p>
<p>요청은 &#8220;xitrum&#8221; 이라고 불리는 Akka actor 시스템 스레드 풀에서 처리됩니다.</p>
</div>
<div class="section" id="id5">
<h3>클라이언트로의 전송<a class="headerlink" href="#id5" title="제목 주소">¶</a></h3>
<p>Action으로 부터 클라이언트로 응답을 전송하려면 다음과 같은 방법을 사용합니다</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondView</span></code>: 레이아웃을 포함하거나 포함하지 않고、View 템플릿을 전송합니다</li>
<li><code class="docutils literal"><span class="pre">respondInlineView</span></code>: 레이아웃을 포함하거나 포함하지 않고、인라인으로 작성된 템플릿을 전송합니다</li>
<li><code class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></code>: 레이아웃 파일을 사용하지 않고 문자열을 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></code>: contentType 을 &#8220;text/html&#8221; 형식으로 문자열을 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>: Scala 객체를 JSON 으로 변환하여、contentType 을 &#8220;application/json&#8221; 형식으로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></code> contentType 을 &#8220;application/javascript&#8221; 으로 문자열을 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></code>: 위 두가지를 조합하여 JSONP로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></code>: contentType 을 &#8220;application/javascript&#8221; 으로 문자열을 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></code>: <cite>respondJs</cite> 、 <cite>respondJsonText</cite> 의 두가지 조합을 JSONP로 보냅니</li>
<li><code class="docutils literal"><span class="pre">respondBinary</span></code>: 바이트 배열로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondFile</span></code>: 디스크에서 파일을 직접보냅니다. <a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a> 를 사용하기 때문에 매우 빠릅니다.</li>
<li><code class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></code>: 청크응답을 보냅니다</li>
</ul>
</div>
<div class="section" id="view">
<h3>템플릿 View 파일 응답<a class="headerlink" href="#view" title="제목 주소">¶</a></h3>
<p>모든 Action은  <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a> 의 템플릿 View 파일과 연관이 있습니다.
위의 응답방식을 사용하여 직접 응답을 보내는 대신 별도의 View파일을 사용하여 응답을 보낼 수 있습니다.</p>
<p>scr/main/scala/mypackage/MyAction.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends Action {
  def execute() {
    respondView()
  }

  def hello(what: String) = &quot;Hello %s&quot;.format(what)
}
</pre></div>
</div>
<p>scr/main/scalate/mypackage/MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage.MyAction

!!! 5
html
  head
    != antiCsrfMeta
    != xitrumCss
    != jsDefaults
    title Welcome to Xitrum

  body
    a(href={url}) Path to the current action
    p= currentAction.asInstanceOf[MyAction].hello(&quot;World&quot;)

    != jsForView
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xitrumCss</span></code> Xitrum 의 기본 CSS파일입니다.삭제해도 무방합니다.</li>
<li><code class="docutils literal"><span class="pre">jsDefaults</span></code> jQuery, jQuery Validate plugin등을 포함하고 있습니다.&lt;head&gt;안에 명시해야 합니다.</li>
<li><code class="docutils literal"><span class="pre">jsForView</span></code> <code class="docutils literal"><span class="pre">jsAddToView</span></code> 에 의해 추가된 javascript가 출력됩니다.레이아웃의 끝에 명시해야 합니다.</li>
</ul>
<p>템플릿 파일에서 <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Action.scala">xitrum.Action</a> 클래스의 모든 파일을 사용할 수 있습니다.
또한、<code class="docutils literal"><span class="pre">unescape</span></code> 같은 Scalate 유틸리티도 사용할 수 있습니다.Scalate 의 유틸리티는 <a class="reference external" href="http://scalate.fusesource.org/documentation/index.html">Scalate doc</a>　를 참고하세요.</p>
<p>Scalate 템플릿의 기본 유형은 <a class="reference external" href="http://scalate.fusesource.org/documentation/jade.html">Jade</a> 를 사용하고 있습니다.
또한 <a class="reference external" href="http://scalate.fusesource.org/documentation/mustache.html">Mustache</a> 、
<a class="reference external" href="http://scalate.fusesource.org/documentation/scaml-reference.html">Scaml</a> 、
<a class="reference external" href="http://scalate.fusesource.org/documentation/ssp-reference.html">Ssp</a> 를 선택할 수 있습니다.
템플릿의 기본 유형을 、어플리케이션의 config 디렉토리내의 <a href="#id6"><span class="problematic" id="id7">`</span></a>xitrum.conf`에서 설정할 수 있습니다.</p>
<p><cite>respondView</cite> 메소드의 type 매개변수로 &#8220;jade&#8221;、 &#8220;mustache&#8221;、&#8221;scaml&#8221;、&#8221;ssp&#8221; 중 하나를 지정하여 기본 템플릿 유형을 무시하고 사용할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>val options = Map(&quot;type&quot; -&gt;&quot;mustache&quot;)
respondView(options)
</pre></div>
</div>
<div class="section" id="currentaction">
<h4>currentAction의 캐스팅<a class="headerlink" href="#currentaction" title="제목 주소">¶</a></h4>
<p>지금의 Action의 인스턴스를 정확하게 지정하려면 、<code class="docutils literal"><span class="pre">currentAction</span></code> 를 지정한 Action 캐스팅합니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span><span class="o">=</span> <span class="n">currentAction</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="p">[</span><span class="n">MyAction</span><span class="p">]</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>여러줄로 사용하는 경우 、캐스트 처리를 한번만 호출합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>- val myAction = currentAction.asInstanceOf[MyAction]; import myAction._

p= hello(&quot;World&quot;)
p= hello(&quot;Scala&quot;)
p= hello(&quot;Xitrum&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>Mustache<a class="headerlink" href="#id8" title="제목 주소">¶</a></h4>
<p>Mustache에 대한 참고자료:</p>
<ul class="simple">
<li><a class="reference external" href="http://mustache.github.com/mustache.5.html">Mustache syntax</a></li>
<li><a class="reference external" href="http://scalate.fusesource.org/documentation/mustache.html">Scalate implementation</a></li>
</ul>
<p>Mustach는 구문위반에 강력해서、Jade 에서 할 수 있는 작업중 일부는 사용할 수 없습니다.</p>
<p>Action 에서 뭔가 값을 전달할 경우 、<code class="docutils literal"><span class="pre">at</span></code> 메소드를 사용합니다.</p>
<p>Action:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">at</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;Jack&quot;</span>
<span class="n">at</span><span class="p">(</span><span class="s">&quot;xitrumCss&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">xitrumCss</span>
</pre></div>
</div>
<p>Mustache template:</p>
<div class="highlight-python"><div class="highlight"><pre>My name is {{name}}
{{xitrumCss}}
</pre></div>
</div>
<p>주의:다음키는 예약어 이므로、 <code class="docutils literal"><span class="pre">at</span></code> 메소드를 통해 Scalate 템플릿에 전달할 수 없습니다.</p>
<ul class="simple">
<li>&#8220;context&#8221;: <code class="docutils literal"><span class="pre">unescape</span></code> 등의 메소드를 포함하여 Scalate 객체</li>
<li>&#8220;helper&#8221;: 현재 Action 객체</li>
</ul>
</div>
<div class="section" id="coffeescript">
<h4>CoffeeScript<a class="headerlink" href="#coffeescript" title="제목 주소">¶</a></h4>
<p><a class="reference external" href="http://scalate.fusesource.org/documentation/jade-syntax.html#filters">:coffeescript filter</a> 를 사용하여
CoffeeScript템플릿에 배포 할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>body
  :coffeescript
    alert &quot;Hello, Coffee!&quot;
</pre></div>
</div>
<p>출력결과:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;body&gt;
  &lt;script type=&#39;text/javascript&#39;&gt;
    //&lt;![CDATA[
      (function() {
        alert(&quot;Hello, Coffee!&quot;);
      }).call(this);
    //]]&gt;
  &lt;/script&gt;
&lt;/body&gt;
</pre></div>
</div>
<p>주의: 그러나 이 작업은 <a class="reference external" href="http://groups.google.com/group/xitrum-framework/browse_thread/thread/6667a7608f0dc9c7">slow</a> 문제가 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>jade+javascript+1thread: 1-2ms for page
jade+coffesscript+1thread: 40-70ms for page
jade+javascript+100threads: ~40ms for page
jade+coffesscript+100threads: 400-700ms for page
</pre></div>
</div>
<p>빠른속도로 동작시키기 위해서는 미리 CoffeeScript에서 Javascript를 생성해야 합니다.</p>
</div>
</div>
<div class="section" id="id9">
<h3>레이아웃<a class="headerlink" href="#id9" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">respondView</span></code> 또 <code class="docutils literal"><span class="pre">respondInlineView</span></code> 를 사용하여 View를 보낸경우
Xitrum은 결과 문자열을 、<code class="docutils literal"><span class="pre">renderedView</span></code> 변수로 설정합니다.
그리고 현재 Action의 <code class="docutils literal"><span class="pre">layout</span></code> 메소드가 실행됩니다.
브라우저에 전송되는 데이터는 결국 이 메소드의 결과가 표시됩니다.</p>
<p>기본적으로、<code class="docutils literal"><span class="pre">layout</span></code> 메소드는 단지 <code class="docutils literal"><span class="pre">renderedView</span></code> 를 호출합니다.
만약、이 처리방법에 무언가를 추가하려면 、재정의가 필요합니다.만약 、 <code class="docutils literal"><span class="pre">renderedView</span></code> 메소드에 포함하려는 경우、
이 View의 레이아웃의 일부로 포함됩니다.</p>
<p>포인트는  <code class="docutils literal"><span class="pre">layout</span></code> 현재의 Action View가 실행된 후라는 것입니다.
거기에서 반환되는 값이 브라우저에 전달이 되는것 입니다.</p>
<p>이 메커니즘은 매우 간단하고 마법이 없습니다.간단하게 Xitrum 에는 레이아웃이 존재하지 않는다고 생각할 수 있습니다.
거기에는 단지 <code class="docutils literal"><span class="pre">layout</span></code> 메소드가 있을뿐、모두 이 방법으로 표현할 수 있습니다.</p>
<p>전형적인 예로、로일반적인 레이아웃을 부모 클래스로 사용하는 패턴을 보여줍니다.</p>
<p>src/main/scala/mypackage/AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage
import xitrum.Action

trait AppAction extends Action {
  override def layout = renderViewNoLayout[AppAction]()
}
</pre></div>
</div>
<p>src/main/scalate/mypackage/AppAction.jade</p>
<div class="highlight-python"><div class="highlight"><pre>!!! 5
html
  head
    != antiCsrfMeta
    != xitrumCss
    != jsDefaults
    title Welcome to Xitrum

  body
    != renderedView
    != jsForView
</pre></div>
</div>
<p>src/main/scala/mypackage/MyAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends AppAction {
  def execute() {
    respondView()
  }

  def hello(what: String) = &quot;Hello %s&quot;.format(what)
}
</pre></div>
</div>
<p>scr/main/scalate/mypackage/MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage.MyAction

a(href={url}) Path to the current action
p= currentAction.asInstanceOf[MyAction].hello(&quot;World&quot;)
</pre></div>
</div>
<div class="section" id="id10">
<h4>독립적인 레이아웃 파일을 사용하지 않는 패턴<a class="headerlink" href="#id10" title="제목 주소">¶</a></h4>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="respondview">
<h4>respondView 레이아웃을 직접 패스<a class="headerlink" href="#respondview" title="제목 주소">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>val specialLayout = () =&gt;
  DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )

respondView(specialLayout _)
</pre></div>
</div>
</div>
</div>
<div class="section" id="inline-view">
<h3>Inline view<a class="headerlink" href="#inline-view" title="제목 주소">¶</a></h3>
<p>일반적인 Scalate 파일에 포함되지만 、직접Action에 표기할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends Action {
  def execute() {
    val s = &quot;World&quot;  // Will be automatically HTML-escaped
    respondInlineView(
      &lt;p&gt;Hello &lt;em&gt;{s}&lt;/em&gt;!&lt;/p&gt;
    )
  }
}
</pre></div>
</div>
</div>
<div class="section" id="render-fragment">
<h3>Render fragment<a class="headerlink" href="#render-fragment" title="제목 주소">¶</a></h3>
<p>MyAction.jade가
<code class="docutils literal"><span class="pre">scr/main/scalate/mypackage/MyAction.jade</span></code>
에 있는경우 :
같은 디렉토리에 있는 조각파일을 반환하는 경우:
<code class="docutils literal"><span class="pre">scr/main/scalate/mypackage/_MyFragment.jade</span></code></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">renderFragment</span><span class="p">[</span><span class="n">MyAction</span><span class="p">](</span><span class="s">&quot;MyFragment&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>현재 Action이 <a href="#id11"><span class="problematic" id="id12">``</span></a>MyAction``의 경우, 다음과 같이 생략이 가능합니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">renderFragment</span><span class="p">(</span><span class="s">&quot;MyFragment&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3>다른 Action의 View를 응답하는 경우<a class="headerlink" href="#id13" title="제목 주소">¶</a></h3>
<p>다음의 메소드를 사용합니다 <code class="docutils literal"><span class="pre">respondView[ClassName]()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.{GET, POST}

@GET(&quot;login&quot;)
class LoginFormAction extends Action {
  def execute() {
    // Respond scr/main/scalate/mypackage/LoginFormAction.jade
    respondView()
  }
}

@POST(&quot;login&quot;)
class DoLoginAction extends Action {
  def execute() {
    val authenticated = ...
    if (authenticated)
      redirectTo[HomeAction]()
    else
      // Reuse the view of LoginFormAction
      respondView[LoginFormAction]()
  }
}
</pre></div>
</div>
<div class="section" id="id14">
<h4>하나의 Action - 여러 View사용<a class="headerlink" href="#id14" title="제목 주소">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.GET

// These are non-routed actions, for mapping to view template files:
// scr/main/scalate/mypackage/HomeAction_NormalUser.jade
// scr/main/scalate/mypackage/HomeAction_Moderator.jade
// scr/main/scalate/mypackage/HomeAction_Admin.jade
trait HomeAction_NormalUser extends Action
trait HomeAction_Moderator  extends Action
trait HomeAction_Admin      extends Action

@GET(&quot;&quot;)
class HomeAction extends Action {
  def execute() {
    val userType = ...
    userType match {
      case NormalUser =&gt; respondView[HomeAction_NormalUser]()
      case Moderator  =&gt; respondView[HomeAction_Moderator]()
      case Admin      =&gt; respondView[HomeAction_Admin]()
    }
  }
}
</pre></div>
</div>
<p>위와 같이 라우팅과 상관없는 작업을 설명하는것이 어려워 보일수는 있지만
이 방법은 프로그램이 형식에 대해 안정성을 유지할 수 있습니다.</p>
<p><code class="docutils literal"><span class="pre">String</span></code> 값을 이용하여 템블릿 위치를 지정할 수도 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_NormalUser&quot;</span><span class="p">)</span>
<span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_Moderator&quot;</span><span class="p">)</span>
<span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_Admin&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="component">
<h3>Component<a class="headerlink" href="#component" title="제목 주소">¶</a></h3>
<p>여러 View에 통합 할 수 있는 재사용이 가능한 구성요소를 생성 수 있습니다.
구성 요소의 개념은 액션과 매우 비슷합니다.
다음과 같은 특징이 있습니다.</p>
<ul class="simple">
<li>구성요소는 루트가 없습니다.즉, <code class="docutils literal"><span class="pre">execute</span></code> 메소드는 필요가 없습니다.</li>
<li>구성요소는 전체 응답을 반환하지 않습니다. 단편적인 view를 &#8220;render&#8221; 하기만 합니다.
따라서、구성요소 내부에서 <code class="docutils literal"><span class="pre">respondXXX</span></code> 대신 <code class="docutils literal"><span class="pre">renderXXX</span></code> 호출해야 합니다.</li>
<li>Action처럼、구성요소는 단일 혹은 여러 View와 연관이 있거나、또는 연관성없이 사용할 수 있습니다.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.{FutureAction, Component}
import xitrum.annotation.GET

class CompoWithView extends Component {
  def render() = {
    // Render associated view template, e.g. CompoWithView.jade
    // Note that this is renderView, not respondView!
    renderView()
  }
}

class CompoWithoutView extends Component {
  def render() = {
    &quot;Hello World&quot;
  }
}

@GET(&quot;foo/bar&quot;)
class MyAction extends FutureAction {
  def execute() {
    respondView()
  }
}
</pre></div>
</div>
<p>MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage._

!= newComponent[CompoWithView]().render()
!= newComponent[CompoWithoutView]().render()
</pre></div>
</div>
</div>
</div>
<span id="document-restful"></span><div class="section" id="restful-apis">
<h2>RESTful APIs<a class="headerlink" href="#restful-apis" title="제목 주소">¶</a></h2>
<p>XitrumiPhone、Android 등의 어플리케이션을 위한 RESTful APIs를 간단하게 만들수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;articles&quot;)
class ArticlesIndex extends Action {
  def execute() {...}
}

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends Action {
  def execute() {...}다
}
</pre></div>
</div>
<p>POST、 PUT、 PATCH、 DELETE 그리고 OPTIONS 뿐만 아니라
Xitrum은 HEAD의 GET 요청를 빈 바디응답으로 자동으로 처리합니다.</p>
<p>일반 브라우저 처럼 PUT과 DELETE를 지원하지 않는 HTTP 클라이언트 에서도、
PUT과 DELETE를 구현하려면 、응답 본문에  <code class="docutils literal"><span class="pre">_method=put</span></code> 또、 <code class="docutils literal"><span class="pre">_method=delete</span></code> 를 포함하여
사용할 수 있습니다.</p>
<p>어플리케이션을 시작할때 Xitrum 어플리케이션을 스캔하여、라우팅 테이블을 만들고 출력합니다.
다음과 같은 로그에서 어플리케이션이 어떤 API를 지원하고 있는지 알 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] Routes:
GET /articles     quickstart.action.ArticlesIndex
GET /articles/:id quickstart.action.ArticlesShow
</pre></div>
</div>
<p>라우팅은 JAX-RS과 Rails의 철학에 따라 자동으로 수집됩니다.
모든 경로를 한군데에 설정할 필요가 없습니다.
분산 라우팅 처럼.이 기능덕분에 어플리케이션을 다른 어플리케이션에 통합할 수 있습니.
만약 블로그 엔진을 만든다면 패키징된 JAR파일을 다른 어플리케이션으로 가져와서 즉시 블로그 기능을 사용할 수 있습니다.
라우팅에는 두가지 특징이 있습니다.
안전한 방법으로 루트를 재 생성하거나（리버스 라우팅、
<a class="reference external" href="http://swagger.wordnik.com/">Swagger Doc</a> 이라고 하는 문서를 통해서 만듨 수 있습니다.</p>
<div class="section" id="id1">
<h3>루트 캐싱<a class="headerlink" href="#id1" title="제목 주소">¶</a></h3>
<p>어플리케이션 시작시 속도 향상을 위해、루트는 <code class="docutils literal"><span class="pre">routes.cache</span></code> 파일에 캐쉬 됩니다.
개발시에는 <code class="docutils literal"><span class="pre">target</span></code> 파일에 있는 클래스 파일의 루트는 캐쉬 되지 않습니다.
만약 루트를 포함하여 라이브러리가 업데이트 된 경、 <code class="docutils literal"><span class="pre">routes.cache</span></code> 파일을 삭제하세요.
또한、이 파일은 소스 저장소에 커밋되지 않도록 주의해야 합니다.</p>
</div>
<div class="section" id="firstlast">
<h3>루트의 우선순위(first、last)<a class="headerlink" href="#firstlast" title="제목 주소">¶</a></h3>
<p>다음과 같은 루트를 만든경우</p>
<div class="highlight-python"><div class="highlight"><pre>/articles/:id --&gt; ArticlesShow
/articles/new --&gt; ArticlesNew
</pre></div>
</div>
<p>두번째 루트를 우선시 할경우 <code class="docutils literal"><span class="pre">&#64;First</span></code> 주석을 추가시킵니.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.{GET, First}

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends Action {
  def execute() {...}
}

@First  // This route has higher priority than &quot;ArticlesShow&quot; above
@GET(&quot;articles/new&quot;)
class ArticlesNew extends Action {
  def execute() {...}
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Last</span></code> 도 똑같이 사용할 수 있습니.</p>
</div>
<div class="section" id="action">
<h3>Action에 여러 경로를 연동<a class="headerlink" href="#action" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;image&quot;, &quot;image/:format&quot;)
class Image extends Action {
  def execute() {
    val format = paramo(&quot;format&quot;).getOrElse(&quot;png&quot;)
    // ...
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>점을 포함하는 루트<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;, &quot;articles/:id.:format&quot;)
class ArticlesShow extends Action {
  def execute() {
    val id     = param[Int](&quot;id&quot;)
    val format = paramo(&quot;format&quot;).getOrElse(&quot;html&quot;)
    // ...
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>정규 표현식을 이용한 라우팅<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>정규 표현식을 이용하여 라우팅 할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">GET</span><span class="p">(</span><span class="s">&quot;articles/:id&lt;[0-9]+&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>경로의 나머지 부분 이용<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">/</span></code> 문자는 특수문자라서 매개변수에 포함되지 않습니.``/`` 문자를 사용하려면 다음과 같이 씁니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">GET</span><span class="p">(</span><span class="s">&quot;service/:id/proxy/:*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>다음의 경로를 가져오게 됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>/service/123/proxy/http://foo.com/bar
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">:*</span></code> 를 가져오게 됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>val url = param(&quot;*&quot;)  // &quot;http://foo.com/bar&quot; 입니다
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>액션에 링크추가<a class="headerlink" href="#id5" title="제목 주소">¶</a></h3>
<p>Xitrum은 typesafe 하기때문에, URL을 직접 사용하면 안됩니다. 다음처럼 사용하세:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href={url[ArticlesShow](&quot;id&quot; -&gt; myArticle.id)}&gt;{myArticle.title}&lt;/a&gt;
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>다른 액션으로 리디랙션<a class="headerlink" href="#id6" title="제목 주소">¶</a></h3>
<p>참고 <a class="reference external" href="http://en.wikipedia.org/wiki/URL_redirection">what redirection is</a>.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{GET, POST}

@GET(&quot;login&quot;)
class LoginInput extends Action {
  def execute() {...}
}

@POST(&quot;login&quot;)
class DoLogin extends Action {
  def execute() {
    ...
    // After login success
    redirectTo[AdminIndex]()
  }
}

GET(&quot;admin&quot;)
class AdminIndex extends Action {
  def execute() {
    ...
    // Check if the user has not logged in, redirect him to the login page
    redirectTo[LoginInput]()
  }
}
</pre></div>
</div>
<p>현재 액션을 다음을 이용하여 변경할 수도 있습니다. <code class="docutils literal"><span class="pre">redirecToThis()</span></code>.</p>
</div>
<div class="section" id="id7">
<h3>다른 액션에 요청 전달<a class="headerlink" href="#id7" title="제목 주소">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">forwardTo[AnotherAction]()</span></code> 사용시에는  <code class="docutils literal"><span class="pre">redirectTo</span></code> 은 다른 요청을 만들어서 전달하지만</dt>
<dd><code class="docutils literal"><span class="pre">forwardTo</span></code> 는 요청이 유지됩니다.</dd>
</dl>
</div>
<div class="section" id="ajax">
<h3>Ajax 요청의 결정<a class="headerlink" href="#ajax" title="제목 주소">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">isAjax</span></code> 을 사용합니다.</div></blockquote>
<div class="highlight-python"><div class="highlight"><pre>// In an action
val msg = &quot;A message&quot;
if (isAjax)
  jsRender(&quot;alert(&quot; + jsEscape(msg) + &quot;)&quot;)
else
  respondText(msg)
</pre></div>
</div>
</div>
<div class="section" id="anti-csrf">
<h3>Anti-CSRF<a class="headerlink" href="#anti-csrf" title="제목 주소">¶</a></h3>
<p>GET 이외의 요청에 、Xitrum은 기본적으로 <a class="reference external" href="http://en.wikipedia.org/wiki/CSRF">Cross-site request forgery</a> 방식을 고수합니다.</p>
<p><code class="docutils literal"><span class="pre">antiCsrfMeta</span></code> Tags 의 레이아웃에 명시한경우:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
<p>출력되는 <code class="docutils literal"><span class="pre">&lt;head&gt;</span></code> 는 다음과 같습니다:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    ...
    &lt;meta name=&quot;csrf-token&quot; content=&quot;5402330e-9916-40d8-a3f4-16b271d583be&quot; /&gt;
    ...
  &lt;/head&gt;
  ...
&lt;/html&gt;
</pre></div>
</div>
<dl class="docutils">
<dt><a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a> 이 템플릿 내에서 사용되는 경우、</dt>
<dd>토큰은 GET 요청을 제외한 모든 jQuery 의 Ajax 요청에 <code class="docutils literal"><span class="pre">X-CSRF-Token</span></code> 을 포함합니다.</dd>
</dl>
<p>xitrum.js은  <code class="docutils literal"><span class="pre">jsDefaults</span></code> 에 포함되어 있습니다.
만약 <code class="docutils literal"><span class="pre">jsDefaults</span></code> 를 사용하지 않고 xitrum.js를 사용하고 싶다면 다음과 같이 사용합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script type=&quot;text/javascript&quot; src={url[xitrum.js]}&gt;&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="anticsrfinput-anticsrftoken">
<h3>antiCsrfInput 와 antiCsrfToken<a class="headerlink" href="#anticsrfinput-anticsrftoken" title="제목 주소">¶</a></h3>
<p>Xitrum은 CSRF토큰을  <code class="docutils literal"><span class="pre">X-CSRF-Token</span></code> 의 요청헤더 에서 가져옵니다.
만약 요청헤더가 없다면 <code class="docutils literal"><span class="pre">csrf-token</span></code> 의 바디 파라미터에서 가져옵니다.
（URL의 파라미터가 아닙니다.）</p>
<p>Form을 직접작성할때, 메타 태그와 xitrum.js을 사용하지 않는다면、<code class="docutils literal"><span class="pre">antiCsrfInput</span></code> 또는
<code class="docutils literal"><span class="pre">antiCsrfToken</span></code> 을 사용해야 합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[AdminAddGroup]})
  != antiCsrfInput
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[AdminAddGroup]})
  input(type=&quot;hidden&quot; name=&quot;csrf-token&quot; value={antiCsrfToken})
</pre></div>
</div>
</div>
<div class="section" id="csrf">
<h3>CSRF 체크 생략<a class="headerlink" href="#csrf" title="제목 주소">¶</a></h3>
<p>스마트폰과 같은 기기를 위해서 API 를 작성할 경우 CSRF체크를 생략할 수 있습니다、
<code class="docutils literal"><span class="pre">xitrum.SkipCsrfCheck</span></code> 를 Action에 추가하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SkipCsrfCheck}
import xitrum.annotation.POST

trait Api extends Action with SkipCsrfCheck

@POST(&quot;api/positions&quot;)
class LogPositionAPI extends Api {
  def execute() {...}
}

@POST(&quot;api/todos&quot;)
class CreateTodoAPI extends Api {
  def execute() {...}
}
</pre></div>
</div>
</div>
<div class="section" id="manipulate-collected-routes">
<h3>Manipulate collected routes<a class="headerlink" href="#manipulate-collected-routes" title="제목 주소">¶</a></h3>
<p>Xitrum 은 시작시에 자동으로 경로를 수집합니다.
경로를 수정하고 싶다면, 다음을 이용하세요
<a class="reference external" href="http://xitrum-framework.github.io/api/3.17/index.html#xitrum.routing.RouteCollection">xitrum.Config.routes</a>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Config, Server}

object Boot {
  def main(args: Array[String]) {
    // You can modify routes before starting the server
    val routes = Config.routes

    // Remove routes to an action by its class
    routes.removeByClass[MyClass]()

    if (demoVersion) {
      // Remove routes to actions by a prefix
      routes.removeByPrefix(&quot;premium/features&quot;)

      // This also works
      routes.removeByPrefix(&quot;/premium/features&quot;)
    }

    ...

    Server.start()
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>요청 내용 가져오기<a class="headerlink" href="#id8" title="제목 주소">¶</a></h3>
<p>요청에 대한 타입이 <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code> 이 아닐경우 、
요청에 대한 내용을 가져오고 수동으로 파싱이 가능합니다.</p>
<p>문자열로 가져오기:</p>
<div class="highlight-python"><div class="highlight"><pre>val body = requestContentString
</pre></div>
</div>
<p>문자열로 가져와서 、JSON형식으로 변경합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>val myJValue = requestContentJValue  // =&gt; JSON4S (http://json4s.org) JValue
val myMap = requestContentJson[Map[String, Int]]
</pre></div>
</div>
<p>요청 전체를 컨트롤 하려면、 <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/FullHttpRequest.html">request.getContent</a> 을 사용하면 됩니다
<a class="reference external" href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html">ByteBuf</a> 타입으로 리턴합니다.</p>
</div>
<div class="section" id="swagger-api">
<h3>Swagger로 API 문서화 하기<a class="headerlink" href="#swagger-api" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="https://developers.helloreverb.com/swagger/">Swagger</a> 를 이용하여 API문서를 만들수 있습니다.
<code class="docutils literal"><span class="pre">&#64;Swagger</span></code> 태크를 문서화 하고 싶은 API에 명시하면 됩니다.
Xitrum은 문서파일을 <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/API-Declaration">/xitrum/swagger.json</a> 에 생성합니다.
이 파일들은 <a class="reference external" href="https://github.com/wordnik/swagger-ui">Swagger UI</a> 를 이용하여 인터렉티브한 API문서를 생성합니다.
Xitrum은Swagger UI 를 내포하고 있으며、 <code class="docutils literal"><span class="pre">/xitrum/swagger-ui</span></code> 에서 확인할 수 있습니다.
: <a class="reference external" href="http://localhost:8000/xitrum/swagger-ui">http://localhost:8000/xitrum/swagger-ui</a>.</p>
<img alt="_images/swagger.png" src="_images/swagger.png" />
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum-placeholder">예제</a> 는 여기에 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SkipCsrfCheck}
import xitrum.annotation.{GET, Swagger}

@Swagger(
  Swagger.Tags(&quot;image&quot;, &quot;APIs to create images&quot;),
  Swagger.Description(&quot;Dimensions should not be bigger than 2000 x 2000&quot;),
  Swagger.OptStringQuery(&quot;text&quot;, &quot;Text to render on the image, default: Placeholder&quot;),
  Swagger.Produces(&quot;image/png&quot;),
  Swagger.Response(200, &quot;PNG image&quot;),
  Swagger.Response(400, &quot;Width or height is invalid or too big&quot;)
)
trait ImageApi extends Action with SkipCsrfCheck {
  lazy val text = paramo(&quot;text&quot;).getOrElse(&quot;Placeholder&quot;)
}

@GET(&quot;image/:width/:height&quot;)
@Swagger(  // &lt;-- Inherits other info from ImageApi
  Swagger.Summary(&quot;Generate rectangle image&quot;),
  Swagger.IntPath(&quot;width&quot;),
  Swagger.IntPath(&quot;height&quot;)
)
class RectImageApi extends Api {
  def execute {
    val width  = param[Int](&quot;width&quot;)
    val height = param[Int](&quot;height&quot;)
    // ...
  }
}

@GET(&quot;image/:width&quot;)
@Swagger(  // &lt;-- Inherits other info from ImageApi
  Swagger.Summary(&quot;Generate square image&quot;),
  Swagger.IntPath(&quot;width&quot;)
)
class SquareImageApi extends Api {
  def execute {
    val width  = param[Int](&quot;width&quot;)
    // ...
  }
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">/xitrum/swagger</span></code> 에 접근할때
<a class="reference external" href="https://github.com/wordnik/swagger-spec/blob/master/versions/1.2.md">JSON For Swagger</a>
가 생성됩니다.</p>
<p>Swagger UI는 이 JSON 정보를 바탕으로 인터랙티브한 API 문서를 만듭니다.</p>
<p>여기에 있는 Swagger.IntPath、Swagger.OptStringQuery이 외에도、BytePath, IntQuery, OptStringForm 등이
form에 명시되어 있습니다.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;Value</span> <span class="pre">type&gt;&lt;Param</span> <span class="pre">type&gt;</span></code> (필수 값)</li>
<li><code class="docutils literal"><span class="pre">Opt&lt;Value</span> <span class="pre">type&gt;&lt;Param</span> <span class="pre">type&gt;</span></code> (옵션 값)</li>
</ul>
<p>Value type: Byte, Int, Int32, Int64, Long, Number, Float, Double, String, Boolean, Date, DateTime</p>
<p>Param type: Path, Query, Body, Header, Form</p>
<p>자세한 내용은 <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/Datatypes">value type</a> 、
<a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/Parameters">param type</a> 를 참고하세요.</p>
</div>
</div>
<span id="document-template_engines"></span><div class="section" id="id1">
<h2>템플릿 엔진<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="index.html#document-action_view"><em>renderView 이나 renderFragment, respondView</em></a> 이 호출되면
설정된 템플릿 엔진이 호출됩니다.</p>
<div class="section" id="id2">
<h3>템플릿 엔진 설정<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a> 에서 템플릿 엔진은 그 형식에 따라서 다음과 같이 두 종류로 설정이 가능합니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">template</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">template</span><span class="o">.</span><span class="n">EngineClassName</span>
</pre></div>
</div>
<p>또는:</p>
<div class="highlight-python"><div class="highlight"><pre>template {
  &quot;my.template.EngineClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>기본 템플릿 엔진은 <a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a> 입니다.</p>
</div>
<div class="section" id="id3">
<h3>템플릿 엔진 제거<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>단지 RESTful API만을 만들경우、renderView、renderFragment、respondView를 호출 할 필요가 없습니.이 경우 템플릿 엔진을 프로젝트에서 삭제해서 프로젝트를 더 가볍게 만들 수 있습니다.
방법은 config/xitrum.conf 에서 <code class="docutils literal"><span class="pre">templateEngine</span></code> 을 지우거나 주석처리 하세요.</p>
</div>
<div class="section" id="id4">
<h3>템플릿 엔진 만들기<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<p>나민의 템플릿 엔진을 만들려、 <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/view/TemplateEngine.scala">xitrum.view.TemplateEngine</a> 을 상속받아 클라스를 만들고.
그러고 나서 config/xitrum.conf 에 명시하면 됩니다.</p>
<p>예제: <a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a></p>
</div>
</div>
<span id="document-postback"></span><div class="section" id="id1">
<h2>포스트백<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p>Web어플리케이션은 다음과 같은 두가지 경우로 많이 사용됩니다.</p>
<ul class="simple">
<li>서버를 위해 사용하는 경우: 스마트폰을 위한 RESTful API를 만들거나, 다른 웹사이트를 위한 웹서비</li>
<li>사람을 위해 사용하는 경우: 인터랙티브한 웹 서비스</li>
</ul>
<p>Web 프레임워크를 기반으로 Xitrum은 이 두가지를 쉽게 사용할 수 있는것을 목표로 하고 있습니다.
1번째 케이스를 사용하기 위해서、<a class="reference internal" href="index.html#document-restful"><em>RESTful actions</em></a> 를 적용하여 대응하고、
2번째 케이스를 사용하기 위해、Ajax폼을 사용하고 있습니다.
아래 링크에서 postback에 대한 개념을 알 수 있습니다.</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Postback">http://en.wikipedia.org/wiki/Postback</a></li>
<li><a class="reference external" href="http://nitrogenproject.com/doc/tutorial.html">http://nitrogenproject.com/doc/tutorial.html</a></li>
</ul>
<p>Xitrum은  <a class="reference external" href="http://nitrogenproject.com/">Nitrogen</a> 영향을 받아서 작성되었습니다.</p>
<div class="section" id="id2">
<h3>레이아웃<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>폼<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>Articles.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.{GET, POST, First}
import xitrum.validator._

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val id      = param(&quot;id&quot;)
    val article = Article.find(id)
    respondInlineView(
      &lt;h1&gt;{article.title}&lt;/h1&gt;
      &lt;div&gt;{article.body}&lt;/div&gt;
    )
  }
}

@First  // Force this route to be matched before &quot;show&quot;
@GET(&quot;articles/new&quot;)
class ArticlesNew extends AppAction {
  def execute() {
    respondInlineView(
      &lt;form data-postback=&quot;submit&quot; action={url[ArticlesCreate]}&gt;
        &lt;label&gt;Title&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;title&quot; class=&quot;required&quot; /&gt;&lt;br /&gt;

        &lt;label&gt;Body&lt;/label&gt;
        &lt;textarea name=&quot;body&quot; class=&quot;required&quot;&gt;&lt;/textarea&gt;&lt;br /&gt;

        &lt;input type=&quot;submit&quot; value=&quot;Save&quot; /&gt;
      &lt;/form&gt;
    )
  }
}

@POST(&quot;articles&quot;)
class ArticlesCreate extends AppAction {
  def execute() {
    val title   = param(&quot;title&quot;)
    val body    = param(&quot;body&quot;)
    val article = Article.save(title, body)

    flash(&quot;Article has been saved.&quot;)
    jsRedirectTo(show, &quot;id&quot; -&gt; article.id)
  }
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">submit</span></code> 이벤트가 JavaScript 에서 실행될때、폼은 <code class="docutils literal"><span class="pre">ArticlesCreate</span></code> 으로 postback을 보냅니다.
<code class="docutils literal"><span class="pre">&lt;form&gt;</span></code> 의 <code class="docutils literal"><span class="pre">action</span></code> 속성은 암호화 되고、암호화된 URL은 CSRF토큰 대신 사용하게 됩니다.</p>
</div>
<div class="section" id="form">
<h3>form 이외의 사용<a class="headerlink" href="#form" title="제목 주소">¶</a></h3>
<p>포스트백은 form이 아닌 HTML 요소에서 사용이 가능합니다.</p>
<p>링크를 사용하는 예제:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot; data-postback=&quot;click&quot; action={url[LogoutAction]}&gt;Logout&lt;/a&gt;
</pre></div>
</div>
<p>링크를 클릭하게 되면 LogoutAction 으로 포스트백 메세지를 보냅니다.</p>
</div>
<div class="section" id="id4">
<h3>확인 다이얼로그<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<p>확인 다이얼로그를 표시하고 싶은 경우:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot; data-postback=&quot;click&quot;
            action={url[LogoutAction]}
            data-confirm=&quot;Do you want to logout?&quot;&gt;Logout&lt;/a&gt;
</pre></div>
</div>
<p>사용자가 취소를 클릭하게 되면 postback 메세지는 보내지 않습니다.</p>
</div>
<div class="section" id="id5">
<h3>매개 변수 추가<a class="headerlink" href="#id5" title="제목 주소">¶</a></h3>
<p>form의 요소중  <code class="docutils literal"><span class="pre">&lt;input</span> <span class="pre">type=&quot;hidden&quot;...</span></code> 를 추가하여 추가 매개변수를 postback메세지로 보낼 수 있습니다 .</p>
<p>form요소 이외의 경우 、다음과 같이 사용하면 됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot;
   data-postback=&quot;click&quot;
   action={url[ArticlesDestroy](&quot;id&quot; -&gt; item.id)}
   data-params=&quot;_method=delete&quot;
   data-confirm={&quot;Do you want to delete %s?&quot;.format(item.name)}&gt;Delete&lt;/a&gt;
</pre></div>
</div>
<p>또는 다음과 같이 다른 요소에 지정할 수 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;form id=&quot;myform&quot; data-postback=&quot;submit&quot; action={url[SiteSearch]}&gt;
  Search:
  &lt;input type=&quot;text&quot; name=&quot;keyword&quot; /&gt;

  &lt;a class=&quot;pagination&quot;
     href=&quot;#&quot;
     data-postback=&quot;click&quot;
     data-form=&quot;#myform&quot;
     action={url[SiteSearch](&quot;page&quot; -&gt; page)}&gt;{page}&lt;/a&gt;
&lt;/form&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">#myform</span></code> 은 JQuery의 선택요소로 폼의 추가 파라미터를 선택하여 보내게 됩니다.</p>
</div>
<div class="section" id="ajax">
<h3>Ajax로딩중 이미지 로딩<a class="headerlink" href="#ajax" title="제목 주소">¶</a></h3>
<p>다음과 같은 이미지를 Ajax로딩중에 표시하고 싶은경우、</p>
<img alt="_images/ajax_loading.gif" src="_images/ajax_loading.gif" />
<p>템플릿에서 、<code class="docutils literal"><span class="pre">jsDefault</span></code> (이것은 <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a> 를 포함하는 함수 입니다) 다음에 표시하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">ajaxLoadingImg</span> <span class="o">=</span> <span class="s">&#39;path/to/your/image&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-xml"></span><div class="section" id="xml">
<h2>XML<a class="headerlink" href="#xml" title="제목 주소">¶</a></h2>
<p>Scala는 리터럴 문자를 표시할 수 있습니다.Xitrum에서는 이 기능을 템플릿 엔진으로 설명하고 있습니다.</p>
<ul class="simple">
<li>Scala 는 XML구문을 컴파일때 체크합니다: View 는 typesafe합니다.</li>
<li>Scala는 XML을 자동으로 빠져나갑니다 <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a>　공격을 방지합니다.</li>
</ul>
<p>일부 팁이 있습니다.</p>
<div class="section" id="id1">
<h3>XML의 이스케이프<a class="headerlink" href="#id1" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">scala.xml.Unparsed</span></code> 를 사용하는 경우:</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.xml.Unparsed

&lt;script&gt;
  {Unparsed(&quot;if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);&quot;)}
&lt;/script&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:unparsed&gt;</span></code> 를 사용하는 경:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  &lt;xml:unparsed&gt;
    if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);
  &lt;/xml:unparsed&gt;
&lt;/script&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:unparsed&gt;</span></code> 는 실제 출력에 포함되지 않습니다:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);
&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>XML 요소의 그룹화<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>&lt;div id=&quot;header&quot;&gt;
  {if (loggedIn)
    &lt;xml:group&gt;
      &lt;b&gt;{username}&lt;/b&gt;
      &lt;a href={url[LogoutAction]}&gt;Logout&lt;/a&gt;
    &lt;/xml:group&gt;
  else
    &lt;xml:group&gt;
      &lt;a href={url[LoginAction]}&gt;Login&lt;/a&gt;
      &lt;a href={url[RegisterAction]}&gt;Register&lt;/a&gt;
    &lt;/xml:group&gt;}
&lt;/div&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:group&gt;</span></code> 는 실제 출력에 포함되지 않습니다.예를 들어 사용자가 로그인 한 경우:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;div id=&quot;header&quot;&gt;
  &lt;b&gt;My username&lt;/b&gt;
  &lt;a href=&quot;/login&quot;&gt;Logout&lt;/a&gt;
&lt;/div&gt;
</pre></div>
</div>
</div>
<div class="section" id="xhtml">
<h3>XHTML 렌더링<a class="headerlink" href="#xhtml" title="제목 주소">¶</a></h3>
<p>Xitrum은 view 와 레이아웃을 자동으로 XHTML로 출력합니다.
이것을 직접 출력으로 표시할경우 드믈지만 、다음 코드가 나타나는 것을 주의하세.</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.xml.Xhtml

val br = &lt;br /&gt;
br.toString            // =&gt; &lt;br&gt;&lt;/br&gt;, 이 경우 브라우저는 br이 두개가 있다고 판단합니다.
Xhtml.toXhtml(&lt;br /&gt;)  // =&gt; &quot;&lt;br /&gt;&quot;
</pre></div>
</div>
</div>
</div>
<span id="document-js"></span><div class="section" id="javascript-json">
<h2>JavaScript 와 JSON<a class="headerlink" href="#javascript-json" title="제목 주소">¶</a></h2>
<div class="section" id="javascript">
<h3>JavaScript<a class="headerlink" href="#javascript" title="제목 주소">¶</a></h3>
<p>Xitrum 은 jQuery를 내포하고 있습니다.</p>
<p>또한 일부 jsXXX 헬퍼도 제공하고 있습니다.</p>
<div class="section" id="javascript-view">
<h4>JavaScript 조각을 View 에 추가하는 방법<a class="headerlink" href="#javascript-view" title="제목 주소">¶</a></h4>
<p>액션내에서 <code class="docutils literal"><span class="pre">jsAddToView</span></code> 를 호출합니다.（필요한 경우 여러번 호출이 가능합니다）:</p>
<div class="highlight-python"><div class="highlight"><pre>class MyAction extends AppAction {
  def execute() {
    ...
    jsAddToView(&quot;alert(&#39;Hello&#39;)&quot;)
    ...
    jsAddToView(&quot;alert(&#39;Hello again&#39;)&quot;)
    ...
    respondInlineView(&lt;p&gt;My view&lt;/p&gt;)
  }
}
</pre></div>
</div>
<p>레이아웃 내에서 <code class="docutils literal"><span class="pre">jsForView</span></code> 를 호출합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;flash&quot;&gt;{jsFlash}&lt;/div&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h4>JavaScript를 직접호출 하는 경우<a class="headerlink" href="#id1" title="제목 주소">¶</a></h4>
<p>Javascript의 응답:</p>
<div class="highlight-python"><div class="highlight"><pre>jsRespond(&quot;$(&#39;#error&#39;).html(%s)&quot;.format(jsEscape(&lt;p class=&quot;error&quot;&gt;Could not login.&lt;/p&gt;)))
</pre></div>
</div>
<p>Javascript로 리다이렉션 하는 경우:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">jsRedirectTo</span><span class="p">(</span><span class="s">&quot;http://cntt.tv/&quot;</span><span class="p">)</span>
<span class="n">jsRedirectTo</span><span class="p">[</span><span class="n">LoginAction</span><span class="p">]()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="json">
<h3>JSON<a class="headerlink" href="#json" title="제목 주소">¶</a></h3>
<p>Xitrum은  <a class="reference external" href="https://github.com/json4s/json4s">JSON4S</a> 를 내포하고 있습니다.
JSON의 파싱과 생성은 JSON4S 을 읽어보세요.</p>
<p>Scala의 case 객체를 JSON으로 변환하는 경우:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri

case class Person(name: String, age: Int, phone: Option[String])
val person1 = Person(&quot;Jack&quot;, 20, None)
val json    = SeriDeseri.toJson(person)
val person2 = SeriDeseri.fromJson(json)
</pre></div>
</div>
<p>JSON의 응답:</p>
<div class="highlight-python"><div class="highlight"><pre>val scalaData = List(1, 2, 3)  // An example
respondJson(scalaData)
</pre></div>
</div>
<p>JSON은 중접된 구조로 되어 있는 문장을 만들기에 적합합니다.</p>
<p>참고 <a class="reference internal" href="index.html#document-howto"><em>설정 파일 읽어들이기</em></a></p>
</div>
<div class="section" id="knockout-js">
<h3>Knockout.js 플러그인<a class="headerlink" href="#knockout-js" title="제목 주소">¶</a></h3>
<p>참고 <a class="reference external" href="https://github.com/xitrum-framework/xitrum-ko">xitrum-ko</a></p>
</div>
</div>
<span id="document-async"></span><div class="section" id="id1">
<h2>비동기 응답<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p>Action에서 클라이언트로 응답을 반환하려면 다음 방법을 사용합니다</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondView</span></code>: 레이아웃 파일을 사용 또는 사용하지 않고、View의 템플릿 파일을 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondInlineView</span></code>: 레이아웃 파일을 사용 또는 사용하지 않고、인라인 작성된 템플릿을 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></code>: 레이아웃 파일을 사용하지 않고 텍스트를 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></code>: 위와 같이 contentType을 &#8220;text/html&#8221;로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>: Scala 객체를 JSON 으로 변환하여、contentType을 &#8220;application/json&#8221;으로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></code> contentType을 &#8220;application/javascript&#8221;으로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></code>: 위 두가지 조합을 JSONP 으로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></code>: contentType 을 &#8220;application/javascript&#8221; 으로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></code>: <cite>respondJs</cite> 、 <cite>respondJsonText</cite> 의 두가지 조합을 JSONP로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondBinary</span></code>: 바이트 배열로 보냅니다</li>
<li><code class="docutils literal"><span class="pre">respondFile</span></code>: 디스크에서 파일을 직접 보냅니다. <a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a> 를 사용하기 때문에 빠릅니다.</li>
<li><code class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></code>: 청크 응답을 보냅니다</li>
</ul>
<p>Xitrum 은 자동으로 어떤 특정한 응답을 하지 않습니다.스스로 응답을 <code class="docutils literal"><span class="pre">respondXXX</span></code> 형식으로 명시해야 합니다.
<code class="docutils literal"><span class="pre">respondXXX</span></code> 을 호출하지 않을경우 Xitrum 은 HTTP 연결을 유지 하기때문에 , 나중에 <code class="docutils literal"><span class="pre">respondXXX</span></code> 형식의 호출문이 필요합니다.</p>
<p>연결이 open 상태로 되어 있는지 확인하려면 <code class="docutils literal"><span class="pre">channel.isOpen</span></code> 을 호출하면 됩니다.``addConnectionClosedListener``
를 사용해도 무방합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>addConnectionClosedListener {
  // 연결이 해제되었습니다.
  // 이벤트로부터 자원을 해제합니다.
}
</pre></div>
</div>
<p>비동기 이므로 응답을 바로 전송하지 않습니다.``respondXXX`` 의 반환값은
<a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html">ChannelFuture</a>
를 사용합니다.이것을 통해 실제로 전송되는 콜백을 지정할 수 있습니다.</p>
<p>예를 들어, 응답의 전송후에 연결을 해제하려면:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.channel.{ChannelFuture, ChannelFutureListener}

val future = respondText(&quot;Hello&quot;)
future.addListener(new ChannelFutureListener {
  def operationComplete(future: ChannelFuture) {
    future.getChannel.close()
  }
})
</pre></div>
</div>
<p>더 짧은 예:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondText</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">addListener</span><span class="p">(</span><span class="n">ChannelFutureListener</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="websocket">
<h3>WebSocket<a class="headerlink" href="#websocket" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import scala.runtime.ScalaRunTime
import xitrum.annotation.WEBSOCKET
import xitrum.{WebSocketAction, WebSocketBinary, WebSocketText, WebSocketPing, WebSocketPong}

@WEBSOCKET(&quot;echo&quot;)
class EchoWebSocketActor extends WebSocketAction {
  def execute() {
    // 여기에서 세션데이터, 요청해더 등을 추출할 수 있지만
    // respondText 나 respondView를 사용하면 안됩니다.
    // 응답하려면 다음과 같이 respondWebSocketXXX를 사용하세요.

    log.debug(&quot;onOpen&quot;)

    context.become {
      case WebSocketText(text) =&gt;
        log.info(&quot;onTextMessage: &quot; + text)
        respondWebSocketText(text.toUpperCase)

      case WebSocketBinary(bytes) =&gt;
        log.info(&quot;onBinaryMessage: &quot; + ScalaRunTime.stringOf(bytes))
        respondWebSocketBinary(bytes)

      case WebSocketPing =&gt;
        log.debug(&quot;onPing&quot;)

      case WebSocketPong =&gt;
        log.debug(&quot;onPong&quot;)
    }
  }

  override def postStop() {
    log.debug(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>요청이 올때 위의 액터가 생성됩니다. 그리고 다음의 경우 중단됩니다:</p>
<ul class="simple">
<li>연결이 끊긴경우</li>
<li>WebSocket의 close 프레임이 수신되거나 전송되었을때</li>
</ul>
<p>WebSocket 프레임을 전송하는 경우:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondWebSocketText</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketBinary</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketPing</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketClose</span></code></li>
</ul>
<p><code class="docutils literal"><span class="pre">respondWebSocketPong</span></code> 은 없습니다.Xitrum이 ping 을 수신하게 되면 자동으로 pong 프레임을 전송하기 때문입니다.</p>
<p>위의 WebSocket 액션의 URL 을 얻으려면:</p>
<div class="highlight-python"><div class="highlight"><pre>// Scalate 템플릿 파일을 사용하기 원한다면
val url = webSocketAbsUrl[EchoWebSocketActor]
</pre></div>
</div>
</div>
<div class="section" id="sockjs">
<h3>SockJS<a class="headerlink" href="#sockjs" title="제목 주소">¶</a></h3>
<dl class="docutils">
<dt><a class="reference external" href="https://github.com/sockjs/sockjs-client">SockJS</a> 은 WebSocket을 지원하지 않는 브라우저를 위한</dt>
<dd><p class="first">WebSocket 과 같은 API를 제공하는 JavaScript라이브러리 입니다. SockJS는 먼저 WebSocket를 시도해보고
실패할경우 다른 방법들을 통해 WebSocket과 같은 라이브러리들을 사용하게 됩니다</p>
<p class="last">만약, 모든 브라우저에서 WebSocket API를 사용하고 싶다면, SockJS 을 사용하되 WebSocket을 직접 사용하지 마세요.</p>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  var sock = new SockJS(&#39;http://mydomain.com/path_prefix&#39;);
  sock.onopen = function() {
    console.log(&#39;open&#39;);
  };
  sock.onmessage = function(e) {
    console.log(&#39;message&#39;, e.data);
  };
  sock.onclose = function() {
    console.log(&#39;close&#39;);
  };
&lt;/script&gt;
</pre></div>
</div>
<p>Xitrum 은 SockJS의 JavsScript 파일을 내포하고 있습니다.
뷰 템플릿에서 다음과 같이 사용하면 됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>...
html
  head
    != jsDefaults
...
</pre></div>
</div>
<p>SockJS는 <a class="reference external" href="https://github.com/sockjs/sockjs-protocol">server counterpart</a> 를 필요로 하지 않습니다.
Xitrum이 자동으로 제공합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SockJsAction, SockJsText}
import xitrum.annotation.SOCKJS

@SOCKJS(&quot;echo&quot;)
class EchoSockJsActor extends SockJsAction {
  def execute() {
    // 응답을 위해, 아래에 respondSockJSXXX를 사용합니다

    log.info(&quot;onOpen&quot;)

    context.become {
      case SockJsText(text) =&gt;
        log.info(&quot;onMessage: &quot; + text)
        respondSockJsText(text)
    }
  }

  override def postStop() {
    log.info(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>액터 새로운 SockJS 세션이 만들어질때 생겨나고 SockJS세션이 닫힐때 종료합니다.</p>
<p>SockJS 프레임으로 보내려면:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondSockJsText</span></code></li>
<li><code class="docutils literal"><span class="pre">respondSockJsClose</span></code></li>
</ul>
<p><a class="reference external" href="https://github.com/sockjs/sockjs-node#various-issues-and-design-considerations">SockJs주의사항</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>기본적으로 쿠키는 SockJS 모델과 맞지가 않습니다. 세션인증을 하려면 고유의 토큰을 SockJS를
통해 서버측에서 검증을 해야 합니다. 이것이 본질적으로 쿠키의 작동원리 입니다
</pre></div>
</div>
<p>SockJS클러스터링을 수정하려면 :doc:<a href="#id4"><span class="problematic" id="id5">`</span></a>Akka 클러스터링 &lt;/cluster&gt;`을 참고하세요.</p>
</div>
<div class="section" id="chunk">
<h3>Chunk응답<a class="headerlink" href="#chunk" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">Chunk응답</a> 을 보내려면:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">setChunked</span></code> 호출</li>
<li><code class="docutils literal"><span class="pre">respondXXX</span></code> 호출（필요한 만큼）</li>
<li>마지막으로 <code class="docutils literal"><span class="pre">respondLastChunk</span></code> 호출</li>
</ol>
<p>Chunk응답은 많은 유스케이스를 가지고 있습니다. 예를들어, 메모리에 맞지 않는 매우큰 CSV파일을 생성할때
Chunk별로 생성해서 보낼수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>// &quot;Cache-Control&quot; 헤더가 자동으로 세팅됩니다:
// 「no-store, no-cache, must-revalidate, max-age=0」
//
// 덧붙여서 &quot;Pragma: no-cache&quot; 는 응답이 아닌 요청에 링크됩니다:
// http://palizine.plynt.com/issues/2008Jul/cache-control-attributes/
setChunked()

val generator = new MyCsvGenerator

generator.onFirstLine { line =&gt;
  val future = respondText(header, &quot;text/csv&quot;)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) generator.next()
    }
  }
}

generator.onNextLine { line =&gt;
  val future = respondText(line)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) generator.next()
    }
  })
}

generator.onLastLine { line =&gt;
  val future = respondText(line)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) respondLastChunk()
    }
  })
}

generator.generate()
</pre></div>
</div>
<p>주의:</p>
<ul class="simple">
<li>헤더는 <code class="docutils literal"><span class="pre">respondXXX</span></code> 을 먼저 요청합니다.</li>
<li>마지막 헤더 옵션을 <code class="docutils literal"><span class="pre">respondLastChunk</span></code> 에 설정할 수 있습니다.</li>
<li><a class="reference internal" href="index.html#document-cache"><em>페이지와 액션캐쉬</em></a> 는 chunk 응답으로 사용할 수 없습니다.</li>
</ul>
<p>Chunk응답을  <code class="docutils literal"><span class="pre">ActorAction</span></code> 과 함께 사용하려면
<a class="reference external" href="http://www.cubrid.org/blog/dev-platform/faster-web-page-loading-with-facebook-bigpipe/">Facebook BigPipe</a>
을 통해 쉽게 구현할수 있습니다.</p>
<div class="section" id="iframe">
<h4>무한iframe<a class="headerlink" href="#iframe" title="제목 주소">¶</a></h4>
<dl class="docutils">
<dt>청크 응답은 <a class="reference external" href="http://en.wikipedia.org/wiki/Comet_%28programming%29">Comet</a></dt>
<dd>을 <a class="reference external" href="http://www.shanison.com/2010/05/10/stop-the-browser-%E2%80%9Cthrobber-of-doom%E2%80%9D-while-loading-comet-forever-iframe/">사용할 수 있습니다</a></dd>
</dl>
<p>iframe을 포함한 페이지:</p>
<div class="highlight-python"><div class="highlight"><pre>...
&lt;script&gt;
  var functionForForeverIframeSnippetsToCall = function() {...}
&lt;/script&gt;
...
&lt;iframe width=&quot;1&quot; height=&quot;1&quot; src=&quot;path/to/forever/iframe&quot;&gt;&lt;/iframe&gt;
...
</pre></div>
</div>
<p>무한 <code class="docutils literal"><span class="pre">&lt;script&gt;</span></code> 생성하는 페이지:</p>
<div class="highlight-python"><div class="highlight"><pre>// 준비

setChunked()

// Firefox를 동작하기 위해 &quot;123&quot; 등을 사용
respondText(&quot;&lt;html&gt;&lt;body&gt;123&quot;, &quot;text/html&quot;)

// curl을 포함한 대부분의 클라이언트는 script를 미리보기로 바로 사용할 수 없음.
// 2KB의 더미 데이터를 바로 보내볼 필요가 있음.
for (i &lt;- 1 to 100) respondText(&quot;&lt;script&gt;&lt;/script&gt;\n&quot;)
</pre></div>
</div>
<p>나중에 실제 데이터를 브라우저에 보내려면, 미리보기를 보내면 된다:</p>
<div class="highlight-python"><div class="highlight"><pre>if (channel.isOpen)
  respondText(&quot;&lt;script&gt;parent.functionForForeverIframeSnippetsToCall()&lt;/script&gt;\n&quot;)
else
  // 연결이 종료되고, 이벤트가 해제됨
  // ``addConnectionClosedListener`` 을 사용할수 있음.
</pre></div>
</div>
</div>
<div class="section" id="event-source">
<h4>Event Source<a class="headerlink" href="#event-source" title="제목 주소">¶</a></h4>
<p>참고: <a class="reference external" href="http://dev.w3.org/html5/eventsource/">http://dev.w3.org/html5/eventsource/</a></p>
<p>Event Source는 특별한 경우 chunk응답을 보냄.
데이터는 UTF-8 이어야 함.</p>
<p>Event Source를 응답하려면 <code class="docutils literal"><span class="pre">respondEventSource</span></code> 호출（필요한 만큼）:</p>
<div class="highlight-python"><div class="highlight"><pre>respondEventSource(&quot;data1&quot;, &quot;event1&quot;)  // event1의 이벤트 이름
respondEventSource(&quot;data2&quot;)            // message라는 이벤트 이름으로 기본설정됨
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-static"></span><div class="section" id="id1">
<h2>정적 파일<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<div class="section" id="id2">
<h3>디스크의 정적 파일 전송<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<p>프로젝트 디렉토리의 레이아웃:</p>
<div class="highlight-python"><div class="highlight"><pre>config
public
  favicon.ico
  robots.txt
  404.html
  500.html
  img
    myimage.png
  css
    mystyle.css
  js
    myscript.js
src
build.sbt
</pre></div>
</div>
<p>Xitrum은 <code class="docutils literal"><span class="pre">public</span></code> 디렉토리의 정적 파일들을 자동으로 제공합니다.
URLs는 다음과 같이 사용합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>/img/myimage.png
/css/mystyle.css
/css/mystyle.min.css
</pre></div>
</div>
<p>참조하려면:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={publicUrl(&quot;img/myimage.png&quot;)} /&gt;
</pre></div>
</div>
<p>일반 파일을 개발환경에서 사용하고 압축된 버전의 파일을 프로덕션 환경에서 사용하려면
(위의 mystyle.css 와 mystyle.min.css):</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={publicUrl(&quot;css&quot;, &quot;mystyle.css&quot;, &quot;mystyle.min.css&quot;)} /&gt;
</pre></div>
</div>
<p>디스크의 정적 파일을 액션을 통해 전송하려면 <code class="docutils literal"><span class="pre">respondFile</span></code> 을 사용합니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondFile</span><span class="p">(</span><span class="s">&quot;/absolute/path&quot;</span><span class="p">)</span>
<span class="n">respondFile</span><span class="p">(</span><span class="s">&quot;path/relative/to/the/current/working/directory&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>정적 파일의 전송 속도를 최적화 하기 위해,
정규식 필터를 통해 불필요한 파일의 존재 체크를 미연에 방지 할 수 있습니다.
만약 요청된 URL이 pathRegex 와 맞지 않으면 Xitrum은 해당 요청에 404를 응답합니다</p>
<p><code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> 의 <code class="docutils literal"><span class="pre">pathRegex</span></code> 를 참고하세요.</p>
</div>
<div class="section" id="index-html">
<h3>index.html 대체<a class="headerlink" href="#index-html" title="제목 주소">¶</a></h3>
<p>만약, <code class="docutils literal"><span class="pre">/foo/bar</span></code> (또는 <code class="docutils literal"><span class="pre">/foo/bar/</span></code> ) URL의 경로(액션)가 없을경우
Xitrum 은 <code class="docutils literal"><span class="pre">public/foo/bar/index.html</span></code> (&#8220;public&#8221; 디렉토리) 경로의 정적 파일을 탐색합니다.
파일이 존재하면, Xitrum은 해당파일을 클라이언트로 응답합니다.</p>
</div>
<div class="section" id="id3">
<h3>404 과 500<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>요청에 대해 적합한 경로가 없거나 에러가 발생한 경우 <code class="docutils literal"><span class="pre">public</span></code> 디렉토리에 있는 404.html과 500.html이 사용됩니다.
핸들러를 직접 등록하고 싶은경우:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{Error404, Error500}

@Error404
class My404ErrorHandlerAction extends Action {
  def execute() {
    if (isAjax)
      jsRespond(&quot;alert(&quot; + jsEscape(&quot;Not Found&quot;) + &quot;)&quot;)
    else
      renderInlineView(&quot;Not Found&quot;)
  }
}

@Error500
class My500ErrorHandlerAction extends Action {
  def execute() {
    if (isAjax)
      jsRespond(&quot;alert(&quot; + jsEscape(&quot;Internal Server Error&quot;) + &quot;)&quot;)
    else
      renderInlineView(&quot;Internal Server Error&quot;)
  }
}
</pre></div>
</div>
<p>응답에 대한 요청은 액션이 수행되기 전에 404과 500이 세팅되므로, 임의로 세팅할 필요는 없습니다.</p>
</div>
<div class="section" id="webjar">
<h3>WebJar에 의한 클래스 패스내의 리소스 파일 전송<a class="headerlink" href="#webjar" title="제목 주소">¶</a></h3>
<div class="section" id="webjars">
<h4>WebJars<a class="headerlink" href="#webjars" title="제목 주소">¶</a></h4>
<p><a class="reference external" href="http://www.webjars.org/">WebJars</a> 는 상당량의 웹 라이브러리를 제공하고 프로젝트 내에서
정의해 사용할 수 있습니다.</p>
<p>예를들어 <a class="reference external" href="http://underscorejs.org/">Underscore.js</a> 를 사용하고자 하는 경우,
프로젝트의 <code class="docutils literal"><span class="pre">build.sbt</span></code> 내에 정의하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;org.webjars&quot;</span> <span class="o">%</span> <span class="s">&quot;underscorejs&quot;</span> <span class="o">%</span> <span class="s">&quot;1.6.0-3&quot;</span>
</pre></div>
</div>
<p>그리고 .jade 템플릿 파일에서 사용됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">script</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="p">{</span><span class="n">webJarsUrl</span><span class="p">(</span><span class="s">&quot;underscorejs/1.6.0&quot;</span><span class="p">,</span> <span class="s">&quot;underscore.js&quot;</span><span class="p">,</span> <span class="s">&quot;underscore-min.js&quot;</span><span class="p">)})</span>
</pre></div>
</div>
<p>Xitrum은 자동으로 개발환경에서  <code class="docutils literal"><span class="pre">underscore.js</span></code> 를 사용하고　<code class="docutils literal"><span class="pre">underscore-min.js</span></code> 를
프로덕션 환경에서 사용합니다.</p>
<p>결과는 다음과 같습니:</p>
<div class="highlight-python"><div class="highlight"><pre>/webjars/underscorejs/1.6.0/underscore.js?XOKgP8_KIpqz9yUqZ1aVzw
</pre></div>
</div>
<p>동일한 파일을 동일 환경에서 사용하려면:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">script</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="p">{</span><span class="n">webJarsUrl</span><span class="p">(</span><span class="s">&quot;underscorejs/1.6.0/underscore.js&quot;</span><span class="p">)})</span>
</pre></div>
</div>
<p>종속된 파일들은 자동으로 다운로드 됩니다. 버전충돌의 문제로 원하는 버전의 라이브러리가 선택되지 않았을경우(<code class="docutils literal"><span class="pre">sbt</span> <span class="pre">xitrum-package</span></code> 명렁어를 통해 다음에 생성되는 디렉토리의 파일들을 보고 확인할 수 있습니다. <code class="docutils literal"><span class="pre">target/xitrum/lib</span></code>), <code class="docutils literal"><span class="pre">dependencyOverrides</span></code> 에서 강제로 원하는 버전의 라이브러리를 추가할 수 있습니다. 예를들어,jQuery 2.x 이 선택되었지만,인터넷 익스플로러 6, 7, 8, 에서 강제로 jQuery 1.x 사용하기를 원할경우 다음과 같이 사용하면 됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dependencyOverrides</span> <span class="o">+=</span> <span class="s">&quot;org.webjars&quot;</span> <span class="o">%</span> <span class="s">&quot;jquery&quot;</span> <span class="o">%</span> <span class="s">&quot;1.11.3&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="webjars-jar">
<h4>WebJars 형식으로 리소스 파일을 .jar 내에 저장하기<a class="headerlink" href="#webjars-jar" title="제목 주소">¶</a></h4>
<p>만약 라이브러리를 개발하여 라이브러리에 myimage.png를 추가하고 싶다면
<a class="reference external" href="http://www.webjars.org/">WebJars</a> 의 형식으로 .jar 파일의 클래스패스에
myimage.png를 넣을 수 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">META</span><span class="o">-</span><span class="n">INF</span><span class="o">/</span><span class="n">resources</span><span class="o">/</span><span class="n">webjars</span><span class="o">/</span><span class="n">mylib</span><span class="o">/</span><span class="mf">1.0</span><span class="o">/</span><span class="n">myimage</span><span class="o">.</span><span class="n">png</span>
</pre></div>
</div>
<p>사용법:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={webJarsUrl(&quot;mylib/1.0/myimage.png&quot;)} /&gt;
</pre></div>
</div>
<p>개발환경과 프로덕션 환경 모두에서 URL은:</p>
<div class="highlight-python"><div class="highlight"><pre>/webjars/mylib/1.0/myimage.png?xyz123
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>클래스 패스내의 파일 응답<a class="headerlink" href="#id6" title="제목 주소">¶</a></h4>
<p>클래스 패스내의 <a class="reference external" href="http://www.webjars.org/">WebJars</a> 형식으로 저장되지 않은 파일의 응답:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;path/relative/to/the/classpath/element&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>예:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;akka/actor/Actor.class&quot;</span><span class="p">)</span>
<span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;META-INF/resources/webjars/underscorejs/1.6.0/underscore.js&quot;</span><span class="p">)</span>
<span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;META-INF/resources/webjars/underscorejs/1.6.0/underscore-min.js&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="etag-max-age">
<h3>ETag 과 max-age의 클라이언트 캐쉬<a class="headerlink" href="#etag-max-age" title="제목 주소">¶</a></h3>
<p>Xitrum은 자동으로 <a class="reference external" href="http://ja.wikipedia.org/wiki/HTTP_ETag">Etag</a> 을 디스크내 클래스 패스의 정적파일을 사용하기 위해 추가합니다.</p>
<p>ETags는 작은 파일일 경우 MD5로 캐쉬되어 나중에 사용됩니다. 캐쉬 앤트리의 키는 <code class="docutils literal"><span class="pre">(파일경로,</span> <span class="pre">수정시간)</span></code> 입니다. 왜냐하면 파일의 변경시간은 각 서버별로 상이하기 때문에
클러스터의 각 서버는 각각 로컬 ETag 캐쉬를 가지게 됩니다.</p>
<p>큰 파일의 경우, 수정된 시간만을 ETag에 사용됩니다. 완벽하지는 않지만 각기 서버는 다른 ETag 정보를 가질것으로 예상되기 때문입니다.
물론 ETag를 사용하지 않는 경우보다는 약간 낫다고 보여집니다.</p>
<p><code class="docutils literal"><span class="pre">publicUrl</span></code> 과 <code class="docutils literal"><span class="pre">resourceUrl</span></code> 은 자동으로 Etag가 추가되어 URLs이 생성됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>webJarsUrl(&quot;jquery/2.1.1/jquery.min.js&quot;)
=&gt; /webjars/jquery/2.1.1/jquery.min.js?0CHJg71ucpG0OlzB-y6-mQ
</pre></div>
</div>
<p>Xitrum은 헤더의 <code class="docutils literal"><span class="pre">max-age</span></code> 와 <code class="docutils literal"><span class="pre">Expires</span></code> 를 <a class="reference external" href="https://developers.google.com/speed/docs/best-practices/caching">1년</a> 으로 설정합니다.
브라우저가 최신 파일을 참조하지 못할것을 염려하지 않아도 됩니다.
왜냐하면 디스크의 파일이 변경될때, <code class="docutils literal"><span class="pre">수정시간</span></code> 이 변하게 되고,
<code class="docutils literal"><span class="pre">publicUrl</span></code> 과 <code class="docutils literal"><span class="pre">resourceUrl</span></code> 이 변하게 된 상태로 생성되기 때문입니다.
ETag 캐쉬 또한 업데이트 되기 때문에 키도 변하게 됩니다.</p>
</div>
<div class="section" id="gzip">
<h3>GZIP<a class="headerlink" href="#gzip" title="제목 주소">¶</a></h3>
<p>Xitrum은 자동으로 텍스트 형식의 응답을 gzips을 적용합니다. <code class="docutils literal"><span class="pre">Content-Type</span></code> 헤더를 통해 형식이
<code class="docutils literal"><span class="pre">text/html</span></code>, <code class="docutils literal"><span class="pre">xml/application</span></code> 등과 같은 텍스트 형식인지 체크해서 결정합니다.</p>
<p>Xitrum은 정적 파일에 대해서는 항상 gzips을 수행하지만, 동적인 텍스트 응답에 대해서는 성능 최적화를 위해
1 KB 미만의 응답에 대해서는 gzips을 수행하지 않습니다.</p>
</div>
<div class="section" id="id9">
<h3>서버 캐쉬<a class="headerlink" href="#id9" title="제목 주소">¶</a></h3>
<p>디스크로부터 파일 로딩을 방지하기 위해, Xitrum은 작은 정적파일에 대해서(텍스트 뿐만 아니라)
메모리에 LRU (Least Recently Used) 알고리즘을 사용합니다.</p>
<p><code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> 내의 <code class="docutils literal"><span class="pre">small_static_file_size_in_kb</span></code> 와 <code class="docutils literal"><span class="pre">max_cached_small_static_files</span></code> 에서 확인할 수 있습니다.</p>
</div>
</div>
<span id="document-flash"></span><div class="section" id="flash-socket">
<h2>Flash Socket 정책 파일<a class="headerlink" href="#flash-socket" title="제목 주소">¶</a></h2>
<p>Flash Socket 정책 파일:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html">http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html</a></li>
<li><a class="reference external" href="http://www.lightsphere.com/dev/articles/flash_socket_policy.html">http://www.lightsphere.com/dev/articles/flash_socket_policy.html</a></li>
</ul>
<p>Flash Socket 정책 파일 프로토콜은 Http와 다릅니다.
제공 하려면:</p>
<ol class="arabic simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/flash_socket_policy.xml">config/flash_socket_policy.xml</a>
를 수정합니다</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>
위 파일을 수정하여 활성화 합니다</li>
</ol>
</div>
<span id="document-scopes"></span><div class="section" id="id1">
<h2>스코프<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p>요청
&#8212;</p>
<div class="section" id="id2">
<h3>매개변수<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<p>두가지의 요청 매개변수:</p>
<ol class="arabic simple">
<li>텍스트</li>
<li>파일업로드(바이너리)</li>
</ol>
<p>다음과 같은 타입의 <code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Seq[String]]</span></code> 3가지 매개변수:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">queryParams</span></code>: URL내의 ?다음에 오는 매개변수  예: <code class="docutils literal"><span class="pre">http://example.com/blah?x=1&amp;y=2</span></code></li>
<li><code class="docutils literal"><span class="pre">bodyTextParams</span></code>: POST요청의 body에 포함된 매개변수</li>
<li><code class="docutils literal"><span class="pre">pathParams</span></code>: URL내에 포함된 매개변수  예: <code class="docutils literal"><span class="pre">GET(&quot;articles/:id/:title&quot;)</span></code></li>
</ol>
<p>이 매개변수들은 위의 순서대로、 <code class="docutils literal"><span class="pre">textParams</span></code> 에 병합됩니다.
（1번에서 3번의 순서대로 매개변수를 덮어씁니다.）</p>
<p><code class="docutils literal"><span class="pre">bodyFileParams</span></code> 은 <code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Seq[</span></code> <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/multipart/FileUpload.html">FileUpload</a> <code class="docutils literal"><span class="pre">]]</span></code> 의 형태입니다.</p>
</div>
<div class="section" id="id3">
<h3>매개변수 접근<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>액션내에서, 매개변수에 직접접근하거나, 접근자 함수를 사용할수 있습니다.</p>
<p><code class="docutils literal"><span class="pre">textParams</span></code> 에 접근하는 경우:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">param(&quot;x&quot;)</span></code>: <code class="docutils literal"><span class="pre">String</span></code> 을 반환하며, x가 존재하지 않으면 예외를 던집니다.</li>
<li><code class="docutils literal"><span class="pre">paramo(&quot;x&quot;)</span></code>: <code class="docutils literal"><span class="pre">Option[String]</span></code> 을 반환합니다.</li>
<li><code class="docutils literal"><span class="pre">params(&quot;x&quot;)</span></code>: <code class="docutils literal"><span class="pre">Seq[String]</span></code> 을 반환하며, x가 존재하지 않으면 Seq.empty를 반환합니다.</li>
</ul>
<p>파라미터를 다른 형태(Int, Long, Fload, Double)로 다음과 같이 <code class="docutils literal"><span class="pre">param[Int](&quot;x&quot;)</span></code> 이나 <code class="docutils literal"><span class="pre">params[Int](&quot;x&quot;)</span></code> 자동으로 변환이 가능합니다.
이 밖에 다른 형태로 변환하고자 하면, <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala-2.11/xitrum/scope/request/ParamAccess.scala">convertTextParam</a> 를 재정의 하여 사용하면 됩니다.</p>
<p>파일 업로드의 경우, <code class="docutils literal"><span class="pre">param[FileUpload](&quot;x&quot;)</span></code> 나 <code class="docutils literal"><span class="pre">params[FileUpload](&quot;x&quot;)</span></code> 를 사용하면 됩니다.
자세한 내용은 <a class="reference internal" href="index.html#document-upload"><em>Upload chapter</em></a> 를 참고하세요.</p>
</div>
<div class="section" id="at">
<h3>&#8220;at&#8221;<a class="headerlink" href="#at" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">at</span></code> 을 사용하여 요청을 전달하는 동안 매개변수를 전달할 수 있습니다(액션이나, 뷰, 또는 레이아웃에서）.
<code class="docutils literal"><span class="pre">at</span></code> 은 <code class="docutils literal"><span class="pre">scala.collection.mutable.HashMap[String,</span> <span class="pre">Any]</span></code> 타입입니다.
<code class="docutils literal"><span class="pre">at</span></code> 은 Rails에서 <code class="docutils literal"><span class="pre">&#64;</span></code> 과 같은 역할을 수행합니다.</p>
<p>Articles.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val (title, body) = ...  // Get from DB
    at(&quot;title&quot;) = title
    respondInlineView(body)
  }
}
</pre></div>
</div>
<p>AppAction.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;{if (at.isDefinedAt(&quot;title&quot;)) &quot;My Site - &quot; + at(&quot;title&quot;) else &quot;My Site&quot;}&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="atjson">
<h3>&#8220;atJson&#8221;<a class="headerlink" href="#atjson" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">atJson</span></code> 은 <code class="docutils literal"><span class="pre">at(&quot;key&quot;)</span></code> 을 자동으로 JSON으로 변환시 사용되는 헬퍼입니다.
Scala 에서 Javascript 로 모델을 전달시에 유용하게 사용됩니다.</p>
<p><code class="docutils literal"><span class="pre">atJson(&quot;key&quot;)</span></code> 은 <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.toJson(at(&quot;key&quot;))</span></code> 과 같습니다.</p>
<p>Action.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>case class User(login: String, name: String)

...

def execute() {
  at(&quot;user&quot;) = User(&quot;admin&quot;, &quot;Admin&quot;)
  respondView()
}
</pre></div>
</div>
<p>Action.ssp:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script type=&quot;text/javascript&quot;&gt;
  var user = ${atJson(&quot;user&quot;)};
  alert(user.login);
  alert(user.name);
&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="requestvar">
<h3>RequestVar<a class="headerlink" href="#requestvar" title="제목 주소">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">at</span></code> 은 어떠한 값도 map으로 저장이 가능해서 typesafe하지 않습니다.</div></blockquote>
<p>안전하게 사용하려면 <code class="docutils literal"><span class="pre">at</span></code> 의 래퍼인 <code class="docutils literal"><span class="pre">RequestVar</span></code> 을 사용하면 됩니다.</p>
<p>RVar.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.RequestVar

object RVar {
  object title extends RequestVar[String]
}
</pre></div>
</div>
<p>Articles.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val (title, body) = ...  // Get from DB
    RVar.title.set(title)
    respondInlineView(body)
  }
}
</pre></div>
</div>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;{if (RVar.title.isDefined) &quot;My Site - &quot; + RVar.title.get else &quot;My Site&quot;}&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
<p>쿠키
&#8212;</p>
<p>위키피디아에 정의되어 있습니다. <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie">cookies</a></p>
<p>액션내에 <code class="docutils literal"><span class="pre">requestCookies</span></code> 를 사용하여 <code class="docutils literal"><span class="pre">Map[String,</span> <span class="pre">String]</span></code> 형식으로 브라우저에서 보낸 쿠키를 읽을 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>requestCookies.get(&quot;myCookie&quot;) match {
  case None         =&gt; ...
  case Some(string) =&gt; ...
}
</pre></div>
</div>
<p>브라우저에서 쿠키를 전송하려면, <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/DefaultCookie.html">DefaultCookie</a> 인스턴스를 생성하고 <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/Cookie.html">Cookie</a> 를 가지고 있는 <code class="docutils literal"><span class="pre">ArrayBuffer</span></code> 형식으로、 <code class="docutils literal"><span class="pre">responseCookies</span></code> 에 추가합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>val cookie = new DefaultCookie(&quot;name&quot;, &quot;value&quot;)
cookie.setHttpOnly(true)  // true: JavaScript cannot access this cookie
responseCookies.append(cookie)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">cookie.setPath(cookiePath)</span></code> 를 설정하지 않고 사용하면
루트 (<code class="docutils literal"><span class="pre">xitrum.Config.withBaseUrl(&quot;/&quot;)</span></code>)가 설정되고 원치않는 중복을 막아줍니다.</p>
<p>브라우저에서 보낸 쿠키를 삭제하려면 같은 이름의 쿠키를 &#8220;max-age&#8221; 를 0으로 설정하면, 브라우저에서는 즉시 쿠키를 만료시킵니다.
브라우저가 종료될때 쿠키를 삭제하려면 &#8220;max-age&#8221; 를 <code class="docutils literal"><span class="pre">Long.MinValue</span></code> 으로 설정합니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cookie</span><span class="o">.</span><span class="n">setMaxAge</span><span class="p">(</span><span class="n">Long</span><span class="o">.</span><span class="n">MinValue</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference external" href="http://mrcoles.com/blog/cookies-max-age-vs-expires/">Internet Explorer 는 &#8220;max-age&#8221; 를 지원하지 않습니다.</a> .
그러나, Netty는  &#8220;max-age&#8221; 와 &#8220;expires&#8221; 를 동시에 찾아내기 때문에 걱정하지 않아도 됩니다.</p>
<p>브라우저는 쿠키의 속성 서버로 전송하지 않습니다.
브라우저는 <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie#Cookie_attributes">name-value pairs</a> 만을 보냅니다.</p>
<p>서명된 쿠키를 사용하여 쿠키의 변조를 방지하려면,
<code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.toSecureUrlSafeBase64</span></code> 와 <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.fromSecureUrlSafeBase64</span></code> 을 사용하세요.
자세한 내용은 <a class="reference internal" href="index.html#document-howto"><em>How to encrypt data</em></a> 를 참고하세요</p>
</div>
<div class="section" id="id4">
<h3>쿠키가 가능한 문자들<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<p>쿠키는 <a class="reference external" href="http://stackoverflow.com/questions/1969232/allowed-characters-in-cookies">arbitrary characters in cookie</a> 를 사용할 수 없습니다.
UTF-8 문자는 UTF-8로 인코딩해야 합니다.
인코딩시 <code class="docutils literal"><span class="pre">xitrum.utill.UrlSafeBase64</span></code> 또는 <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri</span></code> 가 사용가능합니다.</p>
<p>쓰기예제:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.util.CharsetUtil
import xitrum.util.UrlSafeBase64

val value   = &quot;&quot;&quot;{&quot;identity&quot;:&quot;example@gmail.com&quot;,&quot;first_name&quot;:&quot;Alexander&quot;}&quot;&quot;&quot;
val encoded = UrlSafeBase64.noPaddingEncode(value.getBytes(CharsetUtil.UTF_8))
val cookie  = new DefaultCookie(&quot;profile&quot;, encoded)
responseCookies.append(cookie)
</pre></div>
</div>
<p>읽기예제:</p>
<div class="highlight-python"><div class="highlight"><pre>requestCookies.get(&quot;profile&quot;).foreach { encoded =&gt;
  UrlSafeBase64.autoPaddingDecode(encoded).foreach { bytes =&gt;
    val value = new String(bytes, CharsetUtil.UTF_8)
    println(&quot;profile: &quot; + value)
  }
}
</pre></div>
</div>
<p>세션
&#8212;</p>
<p>세션의 저장, 복원, 암호화 등은 Xitrum에 의해 자동화 되므로 신경쓰지 않아도 됩니다.</p>
<p>액션내에서、 <code class="docutils literal"><span class="pre">session</span></code> 은 <code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Any]</span></code> 의 인스턴스 이고 <code class="docutils literal"><span class="pre">session</span></code> 은 반드시 직렬화 가능해야 합니다.</p>
<p>로그인시, 사용자 이름을 세션에 저장하는 예:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">session</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">userId</span>
</pre></div>
</div>
<p>사용자의 로그인 여부를 판단하려면, 세션에 사용자이름 항목이 있는지 확인하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre>if (session.isDefinedAt(&quot;userId&quot;)) println(&quot;This user has logged in&quot;)
</pre></div>
</div>
<p>사용자의 ID를 저장하여 매번 접근할때마다 데이터베이스에서 사용자를 검색하는것은 매우 바람직합니다.
사용자의 정보변경을 알 수 있기 때문입니다.(권한 및 인증을 포함하여)</p>
</div>
<div class="section" id="session-clear">
<h3>session.clear()<a class="headerlink" href="#session-clear" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="http://guides.rubyonrails.org/security.html#session-fixation">One line of code will protect you from session fixation</a>.</p>
<p>session fixation 은 위의 항목을 참고하세요. session fixation 공격을 방지하기 위해
사용자의 로그인시 <code class="docutils literal"><span class="pre">session.clear()</span></code> 을 호출합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;login&quot;)
class LoginAction extends Action {
  def execute() {
    ...
    session.clear()  // Reset first before doing anything else with the session
    session(&quot;userId&quot;) = userId
  }
}
</pre></div>
</div>
<p>로그아웃시에도 <code class="docutils literal"><span class="pre">session.clear()</span></code> 을 호출합니다.</p>
</div>
<div class="section" id="sessionvar">
<h3>SessionVar<a class="headerlink" href="#sessionvar" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">RequestVar</span></code> 와 마찬가지로 SessionVar는 조금더 안전한 방법을 제공합니다.
예를들어, 사용자 로그인후 사용자이름을 세션에 저장할 수 있습니다.</p>
<p>SessionVar의 선언:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.SessionVar

object SVar {
  object username extends SessionVar[String]
}
</pre></div>
</div>
<p>로그인 성공후:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SVar</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
</pre></div>
</div>
<p>유저이름 표시:</p>
<div class="highlight-python"><div class="highlight"><pre>if (SVar.username.isDefined)
  &lt;em&gt;{SVar.username.get}&lt;/em&gt;
else
  &lt;a href={url[LoginAction]}&gt;Login&lt;/a&gt;
</pre></div>
</div>
<ul class="simple">
<li>SessionVar 삭제: <code class="docutils literal"><span class="pre">SVar.username.remove()</span></code></li>
<li>모든 세션 초기화: <code class="docutils literal"><span class="pre">session.clear()</span></code></li>
</ul>
</div>
<div class="section" id="id5">
<h3>세션 스토어<a class="headerlink" href="#id5" title="제목 주소">¶</a></h3>
<p>Xitrum 은 3가지의 세션 스토어를 제공합니다.
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>
원하는 방향대로 세션을 수정할 수 있습니다.</p>
<p>CookieSessionStore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Store sessions on client side</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">xitrum</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">CookieSessionStore</span>
</pre></div>
</div>
<p>LruSessionStore:</p>
<div class="highlight-python"><div class="highlight"><pre># Simple in-memory server side session store
store {
  &quot;xitrum.local.LruSessionStore&quot; {
    maxElems = 10000
  }
}
</pre></div>
</div>
<p>클러스터 내에서 여러 서버를 사용하게 된다면、<a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast</a> 를 클러스터간 세션 공유 저장소로 사용할 수 있습니다.</p>
<p>CookieSessionStore 이나 Hazelcast 를 세션저장용으로 사용한다면, 세션에 사용되는 데이터는 직렬화가 가능해야 합니다.
만약、 직렬화가 불가능한 데이터일 경우에는 LruSessionStore 를 사용하세요.
LruSessionStore를 사용하여 여러 서버를 사용하게 된다면, &#8220;sticky sessions&#8221; 이 가능한 로드밸런서를 사용해야 합니다.</p>
<p>일반적으로, 위에 언급된 기본 세션 저장소면 충분히 구현이 가능하지만, 특별한 세션 저장소를 직접 구축하려면
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/scope/session/SessionStore.scala">SessionStore</a>
또는
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/scope/session/ServerSessionStore.scala">ServerSessionStore</a>
을 상속받아 구현하여야 합니다.</p>
<p>설정방법은 다음의 두가지 형식이 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">store</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">StoreClassName</span>
</pre></div>
</div>
<p>또는:</p>
<div class="highlight-python"><div class="highlight"><pre>store {
  &quot;my.session.StoreClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>세션은 클라이언트에 저장하는것이 확장에 도움이 됩니다.
（직렬화가 가능한 <a class="reference external" href="http://stackoverflow.com/questions/640938/what-is-the-maximum-size-of-a-web-browsers-cookies-key">4KB보다 작은</a>）.
서버측(메모리 혹은 데이터베이스)에는 필요할때에만 저장하세요.</p>
<p>참고:
<a class="reference external" href="http://www.technicalinfo.net/papers/WebBasedSessionManagement.html">Web Based Session Management - Best practices in managing HTTP-based client sessions</a>.</p>
</div>
<div class="section" id="id6">
<h3>클라이언트 세션저장과 서버 세션저장<a class="headerlink" href="#id6" title="제목 주소">¶</a></h3>
<p>두가지 종류의 세션 저장이 가능:</p>
<ul class="simple">
<li>클라이언트에만 저장</li>
<li>클라이언트 + 서버 사용:</li>
</ul>
<p>클라이언트만 사용:</p>
<ul class="simple">
<li>세션데이터는 암호화된 쿠키로 클라이언트에 저장됩니다.</li>
<li>서버는 어떠한 데이터도 저장할 필요가 없습니다.</li>
<li>요청이 발생하면 서버는 복호화 해서 사용합니다.</li>
</ul>
<p>클라이언트 + 서버 사용:</p>
<ul class="simple">
<li>세션은 두가지의 정보가 있습니다: 세션ID 와 세션데이터.</li>
<li>서버는 lookup table에서 데이터를 찾는것처럼 세션을 저장합니다.</li>
<li>ID는 암호화 되어 클라이언트에 저장됩니다.</li>
<li>요청이 발생하면, 서버는 아이디를 복호화 하여 데이터를 찾게됩니다.</li>
<li>신용카드처럼, ID만 저장되고 금액은 저장되지 않는것과 같습니다.</li>
</ul>
<p>위 두가지 경우에 클라이언트는 반드시 쿠키를 저장하고
(암호화된 데이터 vs 암호화된 ID). &#8220;Store sessions at server side&#8221; 가 의미하는것은 서버측에서 데이터가 저장되는것만을 의미합니다.</p>
<div class="section" id="object-vs-val">
<h4>object vs. val<a class="headerlink" href="#object-vs-val" title="제목 주소">¶</a></h4>
<p><code class="docutils literal"><span class="pre">val</span></code> 대신에 <code class="docutils literal"><span class="pre">object</span></code> 를 사용하세요.</p>
<p><strong>아래와 같이 사용하지 마세요</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre>object RVar {
  val title    = new RequestVar[String]
  val category = new RequestVar[String]
}

object SVar {
  val username = new SessionVar[String]
  val isAdmin  = new SessionVar[Boolean]
}
</pre></div>
</div>
<p>위의 코드는 컴파일은 되지만, 실행되지 않습니다. 왜냐하면 &#8220;Vars&#8221;는 내부적으로 조회시에 클래스 이름이 사용됩니다.
<code class="docutils literal"><span class="pre">title</span></code>, <code class="docutils literal"><span class="pre">category</span></code>, <code class="docutils literal"><span class="pre">val</span></code> 을 사용하는 경우 &#8220;xitrum.RequestVar&#8221; 라는 클래스 이름으로 사용됩니다.
<code class="docutils literal"><span class="pre">username</span></code> 과 <code class="docutils literal"><span class="pre">isAdmin</span></code> 도 마찬가지 입니다.</p>
</div>
</div>
</div>
<span id="document-validation"></span><p>검증
===</p>
<p>Xitrum은 클라이언트 검증을 위해 <a class="reference external" href="http://bassistance.de/jquery-plugins/jquery-plugin-validation/">jQuery Validation plugin</a>
내포하고 있고, 서버 검증을 위해 핼퍼를 제공합니다.</p>
<div class="section" id="id1">
<h2>기본 검증<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p><code class="docutils literal"><span class="pre">xitrum.validator</span></code> 패키지에 검증기를 제공합니다.
다음과 같은 메소드를 가지고 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre>check(value): Boolean
message(name, value): Option[String]
exception(name, value)
</pre></div>
</div>
<p>검증을 통과 하지 못하면, <code class="docutils literal"><span class="pre">message</span></code> 는 <code class="docutils literal"><span class="pre">Some(error</span> <span class="pre">message)</span></code> 를 반환하고,
<code class="docutils literal"><span class="pre">exception</span></code> 은 <code class="docutils literal"><span class="pre">xitrum.exception.InvalidInput(error</span> <span class="pre">message)</span></code> 를 호출합니다.</p>
<p>어디서든지, 검증기를 사용할 수 있습니다.</p>
<p>Action 예제:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.validator.Required

@POST(&quot;articles&quot;)
class CreateArticle {
  def execute() {
    val title = param(&quot;tite&quot;)
    val body  = param(&quot;body&quot;)
    Required.exception(&quot;Title&quot;, title)
    Required.exception(&quot;Body&quot;,  body)

    // Do with the valid title and body...
  }
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">try</span></code> 、 <code class="docutils literal"><span class="pre">catch</span></code> 를 사용하지 않은 구문에서 검증을 통과하지 못하면,
xitrum은 자동으로 예외를 탐지해서 클라이언트로 에러메세지를 전송합니다.
이것은 클라이언트에서 검증을 사용하거나 웹 APIs를 작성할때 도움이 됩니다.</p>
<p>Model 예제:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.validator.Required

case class Article(id: Int = 0, title: String = &quot;&quot;, body: String = &quot;&quot;) {
  def isValid           = Required.check(title)   &amp;&amp;     Required.check(body)
  def validationMessage = Required.message(title) orElse Required.message(body)
}
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum/tree/master/src/main/scala/xitrum/validator">xitrum.validator 패키지에는</a>
모든 종류의 기본 검증기 리스트가 있습니다.</p>
</div>
<div class="section" id="id2">
<h2>검증기 수정하기<a class="headerlink" href="#id2" title="제목 주소">¶</a></h2>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/validator/Validator.scala">xitrum.validator.Validator</a> 를 확장할때
<code class="docutils literal"><span class="pre">check</span></code> 나 <code class="docutils literal"><span class="pre">message</span></code> 메소드만 확장하면 됩니다.</p>
<p>또한, <a class="reference external" href="http://commons.apache.org/proper/commons-validator/">Commons Validator</a> 를 사용해도 됩니다.</p>
</div>
<span id="document-upload"></span><div class="section" id="id1">
<h2>파일 업로드<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="index.html#document-scopes"><em>스코프</em></a> 를 참고하세요.</p>
<p>업로드 폼에서 <code class="docutils literal"><span class="pre">enctype</span></code> 를 <code class="docutils literal"><span class="pre">multipart/form-data</span></code> 으로 설정합니다.</p>
<p>MyUpload.scalate:</p>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[MyUpload]} enctype=&quot;multipart/form-data&quot;)
  != antiCsrfInput

  label Please select a file:
  input(type=&quot;file&quot; name=&quot;myFile&quot;)

  button(type=&quot;submit&quot;) Upload
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">MyUpload</span></code> 액션:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.handler.codec.http.multipart.FileUpload

val myFile = param[FileUpload](&quot;myFile&quot;)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">myFile</span></code>  <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/multipart/FileUpload.html">FileUpload</a>
의 인스턴스 입니다. 이 메소드를 이용하여 파일이름을 가져오거나, 파일의 이동등을 할 수 있습니다.</p>
<p>작은파일 (16KB이하)는 메모리에 저장됩니다. 대용량 파일은 시스템의 임시 폴더에 저장됩니다(혹은 xitrum.conf에 정의된 <code class="docutils literal"><span class="pre">xitrum.request.tmpUploadDir</span></code>).
그리고 나서, 커넥션이 닫히거나 응답이 전송되면 자동으로 삭제됩니다.</p>
<div class="section" id="ajax">
<h3>Ajax 스타일 업로드<a class="headerlink" href="#ajax" title="제목 주소">¶</a></h3>
<p>많은 자바스크립트 라이브러리는 Ajax 스타일의 업로드를 지원합니다. 숨겨진 iframe이나 플래시등으로 <code class="docutils literal"><span class="pre">multipart/form-data</span></code> 를 서버로 전송합니다.
폼의 요청 파라미터가 전송될때, 어떤 라이브러리를 사용했는지는 Xitrum 억세스 로그를 확인하면 알 수 있습니다.</p>
</div>
</div>
<span id="document-filter"></span><div class="section" id="id1">
<h2>액션 필터<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<div class="section" id="before">
<h3>Before 필터<a class="headerlink" href="#before" title="제목 주소">¶</a></h3>
<p>Before필터는 액션이 수행되기 전에 수행됩니다
만약 Before가 무언가를 응답한다면, 필터 이후의 어떠한 액션도 수행되지 않습니다</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;before_filter&quot;)
class MyAction extends Action {
  beforeFilter {
    log.info(&quot;I run therefore I am&quot;)
  }

  // This method is run after the above filters
  def execute() {
    respondInlineView(&quot;Before filters should have been run, please check the log&quot;)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="after">
<h3>After필터<a class="headerlink" href="#after" title="제목 주소">¶</a></h3>
<p>After필터는 액션이 수행되고 난 후에 수행됩니다
함수들은 입력값이 없으면, 리턴값은 무시됩니다</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;after_filter&quot;)
class MyAction extends Action {
  afterFilter {
    log.info(&quot;Run at &quot; + System.currentTimeMillis())
  }

  def execute() {
    respondText(&quot;After filter should have been run, please check the log&quot;)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="around">
<h3>Around필터<a class="headerlink" href="#around" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;around_filter&quot;)
class MyAction extends Action {
  aroundFilter { action =&gt;
    val begin = System.currentTimeMillis()
    action()
    val end   = System.currentTimeMillis()
    val dt    = end - begin
    log.info(s&quot;アクション実行時間: $dt [ms]&quot;)
  }

  def execute() {
    respondText(&quot;Around filter should have been run, please check the log&quot;)
  }
}
</pre></div>
</div>
<p>Around필터가 여러개 있을때, 외부, 내부구성에 중첩됩니다</p>
</div>
<div class="section" id="id2">
<h3>필터의 수행 순서<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<ul class="simple">
<li>Before 필터 -&gt; around 필터 -&gt; after 필터.</li>
<li>몇몇 before 필터가 false를 반환하면 나머지 필터가 실행되지 않습니다.</li>
<li>Around 필터가 실행되면 모든 after 필터가 실행됩니다.</li>
<li>외부 around filter 필터가``action`` 인수를 호출하지 않으면 내부의 around 필터가 실행되지 않습니다.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>before1 -true-&gt; before2 -true-&gt; +--------------------+ --&gt; after1 --&gt; after2
                                | around1 (1 of 2)   |
                                |   around2 (1 of 2) |
                                |     action         |
                                |   around2 (2 of 2) |
                                | around1 (2 of 2)   |
                                +--------------------+
</pre></div>
</div>
</div>
</div>
<span id="document-cache"></span><div class="section" id="id1">
<h2>서버측 캐시<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="index.html#document-cluster"><em>클러스터링</em></a> 챕터를 참고하세요</p>
<p>Xitrum은 빠른 응답을 위해, 클라이언트 측과 서버 측의 광범위한 캐싱 기능을 제공합니다.
웹서버 레이어는 작은 파일은 메모리에 캐시 된 큰 파일은 NIO의 제로 복사를 사용하여 전송됩니다.
Xitrum 정적 파일 전송 속도는`Nginx와 동등 &lt;<a class="reference external" href="https://gist.github.com/3293596">https://gist.github.com/3293596</a>&gt;`_ 합니다
Web 프레임 워크 레이어는 Rails 스타일로 페이지 나 액션 객체를 캐시 할 수 있습니다.
<a class="reference external" href="http://code.google.com/speed/page-speed/docs/rules_intro.html">All Google &#8216;s best practices (영문)</a>
에서와 같이 조건부 GET 요청은 클라이언트 사이드에서 캐시됩니다.</p>
<p>동적 콘텐츠에 대해서는 만약 파일이 생성 된 이후 변경되지 않는 경우(static file과 같이) 클라이언트에 적극적으로 캐시하도록
헤더를 설정해야합니다.
이 경우에는``setClientCacheAggressively ()``를 액션에서 호출하여 얻을 수 있습니다.</p>
<p>클라이언트에 캐시시키고 싶지 않은 경우에는, <a href="#id2"><span class="problematic" id="id3">``</span></a>setNoClientCache ()``를 액션에서 호출하여 얻을 수 있습니다.</p>
<p>서버 측 캐시에 대해서는 다음 예제에 자세히 설명합니다.</p>
<div class="section" id="id4">
<h3>캐시페이지 혹은 액션<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{GET, CacheActionMinute, CachePageMinute}

@GET(&quot;articles&quot;)
@CachePageMinute(1)
class ArticlesIndex extends Action {
  def execute() {
    ...
  }
}

@GET(&quot;articles/:id&quot;)
@CacheActionMinute(1)
class ArticlesShow extends Action {
  def execute() {
    ...
  }
}
</pre></div>
</div>
<p>&#8220;page cache&#8221;와 &#8220;acation cache&#8221; 개념은 <a href="#id5"><span class="problematic" id="id6">`</span></a>Ruby on Rails &lt;<a class="reference external" href="http://guides.rubyonrails.org/caching_with_rails.html">http://guides.rubyonrails.org/caching_with_rails.html</a>&gt;`_를 참고하고 있습니다.</p>
<p>요청 처리 프로세스의 순서는 다음과 같습니다.</p>
<ol class="arabic simple">
<li>요청 -&gt; (2) Before 필터 -&gt; (3) 액션의 excute 메소드 -&gt; (4) 응답</li>
</ol>
<p>처음 요청시 Xitrum는 응답을 지정된 기간 동안 캐시합니다.
<code class="docutils literal"><span class="pre">&#64;CachePageMinute</span> <span class="pre">(1)``과``&#64;CacheActionMinute</span> <span class="pre">(1)</span></code> 은 1 분 동안 캐시하는 것을 의미합니다.
Xitrum는 응답 상태가 &#8220;200 OK&#8221;인 경우에만 캐시합니다.
예를들어, 응답 상태가 &#8220;500 Internal Server Error&#8221;또는 &#8220;302 Found&#8221;(리디렉션)이되는 응답은 캐시되지 않습니다.</p>
<p>동일한 작업에 대한 동일 요청에는 만약 캐시 된 응답이 지정된 기간내에 있을 경우
Xitrum은 즉시 캐시 된 응답을 반환합니다 :</p>
<ul class="simple">
<li>페이지 캐시의 경우 처리 과정은 (1) -&gt; (4)입니다.</li>
<li>액션 캐시의 경우 (1) -&gt; (2) -&gt; (4) 또는 Before 필터가 &#8220;false&#8221;를 반환 한 경우 (1) -&gt; (2)입니다.</li>
</ul>
<p>차이점은: page 캐시는 Before 필터를 수행하지 않습니다.</p>
<p>일반적으로 페이지 캐시는 모든 사용자에게 공통된 반응의 경우에 사용합니다.
액션 캐시는 Before 필터를 통해 예를 들어 사용자의 로그인 상태 체크 등을 통해 캐시 된 응답을 &#8220;가드&#8221; 하는 경우에 사용합니다 :</p>
<ul class="simple">
<li>로그인 한 경우 캐시 된 응답에 액세스 할 수 있습니다.</li>
<li>로그인하지 않은 경우 로그인 페이지로 리다이렉트 합니다.</li>
</ul>
</div>
<div class="section" id="id7">
<h3>캐시 오브젝트<a class="headerlink" href="#id7" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="http://xitrum-framework.github.io/api/3.17/index.html#xitrum.Cache">xitrum.Cache</a> 을 대신하여
<code class="docutils literal"><span class="pre">xitrum.Config.xitrum.cache</span></code> 사용할 수 있습니다.</p>
<p>명시적으로 TTL을 설정하지 않은 경우:</p>
<ul class="simple">
<li>put(key, value)</li>
</ul>
<p>유효기간을 설정한 경우:</p>
<ul class="simple">
<li>putSecond(key, value, seconds)</li>
<li>putMinute(key, value, minutes)</li>
<li>putHour(key, value, hours)</li>
<li>putDay(key, value, days)</li>
</ul>
<p>존재하지 않을 경우만 캐시하는 방법:</p>
<ul class="simple">
<li>putIfAbsent(key, value)</li>
<li>putIfAbsentSecond(key, value, seconds)</li>
<li>putIfAbsentMinute(key, value, minutes)</li>
<li>putIfAbsentHour(key, value, hours)</li>
<li>putIfAbsentDay(key, value, days)</li>
</ul>
</div>
<div class="section" id="id8">
<h3>캐시 제거<a class="headerlink" href="#id8" title="제목 주소">¶</a></h3>
<p>페이지나 액션의 캐시 제거:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">removeAction</span><span class="p">[</span><span class="n">MyAction</span><span class="p">]</span>
</pre></div>
</div>
<p>오브젝트 캐시 제거:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>prefix로 시작되는 키들을 모두 제거:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">removePrefix</span><span class="p">(</span><span class="n">keyPrefix</span><span class="p">)</span>
</pre></div>
</div>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a>removePrefix``는 prefix를 사용하여 계층적 캐쉬를 구축 할 수 있습니다.
예를 들면, 기사와 관련된 요소를 캐쉬하고 싶은 경우, 기사가 변경되었을 때 관련 캐쉬는 다음과 같이 정리할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Config.xitrum.cache

// prefix를 이용하여 캐쉬
val prefix = &quot;articles/&quot; + article.id
cache.put(prefix + &quot;/likes&quot;, likes)
cache.put(prefix + &quot;/comments&quot;, comments)

// 필요시, 기사와 관련된 캐쉬를 전부 삭제할 수 있습니다.
cache.remove(prefix)
</pre></div>
</div>
<p>설정
&#8212;</p>
<p>Xitrum 캐시 기능은 캐시 엔진에 의해 제공됩니다. 캐시 엔진은 프로젝트의 필요에 따라 취사선택할 수 있습니다.
캐시 엔진 설정은 <a href="#id11"><span class="problematic" id="id12">`</span></a>config / xitrum.conf &lt;<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf</a>&gt;`_에서 사용하는 엔진에 따라 다음 두 가지 설명 방식으로 설정할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cache</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">EngineClassName</span>
</pre></div>
</div>
<p>또는:</p>
<div class="highlight-python"><div class="highlight"><pre>cache {
  &quot;my.cache.EngineClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>Xitrum은 이것을 제공합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>cache {
  # Simple in-memory cache
  &quot;xitrum.local.LruCache&quot; {
    maxElems = 10000
  }
}
</pre></div>
</div>
<p>만약 클러스터링 된 서버를 사용하는 경우 캐쉬 엔진에는`Hazelcast &lt;<a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">https://github.com/xitrum-framework/xitrum-hazelcast</a>&gt;`_를 사용할 수 있습니다.</p>
<p>자체 캐쉬 엔진을 사용하는 경우,``xitrum.Cache``의`interface &lt;<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Cache.scala">https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Cache.scala</a>&gt; <a href="#id13"><span class="problematic" id="id14">`</span></a>_를 구현합니다.</p>
</div>
<div class="section" id="id15">
<h3>캐쉬의 동작원리<a class="headerlink" href="#id15" title="제목 주소">¶</a></h3>
<p>Inbound:</p>
<div class="highlight-python"><div class="highlight"><pre>               액션응답
               캐쉬됨
request        캐쉬가 존재?
-------------------------+---------------NO---------------&gt;
                         |
&lt;---------YES------------+
  캐쉬에서 응답
</pre></div>
</div>
<p>Outbound:</p>
<div class="highlight-python"><div class="highlight"><pre>               액션응답
               캐쉬됨
               캐쉬가 존재하지 않음? 　          response
&lt;---------NO-------------+---------------------------------
                         |
&lt;---------YES------------+
  캐쉬를 저장함
</pre></div>
</div>
</div>
<div class="section" id="xitrum-util-locallrucache">
<h3>xitrum.util.LocalLruCache<a class="headerlink" href="#xitrum-util-locallrucache" title="제목 주소">¶</a></h3>
<p>위에서 언급 한 캐쉬 엔진은 시스템 전체가 공유하는 캐시입니다.
만약 작은 간단한 캐쉬 엔진 만 필요한 경우``xitrum.util.LocalLruCache``을 사용합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.LocalLruCache

// LRU (Least Recently Used) 캐쉬는 1000개만 저장합니다
// 키와 저장값은 String 타입으로 사용됩니다
val cache = LocalLruCache[String, String](1000)
</pre></div>
</div>
<p>반환된 <code class="docutils literal"><span class="pre">캐쉬</span></code> 는 <a class="reference external" href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html">java.util.LinkedHashMap</a> 인스턴스이기 때문에 <code class="docutils literal"><span class="pre">LinkedHashMap</span></code> 방법을 사용하여 처리 할 수 있습니다.</p>
</div>
</div>
<span id="document-i18n"></span><div class="section" id="i18n">
<h2>I18n<a class="headerlink" href="#i18n" title="제목 주소">¶</a></h2>
<p>GNU gettext 가 사용됩니.gettext는 다른 국제화 방법과는 다르게、복수형을 지원합니다.</p>
<img alt="http://poedit.net/images/home_image2-big.png" src="http://poedit.net/images/home_image2-big.png" />
<div class="section" id="id1">
<h3>소스코드에 국제화 메세지 작성<a class="headerlink" href="#id1" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.Action</span></code> 은 <code class="docutils literal"><span class="pre">xitrum.I18n</span></code> 확장했으며, 다음의 메소드가 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span><span class="p">(</span><span class="s">&quot;Message&quot;</span><span class="p">)</span>
<span class="n">tc</span><span class="p">(</span><span class="s">&quot;Context&quot;</span><span class="p">,</span> <span class="s">&quot;Message&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>action 안에서나 혹은 액션에서 호출 할 수 있습니다.
model과 같은 곳에서의 사용은、 현재의 액션에서 <code class="docutils literal"><span class="pre">t</span></code> 나 <code class="docutils literal"><span class="pre">tc</span></code> 를 호출하여 넘겨줘야 합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>// In an action
respondText(MyModel.hello(this))

// In the model
import xitrum.I18n
object MyModel {
  def hello(i18n: I18n) = i18n.t(&quot;Hello World&quot;)
}
</pre></div>
</div>
</div>
<div class="section" id="pot">
<h3>pot에 메세지 추출하기<a class="headerlink" href="#pot" title="제목 주소">¶</a></h3>
<p>프로젝트 루트에 빈i18n.pot 파일을 생성하여, 전체 프로젝트를 다시 컴파일 하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt clean
rm i18n.pot
touch i18n.pot
sbt/sbt compile
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span></code> 는 모든 .class파일을 삭제하고, 전체를 다시 컴파일 합니다.
<code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span></code> 명령은、SBT가 모든 <a class="reference internal" href="index.html#document-deps"><em>의존된</em></a> 라이브러리를 다운받기 때문에
<code class="docutils literal"><span class="pre">find</span> <span class="pre">target</span> <span class="pre">-name</span> <span class="pre">*.class</span> <span class="pre">-delete</span></code> 명령이 조금 더 빠르지만,
<code class="docutils literal"><span class="pre">target</span></code> 내부의 .class 파일을 삭제하는것은 동일합니다.</p>
<p>재컴파일후에, i18n.pot는 소스코드로 부터 추출된 gettext 메세지를 채웁니다.
마법같은 이 동작은 <a class="reference external" href="http://www.scala-lang.org/node/140">Scala compiler plugin technique</a> 에 기술되어 있습니다.</p>
<p>한가지 이 메소드의 주의점은 gettext는 Scala 소스 코드로부터 메세지를 추출합니다. 만약 자바 파일을 사용한다면, 다음과 같이 <code class="docutils literal"><span class="pre">xgettext</span></code>
커맨드 라인을 사용하여야 합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>xgettext -kt -ktc:1c,2 -ktn:1,2 -ktcn:1c,2,3 -o i18n_java.pot --from-code=UTF-8 $(find src/main/java -name &quot;*.java&quot;)
</pre></div>
</div>
<p>그러고 나서, 수동으로 i18n_java.pot 파일과 i18n.pot파일을 병합해야 합니다.</p>
</div>
<div class="section" id="po">
<h3>po 파일 저장위치<a class="headerlink" href="#po" title="제목 주소">¶</a></h3>
<p>i18n.pot은 임시 파일입니다. 파일들을 &lt;language&gt;.po 로 복사하여 번역해야 합니다.</p>
<p>Xitrum은 클래스 패스상의 <code class="docutils literal"><span class="pre">i18n</span></code> 디렉토리를 모니터링 합니다.
만약 런타임시 디렉토리 상의 &lt;language&gt;.po 파일이 변경되거나 추가된다면,
Xitrum은 자동으로 &lt;language&gt;.po 파일들을 다시 로드합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>src
  main
    scala
    view
    resources
      i18n
        ja.po
        vi.po
        ...
</pre></div>
</div>
<p>po 파일을 수정하기 위해서는 <a class="reference external" href="http://www.poedit.net/">Poedit</a> 와 같은 툴을 사용하면 됩니다.
툴을 사용하여 새로운 pot 파일을 기존의 po 파일에 추가 할수 있습니다.</p>
<p>po 파일들은 여러 JAR파일들에 패키징할 수 있고, Xitrum은 실행시에 자동으로 병합합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>mylib.jar
  i18n
    ja.po
    vi.po
        ...

another.jar
  i18n
    ja.po
    vi.po
        ...
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>언어설정<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<ul class="simple">
<li>브라우저의 요청 헤더의 <code class="docutils literal"><span class="pre">Accept-Language``에서</span> <span class="pre">언어</span> <span class="pre">셋을</span> <span class="pre">가져오려면,</span>
<span class="pre">``browserLanguages</span></code> 를 호출하면 됩니다. 결과는 브라우저의 우선순위에 따라 정렬됩니다.</li>
<li>기본 언어는 &#8220;en&#8221; 입니다. 현재의 언어로 세팅하기 위해서는, 예를 들어 일어일 경우 <code class="docutils literal"><span class="pre">language</span> <span class="pre">=</span> <span class="pre">&quot;ja&quot;</span></code> 로 하면 됩니다.</li>
<li>가장 적절한 언어를 리소스에서 찾아 자동세팅을 위해서는
<code class="docutils literal"><span class="pre">autosetLanguage(resourceLanguages)</span></code> 을 호출하면 됩니다.
<code class="docutils literal"><span class="pre">resourceLanguages</span></code> 는 <code class="docutils literal"><span class="pre">resources/i18n</span></code> 디렉토리와 JAR파일들의 가능한 언어들의 리스트를 가지고 있습니다.
만약, 적절한 언어가 없을경우 기본언어인 &#8220;en&#8221;으로 설정합니다.</li>
<li>현재의 언어셋을 확인하려면 <code class="docutils literal"><span class="pre">language</span></code> 를 사용하면 됩니다.</li>
</ul>
<p>일반적으로, 액션의 before 필터에서 언어를 세팅합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>beforeFilter {
  val lango: Option[String] = yourMethodToGetUserPreferenceLanguageInSession()
  lango match {
    case None       =&gt; autosetLanguage(&quot;ja&quot;, &quot;vi&quot;)
    case Some(lang) =&gt; language = lang
  }
  true
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>검증 메세지<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>jQuery Validation 플러그인은 <a class="reference external" href="https://github.com/jzaefferer/jquery-validation/tree/master/src/localization">i18n error messages</a>
제공합니다
Xitrum은 자동으로 현재의 언어에 상응하는 메세지를 가져옵니다.</p>
<p>서버의 기본 검증인 <code class="docutils literal"><span class="pre">xitrum.validator</span></code> 패키지 또한,
Xitrum은 제공하고 있습니다.</p>
</div>
<div class="section" id="id4">
<h3>복수형<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tn</span><span class="p">(</span><span class="s">&quot;Message&quot;</span><span class="p">,</span> <span class="s">&quot;Plural form&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">tcn</span><span class="p">(</span><span class="s">&quot;Context&quot;</span><span class="p">,</span> <span class="s">&quot;Message&quot;</span><span class="p">,</span> <span class="s">&quot;Plural form&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Xitrum은 다음에 정의된 복수형만을 사용합니다:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.gnu.org/software/gettext/manual/html_node/Plural-forms.html#Plural-forms">What are plural forms</a></li>
<li><a class="reference external" href="http://www.gnu.org/software/gettext/manual/html_node/Translating-plural-forms.html#Translating-plural-forms">Translating plural forms</a></li>
</ul>
<p>복수형은 다음중 하나를 사용해야 합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>nplurals=1; plural=0
nplurals=2; plural=n != 1
nplurals=2; plural=n&gt;1
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2
nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2
nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 &gt; 0 &amp;&amp; n%100 &lt; 20)) ? 1 : 2
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=3; plural=(n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2
nplurals=3; plural=n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=4; plural=n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>날짜와 시간 포멧<a class="headerlink" href="#id5" title="제목 주소">¶</a></h3>
<p>만약 Scalate 템플릿 엔진을 사용한다면, 날짜와 시간 포멧은 현재 액션의 언어 포멧을 따르게 됩니다.</p>
<p>다른 포멧을 사용하고자 하는 경우:</p>
<div class="highlight-python"><div class="highlight"><pre>import java.text.{DateFormat, NumberFormat}

val myDateFormat   = ...
val myNumberFormat = ...
val options        = Map(&quot;date&quot; -&gt; myDateFormat, &quot;number&quot; -&gt; myNumberFormat)
respondView(options)
</pre></div>
</div>
</div>
</div>
<span id="document-log"></span><div class="section" id="id1">
<h2>로그<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<div class="section" id="xitrum-log">
<h3>xitrum.Log 오브젝트를 바로 사용하기<a class="headerlink" href="#xitrum-log" title="제목 주소">¶</a></h3>
<p>어디서든지, 다음과 같이 직접 호출할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;My debug msg&quot;</span><span class="p">)</span>
<span class="n">xitrum</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;My info msg&quot;</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="xitrum-log-trait">
<h3>xitrum.Log trait 사용하기<a class="headerlink" href="#xitrum-log-trait" title="제목 주소">¶</a></h3>
<p>만약, 로그가 사용된 위치(클래스)를 알고 싶다면, xitrum.log를 확장하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre>package my_package
import xitrum.Log

object MyModel extends Log {
  log.debug(&quot;My debug msg&quot;)
  log.info(&quot;My info msg&quot;)
  ...
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">log/xitrum.log</span></code> 파일에서  <code class="docutils literal"><span class="pre">MyModel</span></code> 로 부터 나오는 로그 메세지를 확인할 수 있습니다</p>
<p>Xitrum 액션은 xitrum.Log를 확장하고 있어서, 어느 액션에서도 다음과 같이 사용할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>로깅하기 전에 로그레벨을 체크하지 않아도 됩니다<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.Log</span></code> 는 <a class="reference external" href="http://slf4s.org/">SLF4S</a> (<a class="reference external" href="http://slf4s.org/api/1.7.7/">API</a>) 를 바탕으로 합니다,
SLF4S <a class="reference external" href="http://www.slf4j.org/">SLF4J</a> 위에 구축되어 있습니다.</p>
<p>전통적으로, 로그 결과를 확인하기 전에 계산으로 인한 과도한 CPU사용을 방지하기 위해, 로그레벨을 체크하였지만
<a class="reference external" href="https://github.com/mattroberts297/slf4s/blob/master/src/main/scala/org/slf4s/Logger.scala">SLF4S의 자동체크</a> 기능이 있어서
일부러 체크 할 필요가 없습니다.</p>
<p>이전버전 (이 코드는 3.13 이후로는 동작하지 않습니다):</p>
<div class="highlight-python"><div class="highlight"><pre>if (log.isTraceEnabled) {
  val result = heavyCalculation()
  log.trace(&quot;Output: {}&quot;, result)
}
</pre></div>
</div>
<p>현재:</p>
<div class="highlight-python"><div class="highlight"><pre>log.trace(s&quot;Output: #{heavyCalculation()}&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>로그레벨 및 출력파일 조정<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<p>build.sbt 파일에 다음과 같은 라인이 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;ch.qos.logback&quot;</span> <span class="o">%</span> <span class="s">&quot;logback-classic&quot;</span> <span class="o">%</span> <span class="s">&quot;1.1.2&quot;</span>
</pre></div>
</div>
<p>이것의 의미는 <a class="reference external" href="http://logback.qos.ch/">Logback</a> 을 기본으로 사용한다는 뜻입니다.
Logback의 설정파일은  <code class="docutils literal"><span class="pre">config/logback.xml</span></code> 에 있습니다.</p>
<p>Logback을 <a class="reference external" href="http://www.slf4j.org/">SLF4J</a> 으로 교체 할 수도 있습니다.</p>
</div>
<div class="section" id="fluentd">
<h3>Fluentd 에 로그를 출력<a class="headerlink" href="#fluentd" title="제목 주소">¶</a></h3>
<p>매우 대중적인 <a class="reference external" href="http://www.fluentd.org/">Fluentd</a> 로그 수집장치가 있습니다.
Logback을 수정하여 로그를 Fluentd 서버로 전송(여러곳에서 전송된)할 수 있습니다.</p>
<p>먼저, <a class="reference external" href="https://github.com/sndyuk/logback-more-appenders">logback-more-appenders</a> 라이브러리를 추가합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>libraryDependencies += &quot;org.fluentd&quot; % &quot;fluent-logger&quot; % &quot;0.2.11&quot;

resolvers += &quot;Logback more appenders&quot; at &quot;http://sndyuk.github.com/maven&quot;

libraryDependencies += &quot;com.sndyuk&quot; % &quot;logback-more-appenders&quot; % &quot;1.1.0&quot;
</pre></div>
</div>
<p>그리고 <code class="docutils literal"><span class="pre">config/logback.xml</span></code> 파일을 수정합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>...

&lt;appender name=&quot;FLUENT&quot; class=&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;&gt;
  &lt;tag&gt;mytag&lt;/tag&gt;
  &lt;label&gt;mylabel&lt;/label&gt;
  &lt;remoteHost&gt;localhost&lt;/remoteHost&gt;
  &lt;port&gt;24224&lt;/port&gt;
  &lt;maxQueueSize&gt;20000&lt;/maxQueueSize&gt;  &lt;!-- Save to memory when remote server is down --&gt;
&lt;/appender&gt;

&lt;root level=&quot;DEBUG&quot;&gt;
  &lt;appender-ref ref=&quot;FLUENT&quot;/&gt;
  &lt;appender-ref ref=&quot;OTHER_APPENDER&quot;/&gt;
&lt;/root&gt;

...
</pre></div>
</div>
</div>
</div>
<span id="document-deploy"></span><div class="section" id="id1">
<h2>프로덕션 서버에 배포하기<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p>Xitrum을 직접 배포할수 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre>브라우저 ------ Xitrum 인스턴스
</pre></div>
</div>
<p>HAProxy와 같은 로드밸런서 뒤 혹은、Apache 의 Nginx와 같은 리버스 프록시에:</p>
<div class="highlight-python"><div class="highlight"><pre>브라우저 ------ 로드밸런서/리버스 프록시   -+---- Xitrum 인스턴스1
                                   +---- Xitrum 인스턴스2
</pre></div>
</div>
<div class="section" id="package">
<h3>Package 디렉토리<a class="headerlink" href="#package" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">xitrum-package</span></code> 를 실행하여 배포될 <code class="docutils literal"><span class="pre">target/xitrum</span></code> 디렉토리를 준비합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>target/xitrum
  config
    [config files]
  public
    [static public files]
  lib
    [dependencies and packaged project file]
  script
    runner
    runner.bat
    scalive
    scalive.jar
    scalive.bat
</pre></div>
</div>
</div>
<div class="section" id="xitrum-package">
<h3>사용자 정의 xitrum-package<a class="headerlink" href="#xitrum-package" title="제목 주소">¶</a></h3>
<p>기본적으로 <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">xitrum-package</span></code> 명령은 수정된 <code class="docutils literal"><span class="pre">config</span></code> 、 <code class="docutils literal"><span class="pre">public</span></code> 그리고 <code class="docutils literal"><span class="pre">script</span></code> 를 <code class="docutils literal"><span class="pre">target/xitrum</span></code> 복사합니다
복사할 파일이나 디렉토리를 추가하려면 <code class="docutils literal"><span class="pre">build.sbt</span></code> 파일을 수정하면 됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>XitrumPackage.copy(&quot;config&quot;, &quot;public, &quot;script&quot;, &quot;doc/README.txt&quot;, &quot;etc.&quot;)
</pre></div>
</div>
<p>자세한 내용은 <a class="reference external" href="https://github.com/xitrum-framework/xitrum-package">xitrum-package 사이트</a> 를 참조하세요.</p>
</div>
<div class="section" id="jvm-scala">
<h3>실행중인 JVM 프로세스에 Scala 콘솔 연결<a class="headerlink" href="#jvm-scala" title="제목 주소">¶</a></h3>
<p>프로덕션 환경에서도 특별한 준비없이 <a href="#id3"><span class="problematic" id="id4">`</span></a>Scalive &lt;<a class="reference external" href="https://github.com/xitrum-framework/scalive">https://github.com/xitrum-framework/scalive</a>&gt;`_를 사용하여
실행중인 JVM 프로세스에 대해 Scala 콘솔을 연결하고 디버깅을 할 수 있습니다.</p>
<p><code class="docutils literal"><span class="pre">script</span></code> 디렉토리에서 <code class="docutils literal"><span class="pre">scalive</span></code> 실행하면 됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>script
  runner
  runner.bat
  scalive
  scalive.jar
  scalive.bat
</pre></div>
</div>
</div>
<div class="section" id="oracle-jdk-centos">
<h3>Oracle JDK를 CentOS 나 우분투에 설차하기<a class="headerlink" href="#oracle-jdk-centos" title="제목 주소">¶</a></h3>
<p>여기에서는 Java를 설치하는 방법에 대한 간단한 가이드를 소개합니다.
패키지 관리자를 사용하여 Java를 설치할 수 있습니다.</p>
<p>현재 설치되어 있는 Java 확인:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --list java
</pre></div>
</div>
<p>출력예제:</p>
<div class="highlight-python"><div class="highlight"><pre>/usr/lib/jvm/jdk1.7.0_15/bin/java
/usr/lib/jvm/jdk1.7.0_25/bin/java
</pre></div>
</div>
<p>머신환경 확인 (32 bit 또는 64 bit):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">init</span>
</pre></div>
</div>
<p>출력예:</p>
<div class="highlight-python"><div class="highlight"><pre>/sbin/init: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x4efe732752ed9f8cc491de1c8a271eb7f4144a5c, stripped
</pre></div>
</div>
<p>JDK를 <a class="reference external" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">Oracle</a> 사이트에서 다운로드합니다.
브라우저를 통하지 않고 다운로드하려면 약간의 <a href="#id5"><span class="problematic" id="id6">`</span></a>트릭 &lt;<a class="reference external" href="http://stackoverflow.com/questions/10268583/how-to-automate-download-and-instalation-of-java-jdk-on-linux">http://stackoverflow.com/questions/10268583/how-to-automate-download-and-instalation-of-java-jdk-on-linux</a>&gt;`_이 필요합니다 :</p>
<div class="highlight-python"><div class="highlight"><pre>wget --no-cookies --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/7u45-b18/jdk-7u45-linux-x64.tar.gz&quot;
</pre></div>
</div>
<p>압축을 해제하고 이동합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>tar -xzvf jdk-7u45-linux-x64.tar.gz
sudo mv jdk1.7.0_45 /usr/lib/jvm/jdk1.7.0_45
</pre></div>
</div>
<p>명령을 등록합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/java&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javac&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javap&quot; &quot;javap&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javap&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javaws&quot; 1
</pre></div>
</div>
<p>인터랙티브 쉘에서 새 경로를 지정합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --config java
</pre></div>
</div>
<p>출력예제:</p>
<div class="highlight-python"><div class="highlight"><pre>There are 3 choices for the alternative java (providing /usr/bin/java).

  Selection    Path                               Priority   Status
------------------------------------------------------------
* 0            /usr/lib/jvm/jdk1.7.0_25/bin/java   50001     auto mode
  1            /usr/lib/jvm/jdk1.7.0_15/bin/java   50000     manual mode
  2            /usr/lib/jvm/jdk1.7.0_25/bin/java   50001     manual mode
  3            /usr/lib/jvm/jdk1.7.0_45/bin/java   1         manual mode

Press enter to keep the current choice[*], or type selection number: 3
update-alternatives: using /usr/lib/jvm/jdk1.7.0_45/bin/java to provide /usr/bin/java (java) in manual mode
</pre></div>
</div>
<p>버전 체크:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">java</span> <span class="o">-</span><span class="n">version</span>
</pre></div>
</div>
<p>출력예제:</p>
<div class="highlight-python"><div class="highlight"><pre>java version &quot;1.7.0_45&quot;
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
</pre></div>
</div>
<p>javac 등도 마찬가지로 합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --config javac
sudo update-alternatives --config javap
sudo update-alternatives --config javaws
</pre></div>
</div>
</div>
<div class="section" id="xitrum">
<h3>시스템이 구동될때 Xitrum을 시작하기<a class="headerlink" href="#xitrum" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">script</span> <span class="pre">/</span> <span class="pre">runner</span></code> (<a href="#id7"><span class="problematic" id="id8">*</span></a>nix 환경)과 <code class="docutils literal"><span class="pre">script</span> <span class="pre">/</span> <span class="pre">runner.bat</span></code> (Windows 환경)은 객체의``main`` 메소드를 실행하기위한 스크립트입니다. 프로덕션 환경에서는이 스크립트를 사용하여 Web 서버를 시작합니다 :</p>
<div class="highlight-python"><div class="highlight"><pre>script/runner quickstart.Boot
</pre></div>
</div>
<p><cite>JVM 설정 &lt;http://www.oracle.com/technetwork/java/hotspotfaq-138619.html&gt;`_을 수정하려면
``runner`</cite> (또는``runner.bat``)을 수정합니다.
또한``config / xitrum.conf`` 참조하십시오.</p>
<p>리눅스에서 시스템이 시작할때 백그라운드로 Xitrum이 구동되길 원한다면, 간단하게 <code class="docutils literal"><span class="pre">/etc/rc.local</span></code> 에 라인을 추가해도
됩니다:</p>
<div class="highlight-python"><div class="highlight"><pre>su - user_foo_bar -c /path/to/the/runner/script/above &amp;
</pre></div>
</div>
<p><a class="reference external" href="http://cr.yp.to/daemontools.html">daemontools</a> 는 또다른 방법입니다.
CentOS에 설치하는 방법은 <a class="reference external" href="http://whomwah.com/2008/11/04/installing-daemontools-on-centos5-x86_64/">설치방법</a> 을 참고하세요
또는 <a class="reference external" href="http://supervisord.org/">Supervisord</a> 도 있습니다</p>
<p><code class="docutils literal"><span class="pre">/etc/supervisord.conf</span></code> 예제:</p>
<div class="highlight-python"><div class="highlight"><pre>[program:my_app]
directory=/path/to/my_app
command=/path/to/my_app/script/runner quickstart.Boot
autostart=true
autorestart=true
startsecs=3
user=my_user
redirect_stderr=true
stdout_logfile=/path/to/my_app/log/stdout.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=7
stdout_capture_maxbytes=1MB
stdout_events_enabled=false
environment=PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/opt/aws/bin:~/bin
</pre></div>
</div>
<p>다른 방법:</p>
<ul class="simple">
<li><a class="reference external" href="http://smarden.org/runit/">runit</a></li>
<li><a class="reference external" href="http://upstart.ubuntu.com/">upstart</a></li>
</ul>
</div>
<div class="section" id="id10">
<h3>포트포워딩 방법<a class="headerlink" href="#id10" title="제목 주소">¶</a></h3>
<p>기본적으로 Xitrum는 8000 포트와 4430 포트를 사용합니다.
이 포트 번호는``config / xitrum.conf``으로 설정할 수 있습니다.</p>
<p><a href="#id11"><span class="problematic" id="id12">``</span></a>/ etc / sysconfig / iptables``를 다음 명령으로 수정함으로써
80에서 8000에 443에서 4430로 포트 포워딩을 수행 할 수 있습니다 :</p>
<div class="highlight-python"><div class="highlight"><pre>sudo su - root
chmod 700 /etc/sysconfig/iptables
iptables-restore &lt; /etc/sysconfig/iptables
iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8000
iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 4430
iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 80 -j REDIRECT --to-ports 8000
iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 443 -j REDIRECT --to-ports 4430
iptables-save -c &gt; /etc/sysconfig/iptables
chmod 644 /etc/sysconfig/iptables
</pre></div>
</div>
<p>만약 Apache가 80포트、443포트를 사용하고 있다면, 반드시 멈추고 실행해야 합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo /etc/init.d/httpd stop
sudo chkconfig httpd off
</pre></div>
</div>
<p>Iptables에 대한 좋은 정보:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.frozentux.net/iptables-tutorial/chunkyhtml/">Iptables 튜토리얼</a></li>
</ul>
</div>
<div class="section" id="linux">
<h3>대량연결에 대한 Linux 설정<a class="headerlink" href="#linux" title="제목 주소">¶</a></h3>
<p>Mac의 경우 JDK는`IO (NIO)에 관련된 성능 문제 &lt;<a class="reference external" href="https://groups.google.com/forum/#!topic/spray-user/S-SNR2m0BWU">https://groups.google.com/forum/#!topic/spray-user/S-SNR2m0BWU</a>&gt;`_가 존재합니다.</p>
<p>참고자료:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.basho.com/riak/latest/ops/tuning/linux/">Linux Performance Tuning (Riak)</a></li>
<li><a class="reference external" href="http://docs.basho.com/riak/latest/ops/tuning/aws/">AWS Performance Tuning (Riak)</a></li>
<li><a class="reference external" href="http://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/">Ipsysctl tutorial</a></li>
<li><a class="reference external" href="http://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/tcpvariables.html">TCP variables</a></li>
</ul>
<div class="section" id="id13">
<h4>파일 디스크립터 제한<a class="headerlink" href="#id13" title="제목 주소">¶</a></h4>
<p>각 연결은 Linux에 오픈된 파일로 간주됩니다.
1 프로세스가 동시에 오픈 할 수있는 파일 디스크립터 수는 기본적으로 1024으로되어 있습니다.
이 제한을 변경하려면``/ etc / security / limits.conf``을 편집합니다 :</p>
<div class="highlight-python"><div class="highlight"><pre>*  soft  nofile  1024000
*  hard  nofile  1024000
</pre></div>
</div>
<p>변경 내용을 적용하려면 로그 아웃 한 후 다시 로그인해야합니다.
일시적으로 적용하려면``ulimit -n`` 실행합니다.</p>
</div>
<div class="section" id="id14">
<h4>커널 조정<a class="headerlink" href="#id14" title="제목 주소">¶</a></h4>
<p><a class="reference external" href="http://www.metabrew.com/article/a-million-user-comet-application-with-mochiweb-part-1">A Million-user Comet Application with Mochiweb（영문）</a> 에 소개된것 처럼、<code class="docutils literal"><span class="pre">/etc/sysctl.conf</span></code> 를 편집합니다:</p>
<div class="highlight-python"><div class="highlight"><pre># General gigabit tuning
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216

# This gives the kernel more memory for TCP
# which you need with many (100k+) open socket connections
net.ipv4.tcp_mem = 50576 64768 98152

# Backlog
net.core.netdev_max_backlog = 2048
net.core.somaxconn = 1024
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_syncookies = 1
</pre></div>
</div>
<p>변경사항을 적용하기 위해、 <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">sysctl</span> <span class="pre">-p</span></code> 를 실행합니다.
재부팅할 필요는 없습니다, 지금부터 더 많은 커넥션을 바로 수행이 가능합니다</p>
</div>
<div class="section" id="id15">
<h4>백 로그에 대해<a class="headerlink" href="#id15" title="제목 주소">¶</a></h4>
<p>TCP는 연결 확립을 위해 3 종류의 핸드 셰이크 방식을 사용합니다.
원격 클라이언트가 서버에 연결할 때 클라이언트는 SYN 패킷을 보냅니다.
그리고 서버 측의 OS는 SYN-ACK 패킷을 회신합니다.
그 후 원격 클라이언트는 다시 ACK 패킷을 전송하고 연결이 설정합니다.
Xitrum는 연결이 완전히 확립했을 때 가져옵니다.</p>
<p><a href="#id16"><span class="problematic" id="id17">`</span></a>Socket backlog tuning for Apache (영어) &lt;<a class="reference external" href="https://sites.google.com/site/beingroot/articles/apache/socket-backlog-tuning-for-apache">https://sites.google.com/site/beingroot/articles/apache/socket-backlog-tuning-for-apache</a>&gt;`_에 따르면,
연결 시간 제한은 Web 서버의 백 로그 큐가 SYN-ACK 패킷으로 흘러 버린 때 SYN 패킷이 손실되기 때문에 발생합니다.</p>
<p><a href="#id18"><span class="problematic" id="id19">`</span></a>FreeBSD Handbook (영어) &lt;<a class="reference external" href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/configtuning-kernel-limits.html">http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/configtuning-kernel-limits.html</a>&gt;`_에 따르면
기본 128이라는 설정은 고부하 서버 환경에 새로운 연결을 확실하게 받기에는 너무 낮은 수치입니다.
그런 환경에서는 1024 이상으로 설정하는 것이 좋다고 되어 있습니다.
큐 크기를 크게하는 것은 DoS 공격을 피하는 의미에서도 효과가 있습니다.</p>
<p>Xitrum는 백 로그 크기를 1024 (memcached와 같은 값)으로하고 있습니다.
그러나 위의 커널 튜닝을하는 것도 잊지 마십시오.</p>
<p>백 로그 설정 확인 방법 :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cat</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">net</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">somaxconn</span>
</pre></div>
</div>
<p>또는:</p>
<div class="highlight-python"><div class="highlight"><pre>sysctl net.core.somaxconn
</pre></div>
</div>
<p>一임시로 변경:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo sysctl -w net.core.somaxconn=1024
</pre></div>
</div>
</div>
</div>
<div class="section" id="haproxy">
<h3>HAProxy 팁<a class="headerlink" href="#haproxy" title="제목 주소">¶</a></h3>
<p>HAProxy를 SockJS 위해 설정하려면 <a href="#id20"><span class="problematic" id="id21">`</span></a>샘플 &lt;<a class="reference external" href="https://github.com/sockjs/sockjs-node/blob/master/examples/haproxy.cfg">https://github.com/sockjs/sockjs-node/blob/master/examples/haproxy.cfg</a>&gt;`_을 참조하십시오.
HAProxy를 다시 시작하지 않고 설정 파일을로드하려면 <a href="#id22"><span class="problematic" id="id23">`</span></a>토론 &lt;<a class="reference external" href="http://serverfault.com/questions/165883/is-there-a-way-to-add-more-backend-server">http://serverfault.com/questions/165883/is-there-a-way-to-add-more-backend-server</a>- to-haproxy-without-restarting-haproxy&gt;`_을 참조하십시오.</p>
<p>HAProxy는 Nginx보다 훨신 사용하기 쉽습니다.
:doc:` 캐시 &lt;/cache&gt;` 에서 처럼、Xitrum은 <a class="reference external" href="https://gist.github.com/3293596">정적 파일전송이 매우 빠르므로</a> 그렇기 때문에
정적 파일 전송에 Nginx를 준비 할 필요는 없습니다. 그 점에서 HAProxy는 Xitrum과 아주 궁합이 좋다고 말할 수 있습니다.</p>
</div>
<div class="section" id="nginx">
<h3>Nginx 팁<a class="headerlink" href="#nginx" title="제목 주소">¶</a></h3>
<p>Nginx 1.2 이전에 Xitrum를 사용하는 경우 Xitrum의 WebSocket과 SockJS 기능을 사용하려면
<a href="#id25"><span class="problematic" id="id26">`</span></a>nginx_tcp_proxy_module &lt;<a class="reference external" href="https://github.com/yaoweibin/nginx_tcp_proxy_module">https://github.com/yaoweibin/nginx_tcp_proxy_module</a>&gt;`_를 사용할 필요가 있습니다.
Nginx 1.3+ 이상은 기본적으로 WebSocket을 지원하고 있습니다.</p>
<p>Nginx는 기본적으로 HTTP 1.0을 역방향 프록시 프로토콜로 사용합니다.
청크 응답을 사용하는 경우, Nginx에 HTTP 1.1 프로토콜로 사용하는 것을 알려야합니다 :</p>
<div class="highlight-python"><div class="highlight"><pre>location / {
  proxy_http_version 1.1;
  proxy_set_header Connection &quot;&quot;;
  proxy_pass http://127.0.0.1:8000;
}
</pre></div>
</div>
<p>http keepalive에 대한 <a class="reference external" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive">문서</a> 에서 말하듯이 <code class="docutils literal"><span class="pre">proxy_set_header</span> <span class="pre">Connection</span> <span class="pre">&quot;&quot;</span></code> 로 설정해야 합니다</p>
</div>
<div class="section" id="heroku">
<h3>Heroku에 배포하기<a class="headerlink" href="#heroku" title="제목 주소">¶</a></h3>
<p>Xitrum을 <a class="reference external" href="https://www.heroku.com/">Heroku</a> 에서 실행도 가능합니다</p>
<div class="section" id="id29">
<h4>가입 및 리파지토리 만들기<a class="headerlink" href="#id29" title="제목 주소">¶</a></h4>
<p><a class="reference external" href="https://devcenter.heroku.com/articles/quickstart">공식문서</a> 에 따라 가입 및 저장소를 만듭니다</p>
</div>
<div class="section" id="procfile">
<h4>Procfile 생성<a class="headerlink" href="#procfile" title="제목 주소">¶</a></h4>
<p>Procfile를 만들고 프로젝트의 루트 디렉토리에 저장합니다.
Heroku는이 파일을 기초로 시작시 명령을 실행합니다.
포트 번호는``$ PORT``라는 변수에 Heroku에서 전달됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre>web: target/xitrum/script/runner &lt;YOUR_PACKAGE.YOUR_MAIN_CLASS&gt; $PORT
</pre></div>
</div>
</div>
<div class="section" id="port">
<h4>Port설정 변경<a class="headerlink" href="#port" title="제목 주소">¶</a></h4>
<p>포트 번호는 Heroku에 의해 동적으로 할당되기 때문에 다음과 같이 할 필요가 있습니다:</p>
<p>config/xitrum.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>port {
  http              = 8000
  # https             = 4430
  # flashSocketPolicy = 8430  # flash_socket_policy.xml will be returned
}
</pre></div>
</div>
<p>SSL을 사용하기 원한다면、<a class="reference external" href="https://addons.heroku.com/ssl">add on</a> 을 참고하세요</p>
</div>
<div class="section" id="id31">
<h4>로그 레벨 수정<a class="headerlink" href="#id31" title="제목 주소">¶</a></h4>
<p>config/logback.xml:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;root level=&quot;INFO&quot;&gt;
  &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
&lt;/root&gt;
</pre></div>
</div>
<p>Heroku의 tail log 명령어:</p>
<div class="highlight-python"><div class="highlight"><pre>heroku logs -tail
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h4><code class="docutils literal"><span class="pre">xitrum-package</span></code> 별칭부여<a class="headerlink" href="#id32" title="제목 주소">¶</a></h4>
<p>배치 실행시 Heroku는``sbt / sbt clean compile stage``를 실행합니다.
따라서``xitrum-package`` 대한 별칭을 작성해야합니다.</p>
<p>build.sbt:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">addCommandAlias</span><span class="p">(</span><span class="s">&quot;stage&quot;</span><span class="p">,</span> <span class="s">&quot;;xitrum-package&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h4>Heroku에 푸시하기<a class="headerlink" href="#id33" title="제목 주소">¶</a></h4>
<p>배포 프로세스는 git push 에 의해 수행됩니다</p>
<div class="highlight-python"><div class="highlight"><pre>git push heroku master
</pre></div>
</div>
<p>Heroku <a class="reference external" href="https://devcenter.heroku.com/articles/getting-started-with-scala">Scala 공식문서</a> 를 참고하세요.</p>
</div>
</div>
</div>
<span id="document-cluster"></span><div class="section" id="akka-hazelcast">
<h2>Akka와 Hazelcast 클러스터링<a class="headerlink" href="#akka-hazelcast" title="제목 주소">¶</a></h2>
<p>Xitrum가 프록시 서버와로드 밸런서 뒤에 클러스터 구성에서 움직일 수 있도록 설계되어 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>                         / Xitrum 인스턴스 1
로드밸런서/프록시 서버      ---- Xitrum 인스턴스 2
                         \ Xitrum 인스턴스 3
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Akka &lt;http://akka.io/&gt;`_와`Hazelcast</a>
클러스터링 기능을 사용하여 캐시, 세션, SockJS세션 을 클러스터링 할 수 있습니다.</p>
<p>Hazelcast가 Xitrum 인스턴스의 프로세스의 메모리 캐시 서버가 되므로.
Memcache 같은 추가 서버는 필요하지 않습니다.</p>
<p>Akka와 Hazelcast 클러스터링을 설정하려면``config / akka.conf```Akka 문서 &lt;<a class="reference external" href="http://akka.io/docs/">http://akka.io/docs/</a>&gt;`_
<a href="#id1"><span class="problematic" id="id2">`</span></a>Hazelcast 문서 &lt;<a class="reference external" href="http://hazelcast.org/documentation/">http://hazelcast.org/documentation/</a>&gt;`_를 참고하십시오.</p>
<p>참고 : 세션, :doc:<a href="#id3"><span class="problematic" id="id4">`</span></a>클라이언트 측 쿠키에 저장 &lt;/ scopes&gt;`할 수 있습니다.</p>
</div>
<span id="document-handler"></span><div class="section" id="netty">
<h2>Netty 핸들러<a class="headerlink" href="#netty" title="제목 주소">¶</a></h2>
<p>이번 챕터는 숙련자용으로, Xitrum을 보통으로 사용하시는분은 읽지 않아도 됩니다
이해를 위해서는 <a class="reference external" href="http://netty.io/">Netty</a> 를 반드시 숙지해야 합니다.</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Rack_(Web_server_interface)">Rack</a> 、
<a class="reference external" href="http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a> 、
<a class="reference external" href="http://en.wikipedia.org/wiki/PSGI">PSGI</a> 는 미들웨어 아키텍처가 있습니다.
Xitrum은 <a class="reference external" href="http://netty.io/">Netty</a> 를 기본으로 하고 같은 핸들러를 사용합니다
핸들러를 생성하여 추가할 수 있고 채널의 파이프라인을 수정하여, 케이스별 서버의 성능을 극대화 할 수 있습니다.</p>
<p>이 장의 설명:</p>
<ul class="simple">
<li>Netty 핸들러 구조</li>
<li>Xitrum이 제공하는 핸들러와 기본순서</li>
<li>핸들러를 생성하고 수정하는 방법</li>
</ul>
<div class="section" id="id3">
<h3>Netty 핸들러 구조<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>각각의 커넥션은, 채널 파이프라인이 있고 IO 데이터를 조작합니다
채널 파이프 라인은 여러개의 핸들러로 구성되어 있고, 두가지의 핸들러 종류가 있습니다:</p>
<ul class="simple">
<li>인바운드(Inbound): 요청방향 클라이언트 -&gt; 서버</li>
<li>아웃바운(Inbound): 응답방향 서버 -&gt; 클라이언트</li>
</ul>
<p><a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html">ChannelPipeline</a>
은 여기에서 더 자세한 정보를 얻을 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>                                               I/O Request
                                          via Channel or
                                      ChannelHandlerContext
                                                    |
+---------------------------------------------------+---------------+
|                           ChannelPipeline         |               |
|                                                  \|/              |
|    +---------------------+            +-----------+----------+    |
|    | Inbound Handler  N  |            | Outbound Handler  1  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
|               |                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  .               |
|               .                                   .               |
| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
|        [ method call]                       [method call]         |
|               .                                   .               |
|               .                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
|               |                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler  1  |            | Outbound Handler  M  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
+---------------+-----------------------------------+---------------+
                |                                  \|/
+---------------+-----------------------------------+---------------+
|               |                                   |               |
|       [ Socket.read() ]                    [ Socket.write() ]     |
|                                                                   |
|  Netty Internal I/O Threads (Transport Implementation)            |
+-------------------------------------------------------------------+
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>핸들러의 수정<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<p>Xitrum 서버가 구동될때
<a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelInitializer.html">ChannelInitializer</a>
를 설정할 수 있습니다ㄷ:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Server

object Boot {
  def main(args: Array[String]) {
    Server.start(myChannelInitializer)
  }
}
</pre></div>
</div>
<p>HTTPS서버의 경우, Xitrum은 자동으로 SSL 핸들러를 파이프라인 앞에 준비합니다.
Xitrum 핸들러를 파이프라인에서 재사용이 가능합니다.</p>
</div>
<div class="section" id="xitrum">
<h3>Xitrum 핸들러<a class="headerlink" href="#xitrum" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/handler/DefaultHttpChannelInitializer.scala">xitrum.handler.DefaultHttpChannelInitializer</a>
를 참고하세요.</p>
<p>공유가능한 핸들러（다중연결에서 공유된 같은 인스턴스들）
<code class="docutils literal"><span class="pre">DefaultHttpChannelInitializer</span></code> 개체위에 존재하며 수정된 파이프 라인을 통하여 사용하기 원하는 어플리케이션에 쉽게 사용이 가능합니다.
이 어플리케이션들은 기본 핸들러의 집합입니다</p>
<p>예를들어, 어플리케이션이 자신의 디스패쳐를 사용하고(Xitrum의 라우팅/디스패쳐가 아닌) Xitrum의 빠른 정적파일만 사용한다면,
다음의 핸들러만 사용하면 됩니다.</p>
<p>인바운드(Inbound):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HttpRequestDecoder</span></code></li>
<li><code class="docutils literal"><span class="pre">PublicFileServer</span></code></li>
<li>자신의 dispatcher</li>
</ul>
<p>아웃바운드(Outbound):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HttpResponseEncoder</span></code></li>
<li><code class="docutils literal"><span class="pre">ChunkedWriteHandler</span></code></li>
<li><code class="docutils literal"><span class="pre">XSendFile</span></code></li>
</ul>
</div>
</div>
<span id="document-metrics"></span><div class="section" id="id1">
<h2>매트릭스<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<p>Xitrum은 어플리케이션의 JVM의 힙 메모리, CPU, 그리고 액션의 수행상태를 Akka 클러스터의 각 노드로 부터 수집합니다.
또한, 이 데이터들은 JSON 데이터로 전달됩니다.
Xitrum은 매트릭스의 정의도 가능합니다.</p>
<p>매트릭스의 구성은 <a class="reference external" href="http://metrics.codahale.com/">Coda Hale Metrics</a> 라이브러리를 바탕으로 작성되었습니다.</p>
<div class="section" id="id2">
<h3>매트릭스 수집<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<div class="section" id="cpu">
<h4>힙 메모리와 CPU<a class="headerlink" href="#cpu" title="제목 주소">¶</a></h4>
<p>JVM의 힙 메모리와 CPU는 각 노드의 Akka 액터 시스템의 <a class="reference external" href="http://doc.akka.io/api/akka/2.3.0/index.html#akka.cluster.NodeMetrics">NodeMetrics</a>
으로 수집됩니다.</p>
<p>힙 메모리:</p>
<img alt="_images/metrics_heapmemory.png" src="_images/metrics_heapmemory.png" />
<p>CPU: 프로세스의 갯수와 부하</p>
<img alt="_images/metrics_cpu.png" src="_images/metrics_cpu.png" />
</div>
<div class="section" id="id3">
<h4>액션 매트릭스<a class="headerlink" href="#id3" title="제목 주소">¶</a></h4>
<p>Xitrum은 각 노드에서의 액션의 실행상태를 <a class="reference external" href="http://metrics.codahale.com/getting-started/#histograms">Histogram</a> 을 통해 측정합니다.
여기에서 액션의 실행 횟수와, 비동기 액션의 수행시간을 알 수 있습니다.</p>
<img alt="_images/metrics_action_count.png" src="_images/metrics_action_count.png" />
<p>최근의 특정 액션의 실행 시간:</p>
<img alt="_images/metrics_action_time.png" src="_images/metrics_action_time.png" />
</div>
<div class="section" id="id4">
<h4>수정된 매트릭스 수집<a class="headerlink" href="#id4" title="제목 주소">¶</a></h4>
<p>위에 정의된 기본적인 매트릭스 수집방법에 추가로, 매트릭스를 수정하여 수집할 수 있습니다.
<code class="docutils literal"><span class="pre">xitrum.Metrics</span></code> 은 <code class="docutils literal"><span class="pre">gauge</span></code>, <code class="docutils literal"><span class="pre">counter</span></code>, <code class="docutils literal"><span class="pre">meter</span></code>, <code class="docutils literal"><span class="pre">timer</span></code> , <code class="docutils literal"><span class="pre">histogram</span></code> 에 관한 정보의 단축키 입니다.
<a class="reference external" href="http://metrics.codahale.com/">Coda Hale Metrics</a> 와 <a class="reference external" href="https://github.com/erikvanoosten/metrics-scala">its Scala implementation</a> 를 통해 사용법을 익힐 수 있습니다.</p>
<p>Timer 예제:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, Metrics}
import xitrum.annotation.GET

object MyAction {
  lazy val myTimer = Metrics.timer(&quot;myTimer&quot;)
}

@GET(&quot;my/action&quot;)
class MyAction extends Action {
  import MyAction._

  def execute() {
    myTimer.time {
      // Something that you want to measure execution time
      ...
    }
    ...
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id6">
<h3>매트릭스 배포<a class="headerlink" href="#id6" title="제목 주소">¶</a></h3>
<p>Xitrum은 일정주기로 최근의 매트릭스 값을 JSON 포멧으로 제공합니다.
데이터는 휘발성이며 영구적으로 저장되지 않습니다.</p>
<p>힙 메모:</p>
<div class="highlight-python"><div class="highlight"><pre>{
  &quot;TYPE&quot;      : &quot;heapMemory&quot;,
  &quot;SYSTEM&quot;    : akka.actor.Address.system,
  &quot;HOST&quot;      : akka.actor.Address.host,
  &quot;PORT&quot;      : akka.actor.Address.port,
  &quot;HASH&quot;      : akka.actor.Address.hashCode,
  &quot;TIMESTAMP&quot; : akka.cluster.NodeMetrics.timestamp,
  &quot;USED&quot;      : Number as byte,
  &quot;COMMITTED&quot; : Number as byte,
  &quot;MAX&quot;       : Number as byte
}
</pre></div>
</div>
<p>CPU:</p>
<div class="highlight-python"><div class="highlight"><pre>{
  &quot;TYPE&quot;              : &quot;cpu&quot;,
  &quot;SYSTEM&quot;            : akka.actor.Address.system,
  &quot;HOST&quot;              : akka.actor.Address.host,
  &quot;PORT&quot;              : akka.actor.Address.port,
  &quot;HASH&quot;              : akka.actor.Address.hashCode,
  &quot;TIMESTAMP&quot;         : akka.cluster.NodeMetrics.timestamp
  &quot;SYSTEMLOADAVERAGE&quot; : Number,
  &quot;CPUCOMBINED&quot;       : Number,
  &quot;PROCESSORS&quot;        : Number
}
</pre></div>
</div>
<p>매트릭스 레지스트리는 <a class="reference external" href="http://metrics.codahale.com/manual/json/">metrics-json</a> 에 의해 파싱됩니다.</p>
<div class="section" id="xitrum">
<h4>Xitrum 기본 뷰어<a class="headerlink" href="#xitrum" title="제목 주소">¶</a></h4>
<p>Xitrum은 기본 매트릭스 뷰어로 <code class="docutils literal"><span class="pre">/xitrum/metrics/viewer?api_key=&lt;xitrum.confの中のキー&gt;</span></code> 을 제공합니다.
이 URL은 위의 정보를  <a class="reference external" href="http://d3js.org/">D3.js</a> 로 생성하여 그래프로 보여줍니다.</p>
<p>URL 생성방법:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Config
import xitrum.metrics.XitrumMetricsViewer

url[XitrumMetricsViewer](&quot;api_key&quot; -&gt; Config.xitrum.metrics.get.apiKey)
</pre></div>
</div>
</div>
<div class="section" id="jconsole">
<h4>Jconsole 뷰어<a class="headerlink" href="#jconsole" title="제목 주소">¶</a></h4>
<p><a class="reference external" href="http://metrics.codahale.com/getting-started/#reporting-via-jmx">JVM Reporter</a> 로 볼 수 있습니다.</p>
<img alt="_images/metrics_jconsole.png" src="_images/metrics_jconsole.png" />
<p>JVM Reporter 시작하기:</p>
<div class="highlight-python"><div class="highlight"><pre>import com.codahale.metrics.JmxReporter

object Boot {
  def main(args: Array[String]) {
    Server.start()
    JmxReporter.forRegistry(xitrum.Metrics).build().start()
  }
}
</pre></div>
</div>
<p>다음 명령을 <a class="reference external" href="http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">jconsole</a> 커맨드로 실행합니다.</p>
</div>
<div class="section" id="id8">
<h4>사용자 정의 매트릭스 뷰어<a class="headerlink" href="#id8" title="제목 주소">¶</a></h4>
<p>매트릭스는 JSON 의 형식으로 SockJS URL <code class="docutils literal"><span class="pre">xitrum/metrics/channel</span></code> 에 배포됩니다.
<code class="docutils literal"><span class="pre">jsAddMetricsNameSpace</span></code> 은 Xitrum이 제공하는 편리한 자바스크립트 단편입니다. 앤드포인트에 생성된 커넥션을 연결합니다.</p>
<p>JSON 핸들러를 구현하려면, 핸들러에 <code class="docutils literal"><span class="pre">initMetricsChannel</span></code> 를 호출하면 됩니다.</p>
<p>액션 예제:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.GET
import xitrum.metrics.MetricsViewer

@GET(&quot;my/metrics/viewer&quot;)
class MySubscriber extends MetricsViewer {
  def execute() {
    jsAddMetricsNameSpace(&quot;window&quot;)
    jsAddToView(&quot;&quot;&quot;
      function onValue(json) {
        console.log(json);
      }
      function onClose(){
        console.log(&quot;channel closed&quot;);
      }
      window.initMetricsChannel(onValue, onClose);
    &quot;&quot;&quot;)
    respondView()
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>매트릭스 저장<a class="headerlink" href="#id9" title="제목 주소">¶</a></h4>
<p>메모리를 절약하기 위해, Xitrum은 이전 매트릭스 값을 저장하지 않습니다. 만약 매트릭스값을 사용하기 위해
데이터베이스나 파일에 저장하려면, subscriber를 직접 구현해야 합니다.</p>
<p>예:</p>
<div class="highlight-python"><div class="highlight"><pre>import akka.actor.Actor
import xitrum.metrics.PublisherLookUp

class MySubscriber extends Actor with PublisherLookUp {
  override def preStart() {
    lookUpPublisher()
  }

  def receive = {
    case _ =&gt;
  }

  override def doWithPublisher(globalPublisher: ActorRef) = {
    context.become {
      // When run in multinode environment
      case multinodeMetrics: Set[NodeMetrics] =&gt;
        // Save to DB or write to file.

      // When run in single node environment
      case nodeMetrics: NodeMetrics =&gt;
        // Save to DB or write to file.

      case Publish(registryAsJson) =&gt;
        // Save to DB or write to file.

      case _ =&gt;
    }
  }
}
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-howto"></span><div class="section" id="howto">
<h2>HOWTO<a class="headerlink" href="#howto" title="제목 주소">¶</a></h2>
<p>이 장에서는 몇가지 작은 팁들을 제공합니다.</p>
<div class="section" id="id1">
<h3>기본적인 인증<a class="headerlink" href="#id1" title="제목 주소">¶</a></h3>
<p>사이트나 특정 액션에 <a class="reference external" href="http://ja.wikipedia.org/wiki/Basic%E8%AA%8D%E8%A8%BC">Basic authentication</a> 을 이용하여 보호할 수 있습니다.</p>
<p>Xitrum은 <a class="reference external" href="http://ja.wikipedia.org/wiki/Digest%E8%AA%8D%E8%A8%BC">digest authentication</a> 을 지원하지 않습니다
잘못된 보안 방법으로 인해 man-in-the-middle attack 에 취약하기 때문에 보다 나은 방법으로서 Xitrum을 이용하여 HTTPS를 사용하는 것을 권장합니다.
(Apache나 Nginx와 같은 리버스 프록시를 따로 구축할 필요가 없습니다)</p>
<div class="section" id="id2">
<h4>전체 프로젝트에 기본적인 인증을 설정하는 방법<a class="headerlink" href="#id2" title="제목 주소">¶</a></h4>
<p><code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> 내부에 설정:</p>
<div class="highlight-python"><div class="highlight"><pre>&quot;basicAuth&quot;: {
  &quot;realm&quot;:    &quot;xitrum&quot;,
  &quot;username&quot;: &quot;xitrum&quot;,
  &quot;password&quot;: &quot;xitrum&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>특정 액션에 기본 인증을 추가<a class="headerlink" href="#id3" title="제목 주소">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action

class MyAction extends Action {
  beforeFilter {
    basicAuth(&quot;Realm&quot;) { (username, password) =&gt;
      username == &quot;username&quot; &amp;&amp; password == &quot;password&quot;
    }
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h3>설정파일 로드<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<div class="section" id="json">
<h4>JSON 파일<a class="headerlink" href="#json" title="제목 주소">¶</a></h4>
<p>JSON은 중첩된 구조를 설명하기에 알맞습니다.</p>
<p><code class="docutils literal"><span class="pre">config</span></code> 디렉토리에 설정 파일을 저장합니다.
이 디렉토리는 개발모드에서는 build.sbt에 의해서, 프로덕션 모드에서는 <code class="docutils literal"><span class="pre">script/runner</span></code> 에 의해 클래스 패스에 저장됩니다 (그리고 <code class="docutils literal"><span class="pre">script/runner.bat</span></code> )</p>
<p>myconfig.json:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span>
  <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="s">&quot;God&quot;</span><span class="p">,</span>
  <span class="s">&quot;password&quot;</span><span class="p">:</span> <span class="s">&quot;Does God need a password?&quot;</span><span class="p">,</span>
  <span class="s">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="s">&quot;Eva&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>로드방법:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Loader

case class MyConfig(username: String, password: String, children: Seq[String])
val myConfig = Loader.jsonFromClasspath[MyConfig](&quot;myconfig.json&quot;)
</pre></div>
</div>
<p>주의:</p>
<ul class="simple">
<li>키와 스트링은 큰따옴표로 둘러쌓여 있어야 합니다.</li>
<li>현재는, JSON파일에 주석을 달 수 없습니다.</li>
</ul>
</div>
<div class="section" id="id5">
<h4>설정파일<a class="headerlink" href="#id5" title="제목 주소">¶</a></h4>
<p>설정 파일을 사용할 수도 있습니다만, 설정파일은 안전하지 않고, UTF-8을 지원하지 않을뿐더러 중첩된 구조도 지원하지 않으므로
JSON을 사용하는것이 훨신 좋습니다.</p>
<p>myconfig.properties:</p>
<div class="highlight-python"><div class="highlight"><pre>username = God
password = Does God need a password?
children = Adam, Eva
</pre></div>
</div>
<p>로드방법:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Loader

// Here you get an instance of java.util.Properties
val properties = Loader.propertiesFromClasspath(&quot;myconfig.properties&quot;)
</pre></div>
</div>
</div>
<div class="section" id="typesafe">
<h4>Typesafe한 설정파일<a class="headerlink" href="#typesafe" title="제목 주소">¶</a></h4>
<p>Xitrum은 Akka를 포함하고 있습니다. Akka는 <a class="reference external" href="http://typesafe.com/company">Typesafe</a> 사의 <a class="reference external" href="https://github.com/typesafehub/config">config library</a> 이라고 하는 라이브러리를 포함하고 있으며, 더 나은 설정 방법을 제시합니다.</p>
<p>myconfig.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>username = God
password = Does God need a password?
children = [&quot;Adam&quot;, &quot;Eva&quot;]
</pre></div>
</div>
<p>로드방법:</p>
<div class="highlight-python"><div class="highlight"><pre>import com.typesafe.config.{Config, ConfigFactory}

val config   = ConfigFactory.load(&quot;myconfig.conf&quot;)
val username = config.getString(&quot;username&quot;)
val password = config.getString(&quot;password&quot;)
val children = config.getStringList(&quot;children&quot;)
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h3>직렬화 및 역직렬화<a class="headerlink" href="#id7" title="제목 주소">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Array[Byte]</span></code> 를 직렬화:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri
val bytes = SeriDeseri.toBytes(&quot;my serializable object&quot;)
</pre></div>
</div>
<p>다시 역직렬화:</p>
<div class="highlight-python"><div class="highlight"><pre>val option = SeriDeseri.fromBytes[MyType](bytes)  // Option[MyType]
</pre></div>
</div>
<p>파일에 저장시:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">xitrum.util.Loader</span>
<span class="n">Loader</span><span class="o">.</span><span class="n">bytesToFile</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="s">&quot;myObject.bin&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>파일에서 로드시:</p>
<div class="highlight-python"><div class="highlight"><pre>val bytes = Loader.bytesFromFile(&quot;myObject.bin&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>데이터 암호화<a class="headerlink" href="#id8" title="제목 주소">¶</a></h3>
<p>다시 해독할 필요가 없는 데이터일 경우 MD5등을 사용할 수 있습니다.(단방향 암호화)
다시 해독할 필요가 있는 데이터일 경우, Xitrum에서 제공하는 라이브러리를 사용하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Secure

// Array[Byte]
val encrypted = Secure.encrypt(&quot;my data&quot;.getBytes)

// Option[Array[Byte]]
val decrypted = Secure.decrypt(encrypted)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">xitrum.util.UrlSafeBase64</span></code> 을 이용하여 바이너리 데이터(HTML을 이용한 응답등을 포함)를 일반적인 스트링값으로 암복호화가 가능합니다.</p>
<div class="highlight-python"><div class="highlight"><pre>// cookie와 같이 URL내에 포함된 스트링
val string = UrlSafeBase64.noPaddingEncode(encrypted)

// Option[Array[Byte]]
val encrypted2 = UrlSafeBase64.autoPaddingDecode(string)
</pre></div>
</div>
<p>두가지를 한번에 결합할 수 있습니다:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri

val mySerializableObject = new MySerializableClass

// String
val encrypted = SeriDeseri.toSecureUrlSafeBase64(mySerializableObject)

// Option[MySerializableClass]
val decrypted = SeriDeseri.fromSecureUrlSafeBase64[MySerializableClass](encrypted)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">SeriDeseri</span></code> 는 <a class="reference external" href="https://github.com/twitter/chill">Twitter Chill</a> 를 사용하여 직렬화 및 역직렬화를 합니다.
데이터는 반드시 직렬화가 가능 해야 합니다.</p>
<p>특정한 키를 암호화:</p>
<div class="highlight-python"><div class="highlight"><pre>val encrypted = Secure.encrypt(&quot;my data&quot;.getBytes, &quot;my key&quot;)
val decrypted = Secure.decrypt(encrypted, &quot;my key&quot;)
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>val encrypted = SeriDeseri.toSecureUrlSafeBase64(mySerializableObject, &quot;my key&quot;)
val decrypted = SeriDeseri.fromSecureUrlSafeBase64[MySerializableClass](encrypted, &quot;my key&quot;)
</pre></div>
</div>
<p>키가 지정되어 있지 않은경우、<code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> 파일내의 <code class="docutils literal"><span class="pre">secureKey</span></code> 가 사용됩니다.</p>
</div>
<div class="section" id="id9">
<h3>동일한 도매인내의 여러 사이트<a class="headerlink" href="#id9" title="제목 주소">¶</a></h3>
<p>Nginx와 같은 리버스 프록시를 사용하여 같은 도메인내의 여러 다른 사이트를 실행:</p>
<div class="highlight-python"><div class="highlight"><pre>http://example.com/site1/...
http://example.com/site2/...
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">config/xitrum.conf</span></code> 내의、 <code class="docutils literal"><span class="pre">baseUrl</span></code> 을 정의합니다.</p>
<p>JavaScript코드 내에서、 Ajax 요청에 정확한 URLs을 얻으려면 <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a> 내의 <code class="docutils literal"><span class="pre">withBaseUrl</span></code> 을 사용하면 됩니다.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 만약 현재 사이트의 baseUrl이 &quot;site1&quot; 일경우, 결과는:</span>
<span class="c"># 다음과 같습니다. /site1/path/to/my/action</span>
<span class="n">xitrum</span><span class="o">.</span><span class="n">withBaseUrl</span><span class="p">(</span><span class="s">&#39;/path/to/my/action&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="markdown-html">
<h3>Markdown 텍스트를 HTML 로 변환<a class="headerlink" href="#markdown-html" title="제목 주소">¶</a></h3>
<p>프로젝트가 이미 <a class="reference internal" href="index.html#document-template_engines"><em>Scalate</em></a> 을 사용하고 있다면, 다음과 같이 해야 합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>import org.fusesource.scalamd.Markdown
val html = Markdown(&quot;input&quot;)
</pre></div>
</div>
<p>아니라면, 라이브러리를 프로젝트의 build.sbt에 추가해야 합니다:</p>
<div class="highlight-python"><div class="highlight"><pre>libraryDependencies += &quot;org.fusesource.scalamd&quot; %% &quot;scalamd&quot; % &quot;1.6&quot;
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>파일의 모니터링<a class="headerlink" href="#id10" title="제목 주소">¶</a></h3>
<p>파일이나 디렉토리의 <a class="reference external" href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/StandardWatchEventKinds.html">StandardWatchEventKinds</a> 에
콜백을 설정할 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>import java.nio.file.Paths
import xitrum.util.FileMonitor

val target = Paths.get(&quot;absolute_path_or_path_relative_to_application_directory&quot;).toAbsolutePath
FileMonitor.monitor(FileMonitor.MODIFY, target, { path =&gt;
  // Do some callback with path
  println(s&quot;File modified: $path&quot;)

  // And stop monitoring if necessary
  FileMonitor.unmonitor(FileMonitor.MODIFY, target)
})
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">FileMonitor</span></code> 는 <a class="reference external" href="https://github.com/lloydmeta/schwatcher">Schwatcher</a> 를 사용하고 있습니다.</p>
</div>
<div class="section" id="id11">
<h3>임시 디렉토리<a class="headerlink" href="#id11" title="제목 주소">¶</a></h3>
<p>기본적으로 Xitrum은 <code class="docutils literal"><span class="pre">tmp</span></code> 디렉토리 ( <code class="docutils literal"><span class="pre">xitrum.conf</span></code> 의 <code class="docutils literal"><span class="pre">tmpDir</span></code> 에서 확인가능)를 생성된 .scala파일의 저장이나 큰 업로드용 파일들을
저장하기 위해 사용합니다.</p>
<p>파일 경로 얻어오기:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">Config</span><span class="o">.</span><span class="n">xitrum</span><span class="o">.</span><span class="n">tmpDir</span><span class="o">.</span><span class="n">getAbsolutePath</span>
</pre></div>
</div>
<p>파일이나 디렉토리 생성:</p>
<div class="highlight-python"><div class="highlight"><pre>val file = new java.io.File(xitrum.Config.xitrum.tmpDir, &quot;myfile&quot;)

val dir = new java.io.File(xitrum.Config.xitrum.tmpDir, &quot;mydir&quot;)
dir.mkdirs()
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>비디오 스트리밍<a class="headerlink" href="#id12" title="제목 주소">¶</a></h3>
<p>다양한 비디오 스트리밍 방법중, 쉬운 방법은:</p>
<ul class="simple">
<li>.mp4 비디오 파일들에 간격을 주어서, 플래이 하는 동안 다운로드를 합니다.</li>
<li>그리고 Xitrum이 지원하는 HTTP서버와 같이 <a class="reference external" href="http://en.wikipedia.org/wiki/Byte_serving">range requests</a> 사용자는 다운로드 받지 않은 부분에 대하여
건너뛰기가 가능합니다.</li>
</ul>
<p><a class="reference external" href="http://gpac.wp.mines-telecom.fr/mp4box/">MP4Box</a> 를 이용하는 것으로 500밀리초마다 데이터를 넣을 수 있습니다.</p>
<div class="highlight-python"><div class="highlight"><pre>MP4Box -inter 500 movie.mp4
</pre></div>
</div>
</div>
</div>
<span id="document-deps"></span><div class="section" id="id1">
<h2>의존도<a class="headerlink" href="#id1" title="제목 주소">¶</a></h2>
<div class="section" id="id2">
<h3>라이브러리 의존도<a class="headerlink" href="#id2" title="제목 주소">¶</a></h3>
<p>Xitrum은 다양한 라이브러리를 포함하고 있습니다. 원한다면 직접 라이브러리를 사용할 수 있습니다</p>
<img alt="_images/deps.png" src="_images/deps.png" />
<p>주요 종속 라이브러리:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.scala-lang.org/">Scala</a> :</li>
</ul>
<p>&nbsp;&nbsp; Xitrum은 Scala로 작성 되었습니다.
* <a class="reference external" href="https://netty.io/">Netty</a> :
&nbsp;&nbsp; WebSocket과 제로 복사 파일 전송 등
&nbsp;&nbsp; Xitrum의 비동기 HTTP(S) 서버의 많은 기능은 Netty의 기능을 바탕으로 구현되었습니다.
* <a class="reference external" href="http://akka.io/">Akka</a> :
&nbsp;&nbsp; 주로 SockJS 위해. Akka는`Typesafe Config &lt;<a class="reference external" href="https://github.com/typesafehub/config">https://github.com/typesafehub/config</a>&gt;`_
&nbsp;&nbsp; 에 의존하고 있으며, Xitrum 또한 그것을 사용하고 있습니다.</p>
<p>기타 주요 종속 라이브러리 :</p>
<ul class="simple">
<li><a class="reference external" href="http://commons.apache.org/lang/">Commons Lang</a> :</li>
</ul>
<p>&nbsp;&nbsp; JSON 데이터의 이스케이프 처리에 사용하고 있습니다.
* <a class="reference external" href="https://github.com/xitrum-framework/glokka">Glokka</a> :
&nbsp;&nbsp; SockJS 액터 클러스터링에 사용하고 있습니다.
* <a class="reference external" href="https://github.com/json4s/json4s">JSON4S</a> :
&nbsp;&nbsp; JSON 파싱과 생성을 위해 사용합니다.
&nbsp;&nbsp; JSON4S은</p>
<blockquote>
<div><a class="reference external" href="http://paranamer.codehaus.org/">Paranamer</a> 의존 라이브러리로 사용하고 있습니다.</div></blockquote>
<ul class="simple">
<li><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Rhino">Rhino</a> :</li>
</ul>
<p>&nbsp;&nbsp; Scalate에서 CoffeeScript를 JavaScript로 컴파일하는 데 사용하고 있습니다.
* <a class="reference external" href="https://github.com/xitrum-framework/sclasner">Sclasner</a> :
&nbsp;&nbsp; 클래스 파일과 jar 파일에서 HTTP 경로를 검색하는 데 사용하고 있습니다.
* <a class="reference external" href="https://github.com/xitrum-framework/scaposer">Scaposer</a> :
&nbsp;&nbsp; 국제화를 위해 사용하고 있습니다.
* <a class="reference external" href="https://github.com/twitter/chill">Twitter Chill</a> :
&nbsp;&nbsp; 쿠키와 세션의 직렬화 역직렬화에 사용하고 있습니다.
&nbsp;&nbsp; Chill는`Kryo &lt;<a class="reference external" href="http://code.google.com/p/kryo/">http://code.google.com/p/kryo/</a>&gt;`_를 바탕으로하고 있습니다.
* <a class="reference external" href="http://logback.qos.ch/">SLF4S &lt;http://slf4s.org/&gt;`_`Logback</a> :
&nbsp;&nbsp; 로깅에 사용하고 있습니다.</p>
<p><a href="#id3"><span class="problematic" id="id4">`</span></a>Xitrum 프로젝트 뼈대 &lt;<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">https://github.com/xitrum-framework/xitrum-new</a>&gt;`_는 다음 도구를 포장하고 있습니다:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/scala-xgettext">scala-xgettext</a> :</li>
</ul>
<p>&nbsp;&nbsp; 컴파일시에 .scala 파일 :doc: <cite>국제화 &lt;/ i18n&gt;</cite> 문자열을 확장합니다.
* <a class="reference external" href="https://github.com/xitrum-framework/xitrum-package">xitrum-package</a> :
&nbsp;&nbsp; 프로덕션 환경에 배포하기 위해 :doc: <cite>프로젝트를 패키징 &lt;/ deploy&gt;</cite> 합니다.
* <a class="reference external" href="https://github.com/xitrum-framework/scalive">Scalive</a> :
&nbsp;&nbsp; Scala 콘솔에서 JVM 프로세스에 연결하여 동적 디버깅을 가능하게합니다.</p>
</div>
<div class="section" id="id5">
<h3>관련 프로젝트<a class="headerlink" href="#id5" title="제목 주소">¶</a></h3>
<p>데모:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">xitrum-new</a> :</li>
</ul>
<p>&nbsp;&nbsp; 신규 Xitrum 프로젝트의 골격.
* <a class="reference external" href="https://github.com/xitrum-framework/xitrum-demos">xitrum-demos</a> :
&nbsp;&nbsp; Xitrum 각 기능의 데모 프로젝트.
* <a class="reference external" href="https://github.com/xitrum-framework/xitrum-placeholder">xitrum-placeholder</a> :
&nbsp;&nbsp; Xitrum 의한 화상 이미지 응용 프로그램의 데모.
* <a class="reference external" href="https://github.com/xitrum-framework/comy">comy</a> :
&nbsp;&nbsp; 간단한 URL 숏터 앱 데모.
* <a class="reference external" href="https://github.com/xitrum-framework/xitrum-multimodule-demo">xitrum-multimodule-demo</a> :
&nbsp;&nbsp; <a class="reference external" href="http://www.scala-sbt.org/">SBT</a> 멀티 모듈 프로젝트의 데모.</p>
<p>플러그인:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a> :</li>
</ul>
<dl class="docutils">
<dt>&nbsp;&nbsp; Xitrum의 기본 템플릿 엔진.</dt>
<dd><a href="#id6"><span class="problematic" id="id7">`</span></a>Xitrum 프로젝트 뼈대 &lt;<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">https://github.com/xitrum-framework/xitrum-new</a>&gt;`_에서 사용하고 있습니다.</dd>
</dl>
<p>&nbsp;&nbsp; 다른 템플릿 엔진을 사용하는 것도 또한 필요가 없으면 프로젝트에서 삭제 해 버리는 것도 가능합니다.
&nbsp;&nbsp; xitrum-scalate은</p>
<blockquote>
<div><a class="reference external" href="https://github.com/chirino/scalamd">Scalate &lt;http://scalate.fusesource.org/&gt;`_와
`Scalamd</a> 에 의존하고 있습니다.</div></blockquote>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">xitrum-hazelcast</a> :</li>
</ul>
<p>&nbsp;&nbsp; 캐시와 서버의 세션 클러스터링을 하는 플러그인.
* <a class="reference external" href="https://github.com/xitrum-framework/xitrum-ko">xitrum-ko</a> :
&nbsp;&nbsp;<a class="reference external" href="http://knockoutjs.com/">Knockoutjs</a> 를 간편하게 사용할 수 있도록 하는 플러그인.</p>
<p>기타 프로젝트:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-doc">xitrum-doc</a> :</li>
</ul>
<p>&nbsp;&nbsp; <a class="reference external" href="http://xitrum-framework.github.io/guide.html">Xitrum Guide</a> 소스 코드.
* <a class="reference external" href="https://github.com/xitrum-framework/xitrum-framework.github.io">xitrum-hp</a> :
&nbsp;&nbsp; <a class="reference external" href="http://xitrum-framework.github.io/">Xitrum Homepage</a> 소스 코드.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html#document-index">목차</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro">기여자들</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-tutorial">튜토리얼</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum">Xitrum 프로젝트 만들기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">시작하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#eclipse">Eclipse 프로젝트로 만들기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#intellij-idea">IntelliJ IDEA프로젝트 만들기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">자동 리로드</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#ide">IDE를 사용하는 경우</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id7">SBT를 사용하는 경우</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dcevm">DCEVM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">무시되는 파일들</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-action_view">Action 과 view</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#normal-action">Normal Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#futureaction">FutureAction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#actor-action">Actor Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">클라이언트로의 전송</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#view">템플릿 View 파일 응답</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#currentaction">currentAction의 캐스팅</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id8">Mustache</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#coffeescript">CoffeeScript</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">레이아웃</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id10">독립적인 레이아웃 파일을 사용하지 않는 패턴</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#respondview">respondView 레이아웃을 직접 패스</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#inline-view">Inline view</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#render-fragment">Render fragment</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id13">다른 Action의 View를 응답하는 경우</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id14">하나의 Action - 여러 View사용</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#component">Component</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-restful">RESTful APIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">루트 캐싱</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#firstlast">루트의 우선순위(first、last)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#action">Action에 여러 경로를 연동</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">점을 포함하는 루트</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">정규 표현식을 이용한 라우팅</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">경로의 나머지 부분 이용</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">액션에 링크추가</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">다른 액션으로 리디랙션</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">다른 액션에 요청 전달</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax">Ajax 요청의 결정</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#anti-csrf">Anti-CSRF</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#anticsrfinput-anticsrftoken">antiCsrfInput 와 antiCsrfToken</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#csrf">CSRF 체크 생략</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#manipulate-collected-routes">Manipulate collected routes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">요청 내용 가져오기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#swagger-api">Swagger로 API 문서화 하기</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-template_engines">템플릿 엔진</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">템플릿 엔진 설정</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">템플릿 엔진 제거</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">템플릿 엔진 만들기</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-postback">포스트백</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">레이아웃</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">폼</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#form">form 이외의 사용</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">확인 다이얼로그</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">매개 변수 추가</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax">Ajax로딩중 이미지 로딩</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-xml">XML</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">XML의 이스케이프</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">XML 요소의 그룹화</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xhtml">XHTML 렌더링</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-js">JavaScript 와 JSON</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#javascript">JavaScript</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#javascript-view">JavaScript 조각을 View 에 추가하는 방법</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id1">JavaScript를 직접호출 하는 경우</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#json">JSON</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#knockout-js">Knockout.js 플러그인</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-async">비동기 응답</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#websocket">WebSocket</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#sockjs">SockJS</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#chunk">Chunk응답</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#iframe">무한iframe</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#event-source">Event Source</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-static">정적 파일</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">디스크의 정적 파일 전송</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#index-html">index.html 대체</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">404 과 500</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#webjar">WebJar에 의한 클래스 패스내의 리소스 파일 전송</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#webjars">WebJars</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#webjars-jar">WebJars 형식으로 리소스 파일을 .jar 내에 저장하기</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id6">클래스 패스내의 파일 응답</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#etag-max-age">ETag 과 max-age의 클라이언트 캐쉬</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#gzip">GZIP</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">서버 캐쉬</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-flash">Flash Socket 정책 파일</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-scopes">스코프</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">매개변수</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">매개변수 접근</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#at">&#8220;at&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#atjson">&#8220;atJson&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#requestvar">RequestVar</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">쿠키가 가능한 문자들</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#session-clear">session.clear()</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#sessionvar">SessionVar</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">세션 스토어</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">클라이언트 세션저장과 서버 세션저장</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#object-vs-val">object vs. val</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-validation">기본 검증</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#id2">검증기 수정하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-upload">파일 업로드</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax">Ajax 스타일 업로드</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-filter">액션 필터</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#before">Before 필터</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#after">After필터</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#around">Around필터</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">필터의 수행 순서</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cache">서버측 캐시</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">캐시페이지 혹은 액션</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">캐시 오브젝트</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">캐시 제거</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id15">캐쉬의 동작원리</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-util-locallrucache">xitrum.util.LocalLruCache</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-i18n">I18n</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">소스코드에 국제화 메세지 작성</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#pot">pot에 메세지 추출하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#po">po 파일 저장위치</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">언어설정</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">검증 메세지</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">복수형</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">날짜와 시간 포멧</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-log">로그</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-log">xitrum.Log 오브젝트를 바로 사용하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-log-trait">xitrum.Log trait 사용하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">로깅하기 전에 로그레벨을 체크하지 않아도 됩니다</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">로그레벨 및 출력파일 조정</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#fluentd">Fluentd 에 로그를 출력</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deploy">프로덕션 서버에 배포하기</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#package">Package 디렉토리</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-package">사용자 정의 xitrum-package</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#jvm-scala">실행중인 JVM 프로세스에 Scala 콘솔 연결</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#oracle-jdk-centos">Oracle JDK를 CentOS 나 우분투에 설차하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum">시스템이 구동될때 Xitrum을 시작하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">포트포워딩 방법</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#linux">대량연결에 대한 Linux 설정</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id13">파일 디스크립터 제한</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id14">커널 조정</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id15">백 로그에 대해</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#haproxy">HAProxy 팁</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nginx">Nginx 팁</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#heroku">Heroku에 배포하기</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id29">가입 및 리파지토리 만들기</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#procfile">Procfile 생성</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#port">Port설정 변경</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id31">로그 레벨 수정</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id32"><code class="docutils literal"><span class="pre">xitrum-package</span></code> 별칭부여</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id33">Heroku에 푸시하기</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cluster">Akka와 Hazelcast 클러스터링</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-handler">Netty 핸들러</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Netty 핸들러 구조</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">핸들러의 수정</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum">Xitrum 핸들러</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-metrics">매트릭스</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">매트릭스 수집</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#cpu">힙 메모리와 CPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">액션 매트릭스</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id4">수정된 매트릭스 수집</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">매트릭스 배포</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#xitrum">Xitrum 기본 뷰어</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#jconsole">Jconsole 뷰어</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id8">사용자 정의 매트릭스 뷰어</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">매트릭스 저장</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-howto">HOWTO</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">기본적인 인증</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id2">전체 프로젝트에 기본적인 인증을 설정하는 방법</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">특정 액션에 기본 인증을 추가</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">설정파일 로드</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#json">JSON 파일</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id5">설정파일</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#typesafe">Typesafe한 설정파일</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">직렬화 및 역직렬화</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">데이터 암호화</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">동일한 도매인내의 여러 사이트</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#markdown-html">Markdown 텍스트를 HTML 로 변환</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">파일의 모니터링</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id11">임시 디렉토리</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id12">비디오 스트리밍</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deps">의존도</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">라이브러리 의존도</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">관련 프로젝트</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">Xitrum Scala Web Framework Guide 3.25.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2010, Ngoc Dao.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>