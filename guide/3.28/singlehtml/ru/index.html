<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Документация Xitrum Scala Web Framework Guide 3.28.6</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.28.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="None" href="index.html#document-index" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">Документация Xitrum Scala Web Framework Guide 3.28.6</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="xitrum-guide">
<h1>Xitrum Guide<a class="headerlink" href="#xitrum-guide" title="Ссылка на этот заголовок">¶</a></h1>

<p>
  <a href="../../xitrum-ru.pdf" title="PDF" style="float:left"><img src="../../../pdf-ru.png"/></a>
  <a href="../../xitrum-ru.pdf" title="PDF">Скачать PDF</a></p>
</p>
<div style="clear:both"></div>

<p><a class="reference external" href="http://xitrum-framework.github.io/guide.html">Есть также английский, японский, корейский и вьетнамский версии.</a></p>
<div class="toctree-wrapper compound">
<span id="document-intro"></span><div class="section" id="id1">
<h2>Введение<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre>+--------------------+
|      Клиенты       |
+--------------------+
          |
+--------------------+
|       Netty        |
+--------------------+
|       Xitrum       |
| +----------------+ |
| | HTTP(S) Сервер | |
| |----------------| |
| | Web фреймворк  | |  &lt;- Akka, Hazelcast -&gt; Другие экземпляры
| +----------------+ |
+--------------------+
|     Приложение     |
+--------------------+
</pre></div>
</div>
<p>Xitrum - асинхронный и масштабируемый Scala веб фреймворк и HTTP(S) сервер. Он построен
на базе <a class="reference external" href="http://netty.io/">Netty</a> и <a class="reference external" href="http://akka.io/">Akka</a>.</p>
<p>Из отзывов <a class="reference external" href="https://groups.google.com/group/xitrum-framework/msg/d6de4865a8576d39">пользователей</a>:</p>
<blockquote>
<div><p>Wow, this is a really impressive body of work, arguably the most
complete Scala framework outside of Lift (but much easier to use).</p>
<p><a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> is truly a full stack web framework, all the bases are covered,
including wtf-am-I-on-the-moon extras like ETags, static file cache
identifiers &amp; auto-gzip compression. Tack on built-in JSON converter,
before/around/after interceptors, request/session/cookie/flash scopes,
integrated validation (server &amp; client-side, nice), built-in cache
layer (<a class="reference external" href="http://www.hazelcast.org/">Hazelcast</a>), i18n a la GNU gettext, Netty (with Nginx, hello
blazing fast), etc. and you have, wow.</p>
</div></blockquote>
<div class="section" id="id3">
<h3>Возможности<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<ul class="simple">
<li>Безопасный относительно типов (typesafe) во всех отношениях где это возможно.</li>
<li>Полностью асинхронный. Необязательно слать ответ на запрос немедленно, можно запустить сложные вычисления и дать ответ, когда он будет готов. Поддерживаются Long polling, chunked response, WebSockets, SockJs, EventStream.</li>
<li>Встроенный веб сервер основан на высоко производительном <a class="reference external" href="http://netty.io/">Netty</a>, отдача статических файлов сравнима по производительности с <a class="reference external" href="https://gist.github.com/3293596">Nginx</a>.</li>
<li>Обширные возможности для кэширования как на серверной так и на клиентской стороне.
На уровне сервера файлы маленького размера сохраняются в памяти, большие файлы пересылаются с использованием NIO&#8217;s zero copy.
На уровне фреймворка есть возможность сохранить в кэш страницу, действие (action) или объект в стиле Rails.
Учтены рекомендации <a class="reference external" href="http://code.google.com/speed/page-speed/docs/rules_intro.html">Google</a>.
Ревалидация кэша возможна в любой момент.</li>
<li>Для статических файлов поддерживаются <a class="reference external" href="http://en.wikipedia.org/wiki/Byte_serving">Range запросы</a>. Эта функция необходима для отдачи видео файлов.</li>
<li>Поддержка <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>.</li>
<li>Автоматический расчет маршрутов (routes) приложения в стиле JAX-RS и Rails. Нет необходимости в объявлении маршрутов в каком-либо файле. Благодаря этому Xitrum позволяет объединять несколько приложений в одно. Все маршруты из jar файлов объединяются и работают как единое приложение.</li>
<li>Обратная маршрутизация: генерация ссылок на контроллеры и действия.</li>
<li>Генерация документации на основе <a class="reference external" href="http://swagger.wordnik.com/">Swagger Doc</a>.</li>
<li>Автоматическая перезагрузка классов и маршрутов при изменении (не требует перезапуска сервера).</li>
<li>Представления (views) могут быть созданы с использованием <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a>, Scala или xml (во всех случаях происходит проверка типов на этапе компиляции).</li>
<li>Сессии могут хранится в куках или кластеризованны, например, с помощью <a class="reference external" href="http://www.hazelcast.org/">Hazelcast</a>.</li>
<li>Встроенная валидация с <a class="reference external" href="http://jqueryvalidation.org/">jQuery</a> (опционально).</li>
<li>i18n на основе <a class="reference external" href="http://en.wikipedia.org/wiki/GNU_gettext">GNU gettext</a>. Автоматическая генерация pot файлов из исходников. gettext поддерживает множественные и единственные формы числа.</li>
</ul>
<p>Идеологически Xitrum находится между <a class="reference external" href="https://github.com/scalatra/scalatra">Scalatra</a>
и <a class="reference external" href="http://liftweb.net/">Lift</a>: более функциональный чем Scalatra и гораздо проще чем Lift. Вы можете очень просто создавать RESTful APIs и postbacks. <a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a>
является controller-first фреймворком.</p>
<p><a class="reference internal" href="index.html#document-deps"><em>Связанные сcылки</em></a> список демонстрационных проектов, плагинов и прочее.</p>
</div>
<div class="section" id="id7">
<h3>Авторы<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
<p><a class="reference external" href="http://xitrum-framework.github.io/">Xitrum</a> - проект с открытым <a class="reference external" href="https://github.com/xitrum-framework/xitrum">исходным кодом</a> проект, вступайте в официальную <a class="reference external" href="http://groups.google.com/group/xitrum-framework">Google группу</a>.</p>
<p>Авторы в списке упорядочены по времени их
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/graphs/contributors">первого вклада в проект</a>.</p>
<p>(*): Участники команды разработки Xitrum.</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/ngocdaothanh">Ngoc Dao (*)</a></li>
<li><a class="reference external" href="https://github.com/alide">Linh Tran</a></li>
<li><a class="reference external" href="https://github.com/earldouglas">James Earl Douglas</a></li>
<li><a class="reference external" href="https://github.com/caiiiycuk">Aleksander Guryanov</a></li>
<li><a class="reference external" href="https://github.com/georgeOsdDev">Takeharu Oshida (*)</a></li>
<li><a class="reference external" href="https://github.com/kimkha">Nguyen Kim Kha</a></li>
<li><a class="reference external" href="https://github.com/murz">Michael Murray</a></li>
</ul>
</div>
</div>
<span id="document-tutorial"></span><div class="section" id="id1">
<h2>Как начать<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Эта глава описывает как создать и запустить Xitrum проект.
<strong>Предполагается что вы знакомы с операционной системой Linux и у вас установлена Java.</strong></p>
<div class="section" id="xitrum">
<h3>Создание пустого проекта Xitrum<a class="headerlink" href="#xitrum" title="Ссылка на этот заголовок">¶</a></h3>
<p>Для создания проекта, скачайте файл
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/archive/master.zip">xitrum-new.zip</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>wget -O xitrum-new.zip https://github.com/xitrum-framework/xitrum-new/archive/master.zip
</pre></div>
</div>
<p>или:</p>
<div class="highlight-python"><div class="highlight"><pre>curl -L -o xitrum-new.zip https://github.com/xitrum-framework/xitrum-new/archive/master.zip
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Запуск<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Сложившийся стандарт запуска Scala проектов - использование
<a class="reference external" href="https://github.com/harrah/xsbt/wiki/Setup">SBT</a>. Проект созданный из шаблона уже включает
SBT в директории <code class="docutils literal"><span class="pre">sbt</span></code>. Если вы хотите установить SBT самостоятельно, воспользуйтесь
<a class="reference external" href="https://github.com/harrah/xsbt/wiki/Setup">руководством</a>.</p>
<p>Перейдите в директорию созданного проекта и выполните команду <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">run</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>unzip xitrum-new.zip
cd xitrum-new
sbt/sbt run
</pre></div>
</div>
<p>Данная команда выполнит скачивание всех <a class="reference internal" href="index.html#document-deps"><em>зависимостей</em></a>, компиляцию проекта
и запуск main-класса <code class="docutils literal"><span class="pre">quickstart.Boot</span></code>, который запустит сервер. В консоль будут напечатаны все
маршруты (routes) проекта:</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] Load routes.cache or recollect routes...
[INFO] Normal routes:
GET  /  quickstart.action.SiteIndex
[INFO] SockJS routes:
xitrum/metrics/channel  xitrum.metrics.XitrumMetricsChannel  websocket: true, cookie_needed: false
[INFO] Error routes:
404  quickstart.action.NotFoundError
500  quickstart.action.ServerError
[INFO] Xitrum routes:
GET        /webjars/swagger-ui/2.0.17/index                            xitrum.routing.SwaggerUiVersioned
GET        /xitrum/xitrum.js                                           xitrum.js
GET        /xitrum/metrics/channel                                     xitrum.sockjs.Greeting
GET        /xitrum/metrics/channel/:serverId/:sessionId/eventsource    xitrum.sockjs.EventSourceReceive
GET        /xitrum/metrics/channel/:serverId/:sessionId/htmlfile       xitrum.sockjs.HtmlFileReceive
GET        /xitrum/metrics/channel/:serverId/:sessionId/jsonp          xitrum.sockjs.JsonPPollingReceive
POST       /xitrum/metrics/channel/:serverId/:sessionId/jsonp_send     xitrum.sockjs.JsonPPollingSend
WEBSOCKET  /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocket
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr            xitrum.sockjs.XhrPollingReceive
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr_send       xitrum.sockjs.XhrSend
POST       /xitrum/metrics/channel/:serverId/:sessionId/xhr_streaming  xitrum.sockjs.XhrStreamingReceive
GET        /xitrum/metrics/channel/info                                xitrum.sockjs.InfoGET
WEBSOCKET  /xitrum/metrics/channel/websocket                           xitrum.sockjs.RawWebSocket
GET        /xitrum/metrics/viewer                                      xitrum.metrics.XitrumMetricsViewer
GET        /xitrum/metrics/channel/:iframe                             xitrum.sockjs.Iframe
GET        /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocketGET
POST       /xitrum/metrics/channel/:serverId/:sessionId/websocket      xitrum.sockjs.WebSocketPOST
[INFO] HTTP server started on port 8000
[INFO] HTTPS server started on port 4430
[INFO] Xitrum started in development mode
</pre></div>
</div>
<p>Во время запуска, все маршруты будут собраны и напечатаны в лог. Это очень удобно
иметь список всех маршрутов проекта, если вы планируете написать документацию для своего
RESTful API.</p>
<p>Откройте <a class="reference external" href="http://localhost:8000/">http://localhost:8000/</a> или <a class="reference external" href="https://localhost:4430/">https://localhost:4430/</a> в браузере. В консоль будет
напечатана информация о запросе:</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] GET quickstart.action.SiteIndex, 1 [ms]
</pre></div>
</div>
</div>
<div class="section" id="eclipse">
<h3>Импорт проекта в Eclipse<a class="headerlink" href="#eclipse" title="Ссылка на этот заголовок">¶</a></h3>
<p><a class="reference external" href="http://scala-ide.org/">Использование Eclipse для написания Scala кода</a>.</p>
<p>Из директории проекта выполните команду:</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt eclipse
</pre></div>
</div>
<p>Файл Eclipse проекта  <code class="docutils literal"><span class="pre">.project</span></code> будет создан из описание проекта <code class="docutils literal"><span class="pre">build.sbt</span></code>.
Откройте Eclipse и импортируйте созданный проект.</p>
</div>
<div class="section" id="intellij">
<h3>Импорт проекта в IntelliJ<a class="headerlink" href="#intellij" title="Ссылка на этот заголовок">¶</a></h3>
<p><a class="reference external" href="http://www.jetbrains.com/idea/">IntelliJ</a>, поддерживает Scala на очень хорошем уровне.</p>
<p>С установленным его Scala плагин, просто откройте свой проект SBT,
Вам не нужно для создания файлов проекта, как с Eclipse.</p>
</div>
<div class="section" id="id5">
<h3>Автоматическая перезагрузка<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum позволяет перезагружать .class файлы (hot swap) без перезапуска программы.
Однако, что бы избежать проблем с производительностью и получить более стабильное
приложение, эта функция должна быть использована только в режиме разработчика
(development mode).</p>
<div class="section" id="ide">
<h4>Запуск в IDE<a class="headerlink" href="#ide" title="Ссылка на этот заголовок">¶</a></h4>
<p>Во время разработки в IDE на подобии Eclipse или IntelliJ, автоматически будет происходить
перезагрузка кода.</p>
</div>
<div class="section" id="id6">
<h4>Запуск в SBT<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h4>
<p>При использовании SBT, нужно открыть две консоли:</p>
<ul class="simple">
<li>В первой выполните <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">run</span></code>. Эта команда запустить программу и будет
перезагружать .class файлы когда они изменятся.</li>
<li>Во второй <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">~compile</span></code>. При изменении исходных файлов они будут автоматически
компилироваться в .class файлы.</li>
</ul>
<p>В директории sbt расположен <a class="reference external" href="https://github.com/xitrum-framework/agent7">agent7.jar</a>.
Его задача заключается в перезагрузке .class файлов в рабочей директории (и под директориях).
Внутри скрипта <code class="docutils literal"><span class="pre">sbt/sbt</span></code>, agent7.jar подключается специальной опцией <code class="docutils literal"><span class="pre">-javaagent:agent7.jar</span></code>.</p>
</div>
<div class="section" id="dcevm">
<h4>DCEVM<a class="headerlink" href="#dcevm" title="Ссылка на этот заголовок">¶</a></h4>
<p>Обычно JVM позволяет перезагружать только тела методов. Вы можете использовать
<a class="reference external" href="https://github.com/dcevm/dcevm">DCEVM</a> - открытую модификацию Java HotSpot VM,
которая позволяет полностью перезагружать классы.</p>
<p>Вы можете установить DCEVM двумя способами:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/dcevm/dcevm/releases">Изменить</a> существующую установку Java.</li>
<li>Установить <a class="reference external" href="http://dcevm.nentjes.com/">собранную</a> версию (проще).</li>
</ul>
<p>В первом варианте:</p>
<ul class="simple">
<li>DCEVM будет включен постоянно.</li>
<li>Или будет установлен в качестве &#8220;альтернативной&#8221; JVM. В этом случае, что бы включить
DCEVM, при запуске <code class="docutils literal"><span class="pre">java</span></code> нужно указывать опцию <code class="docutils literal"><span class="pre">-XXaltjvm=dcevm</span></code>.
Например, вам нужно добавить <code class="docutils literal"><span class="pre">-XXaltjvm=dcevm</span></code> в скрипт <code class="docutils literal"><span class="pre">sbt/sbt</span></code>.</li>
</ul>
<p>Если вы используете IDE (например, Eclipse или IntelliJ), вам нужно настроить
их на использование DCEVM при работе с вашим проектом.</p>
<p>Если вы используете SBT, вам нужно настроить переменную окружения <code class="docutils literal"><span class="pre">PATH</span></code>
так что бы команда <code class="docutils literal"><span class="pre">java</span></code> была из DCEVM (не из стандартной JVM). Вам
так же нужен <code class="docutils literal"><span class="pre">javaagent</span></code> описанный выше, поскольку DCEVM поддерживает изменения классов,
но сам их не перезагружает.</p>
<p>Смотри <a class="reference external" href="http://javainformed.blogspot.jp/2014/01/jrebel-free-alternative.html">DCEVM - бесплатная альтернатива JRebel</a>.</p>
</div>
</div>
<div class="section" id="id10">
<h3>Список игнорируемых файлов<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h3>
<p>При создании проекта <a class="reference internal" href="index.html#document-tutorial"><em>по шаблону</em></a>, есть ряд файлов которые нужно
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/.gitignore">исключить</a> из системы контроля версий:</p>
<div class="highlight-python"><div class="highlight"><pre>.*
log
project/project
project/target
target
tmp
</pre></div>
</div>
</div>
</div>
<span id="document-action_view"></span><div class="section" id="id1">
<h2>Контроллеры и представления<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Xitrum располагает тремя видами контроллеров или действий (actions):
стандартный контроллер <code class="docutils literal"><span class="pre">Action</span></code>, <code class="docutils literal"><span class="pre">FutureAction</span></code> и актор контроллер <code class="docutils literal"><span class="pre">ActorAction</span></code>.</p>
<div class="section" id="normal-action">
<h3>Стандартный контроллер (normal action)<a class="headerlink" href="#normal-action" title="Ссылка на этот заголовок">¶</a></h3>
<p>Реализация данного контроллера синхронная.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends Action {
  def execute() {
    respondText(&quot;Hello&quot;)
  }
}
</pre></div>
</div>
<p>В случае наследования от xitrum.Action, ваш код будет выполнятся в потоке Netty&#8217;s IO.
Это допустимо только в случае если ваш контроллер очень легковесный и не блокирующий
(возвращает ответ немедленно). Иначе Netty не сможет принимать новые подключения или
отправлять запросы клиентам.</p>
</div>
<div class="section" id="futureaction">
<h3>FutureAction<a class="headerlink" href="#futureaction" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.FutureAction
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends FutureAction {
  def execute() {
    respondText(&quot;hi&quot;)
  }
}
</pre></div>
</div>
<p>В случае наследования от xitrum.FutureAction, код контроллера будет выполнятся в отдельном потоке (в том же пуле что и <code class="docutils literal"><span class="pre">ActorAction</span></code>) не занимая потоки Netty.</p>
</div>
<div class="section" id="actor-action">
<h3>Актор контроллер (actor action)<a class="headerlink" href="#actor-action" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если вы хотите что бы контроллер был актором Akka наследуйтесь от <code class="docutils literal"><span class="pre">ActorAction</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.concurrent.duration._

import xitrum.ActorAction
import xitrum.annotation.GET

@GET(&quot;hello&quot;)
class HelloAction extends ActorAction with AppAction {
  def execute() {
    // See Akka doc about scheduler
    import context.dispatcher
    context.system.scheduler.scheduleOnce(3 seconds, self, System.currentTimeMillis())

    // See Akka doc about &quot;become&quot;
    context.become {
      case pastTime =&gt;
        respondInlineView(s&quot;It&#39;s $pastTime Unix ms 3s ago.&quot;)
    }
  }
}
</pre></div>
</div>
<p>Экземпляр актора будет создан на каждый запрос. Актор будет остановлен в момент закрытия подключения
или когда ответ будет отправлен клиенту. Для chunked запросов актор будет остановлен когда будет
отправлен последний chunk.</p>
<p>Актор будет выполняться в пуле потоков Akka в системе с именем &#8220;xitrum&#8221;.</p>
</div>
<div class="section" id="id2">
<h3>Отправка ответа клиенту<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Что бы отправить данные клиенту используются функции:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondView</span></code>: при ответе использует шаблон ассоциированный с контроллером</li>
<li><code class="docutils literal"><span class="pre">respondInlineView</span></code>: при ответе использует шаблон переданный как аргумент</li>
<li><code class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></code>: ответ строкой &#8220;plain/text&#8221;</li>
<li><code class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></code>: ответ строкой &#8220;text/html&#8221;</li>
<li><code class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>: преобразовать Scala объект в JSON и ответить</li>
<li><code class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></code>: совмещение предыдущих двух</li>
<li><code class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondBinary</span></code>: ответ массивом байт</li>
<li><code class="docutils literal"><span class="pre">respondFile</span></code>: переслать файл с использованием техники <a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a>  (aka send-file)</li>
<li><code class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></code></li>
</ul>
</div>
<div class="section" id="id3">
<h3>Шаблонизация<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p>Каждый контроллер может быть связан с шаблоном <a class="reference external" href="http://scalate.fusesource.org/">Scalate</a>.
В этом случае при вызове метода <cite>respondView</cite> будет задействован данный шаблон для формирования
ответа.</p>
<p>scr/main/scala/mypackage/MyAction.scala:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends Action {
  def execute() {
    respondView()
  }

  def hello(what: String) = &quot;Hello %s&quot;.format(what)
}
</pre></div>
</div>
<p>scr/main/scalate/mypackage/MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage.MyAction

!!! 5
html
  head
    != antiCsrfMeta
    != xitrumCss
    != jsDefaults
    title Welcome to Xitrum

  body
    a(href={url}) Path to the current action
    p= currentAction.asInstanceOf[MyAction].hello(&quot;World&quot;)

    != jsForView
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xitrumCss</span></code> подключает стандартные CSS встроенные в Xitrum. Вы можете убрать их если
они не требуются</li>
<li><code class="docutils literal"><span class="pre">jsDefaults</span></code> подключает jQuery, jQuery Validate и пр. Если используется, вызов должен
быть размешен в секции &lt;head&gt;</li>
<li><code class="docutils literal"><span class="pre">jsForView</span></code> использует функцию контроллера <code class="docutils literal"><span class="pre">jsAddToView</span></code> и  включает JS фаргмент в шаблон.
Если используется, вызов должен быть в конце шаблона</li>
</ul>
<p>В шаблонах допускается использование любых методов из трейта <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Action.scala">xitrum.Action</a>. Дополнительно можно использовать утильные методы Scalate,
такие как <code class="docutils literal"><span class="pre">unescape</span></code> (см. <a class="reference external" href="http://scalate.fusesource.org/documentation/index.html">Scalate doc</a>).</p>
<p>Синтаксис <a class="reference external" href="http://scalate.fusesource.org/documentation/jade.html">Jade</a> используется по умолчанию для Scalate.
Так же вы можете использовать синтаксис <a class="reference external" href="http://scalate.fusesource.org/documentation/mustache.html">Mustache</a>,
<a class="reference external" href="http://scalate.fusesource.org/documentation/scaml-reference.html">Scaml</a> или
<a class="reference external" href="http://scalate.fusesource.org/documentation/ssp-reference.html">Ssp</a>.
Что бы установить предпочитаемый синтаксис, отредактируйте файл xitrum.conf в директории config.</p>
<p>Кроме этого, метод <cite>respondView</cite> позволяет переопределять синтаксис шаблона.</p>
<div class="highlight-python"><div class="highlight"><pre>respondView(Map(&quot;type&quot; -&gt;&quot;mustache&quot;))
</pre></div>
</div>
<div class="section" id="currentaction">
<h4>currentAction и приведение типов<a class="headerlink" href="#currentaction" title="Ссылка на этот заголовок">¶</a></h4>
<p>Если известен подкласс контроллера который используется с шаблоном, то можно выполнить
приведение <code class="docutils literal"><span class="pre">currentAction</span></code> к этому подклассу.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span><span class="o">=</span> <span class="n">currentAction</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="p">[</span><span class="n">MyAction</span><span class="p">]</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Или так:</p>
<div class="highlight-python"><div class="highlight"><pre>- val myAction = currentAction.asInstanceOf[MyAction]; import myAction._

p= hello(&quot;World&quot;)
p= hello(&quot;Scala&quot;)
p= hello(&quot;Xitrum&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>Mustache<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h4>
<p>Важно:</p>
<ul class="simple">
<li><a class="reference external" href="http://mustache.github.com/mustache.5.html">Mustache syntax</a></li>
<li><a class="reference external" href="http://scalate.fusesource.org/documentation/mustache.html">Scalate implementation</a></li>
</ul>
<p>Mustache намеренно ограничивает возможности шаблонизации до минимума логики. Поэтому многие
возможности используемые в Jade не применимы в Mustache.</p>
<p>Для передачи моделей из контроллера в шаблон необходимо использовать <code class="docutils literal"><span class="pre">at</span></code>:</p>
<p>Контролер:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">at</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;Jack&quot;</span>
<span class="n">at</span><span class="p">(</span><span class="s">&quot;xitrumCss&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">xitrumCss</span>
</pre></div>
</div>
<p>Шаблон Mustache:</p>
<div class="highlight-python"><div class="highlight"><pre>Мое имя {{name}}
{{xitrumCss}}
</pre></div>
</div>
<p>Примечание: следующие слова зарезервированы и не могут быть использованы
как ключ в <code class="docutils literal"><span class="pre">at</span></code>:</p>
<ul class="simple">
<li>&#8220;context&#8221;: Scalate объект предоставляющий методы <code class="docutils literal"><span class="pre">unescape</span></code> и пр.</li>
<li>&#8220;helper&#8221;: текущий контроллер</li>
</ul>
</div>
<div class="section" id="coffeescript">
<h4>CoffeeScript<a class="headerlink" href="#coffeescript" title="Ссылка на этот заголовок">¶</a></h4>
<p>Scalate позволяет включать CoffeeScript в шаблоны
<a class="reference external" href="http://scalate.fusesource.org/documentation/jade-syntax.html#filters">:coffeescript filter</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>body
  :coffeescript
    alert &quot;Hello, Coffee!&quot;
</pre></div>
</div>
<p>Результат:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;body&gt;
  &lt;script type=&#39;text/javascript&#39;&gt;
    //&lt;![CDATA[
      (function() {
        alert(&quot;Hello, Coffee!&quot;);
      }).call(this);
    //]]&gt;
  &lt;/script&gt;
&lt;/body&gt;
</pre></div>
</div>
<p>Однако, эта возможность работает достаточно <a class="reference external" href="http://groups.google.com/group/xitrum-framework/browse_thread/thread/6667a7608f0dc9c7">медленно</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>jade+javascript+1thread: 1-2ms for page
jade+coffesscript+1thread: 40-70ms for page
jade+javascript+100threads: ~40ms for page
jade+coffesscript+100threads: 400-700ms for page
</pre></div>
</div>
<p>Рекомендуется самостоятельно компилировать CoffeeScript в JavaScript для оптимизации производительности.</p>
</div>
</div>
<div class="section" id="layout">
<h3>Макет (Layout)<a class="headerlink" href="#layout" title="Ссылка на этот заголовок">¶</a></h3>
<p>При использовании <code class="docutils literal"><span class="pre">respondView</span></code> или <code class="docutils literal"><span class="pre">respondInlineView</span></code>, Xitrum
выполняет шаблонизацию в строку, и присваивает результат в переменную <code class="docutils literal"><span class="pre">renderedView</span></code>.
Затем, Xitrum вызывает метод <code class="docutils literal"><span class="pre">layout</span></code> текущего контроллера и отправляет результат работы
этого метода как ответ сервера.</p>
<p>По умолчанию метод <code class="docutils literal"><span class="pre">layout</span></code> просто возвращает переменную <code class="docutils literal"><span class="pre">renderedView</span></code>.
В случае перекрытия этого метода появляется возможность декорировать шаблон.
Таким образом достаточно просто реализовать произвольный макет (layout) для всех контроллеров.</p>
<p>Механизм <code class="docutils literal"><span class="pre">layout</span></code> очень простой и понятный. Никакой магии. Для удобства, вы можете
думать что Xitrum не поддерживает макеты (layout), есть только метод <code class="docutils literal"><span class="pre">layout</span></code> и вы вольны
делать с ним все что захотите.</p>
<p>Обычно, создается базовый класс для реализация стандартного макета:</p>
<p>src/main/scala/mypackage/AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage
import xitrum.Action

trait AppAction extends Action {
  override def layout = renderViewNoLayout[AppAction]()
}
</pre></div>
</div>
<p>src/main/scalate/mypackage/AppAction.jade</p>
<div class="highlight-python"><div class="highlight"><pre>!!! 5
html
  head
    != antiCsrfMeta
    != xitrumCss
    != jsDefaults
    title Welcome to Xitrum

  body
    != renderedView
    != jsForView
</pre></div>
</div>
<p>src/main/scala/mypackage/MyAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends AppAction {
  def execute() {
    respondView()
  }

  def hello(what: String) = &quot;Hello %s&quot;.format(what)
}
</pre></div>
</div>
<p>scr/main/scalate/mypackage/MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage.MyAction

a(href={url}) Path to the current action
p= currentAction.asInstanceOf[MyAction].hello(&quot;World&quot;)
</pre></div>
</div>
<div class="section" id="id6">
<h4>Макет в отдельном файле<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h4>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="respondview">
<h4>Использование макета непосредственно в respondView<a class="headerlink" href="#respondview" title="Ссылка на этот заголовок">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>val specialLayout = () =&gt;
  DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )

respondView(specialLayout _)
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h3>Внутренние представления<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
<p>Обычно, шаблон описывается в отдельном файле, но существует возможность писать
шаблоны непосредственно в контроллере:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;myAction&quot;)
class MyAction extends Action {
  def execute() {
    val s = &quot;World&quot;  // Will be automatically HTML-escaped
    respondInlineView(
      &lt;p&gt;Hello &lt;em&gt;{s}&lt;/em&gt;!&lt;/p&gt;
    )
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>Фрагменты<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p>MyAction.jade:
<code class="docutils literal"><span class="pre">scr/main/scalate/mypackage/MyAction.jade</span></code></p>
<p>Шаблонизация с помощью фрагмента
<code class="docutils literal"><span class="pre">scr/main/scalate/mypackage/_MyFragment.jade</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">renderFragment</span><span class="p">[</span><span class="n">MyAction</span><span class="p">](</span><span class="s">&quot;MyFragment&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Можно записать короче, если <code class="docutils literal"><span class="pre">MyAction</span></code> - текущий контроллер:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">renderFragment</span><span class="p">(</span><span class="s">&quot;MyFragment&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>Использование шаблона смежного контроллера<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h3>
<p>Использование метода <code class="docutils literal"><span class="pre">respondView[ClassName]()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.{GET, POST}

@GET(&quot;login&quot;)
class LoginFormAction extends Action {
  def execute() {
    // Respond scr/main/scalate/mypackage/LoginFormAction.jade
    respondView()
  }
}

@POST(&quot;login&quot;)
class DoLoginAction extends Action {
  def execute() {
    val authenticated = ...
    if (authenticated)
      redirectTo[HomeAction]()
    else
      // Reuse the view of LoginFormAction
      respondView[LoginFormAction]()
  }
}
</pre></div>
</div>
<div class="section" id="id10">
<h4>Один контроллер - много представлений<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h4>
<p>Использование нескольких шаблонов для одного контроллера:</p>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.Action
import xitrum.annotation.GET

// Шаблоны автоматически не маршрутизируются
// scr/main/scalate/mypackage/HomeAction_NormalUser.jade
// scr/main/scalate/mypackage/HomeAction_Moderator.jade
// scr/main/scalate/mypackage/HomeAction_Admin.jade
trait HomeAction_NormalUser extends Action
trait HomeAction_Moderator  extends Action
trait HomeAction_Admin      extends Action

@GET(&quot;&quot;)
class HomeAction extends Action {
  def execute() {
    val userType = ...
    userType match {
      case NormalUser =&gt; respondView[HomeAction_NormalUser]()
      case Moderator  =&gt; respondView[HomeAction_Moderator]()
      case Admin      =&gt; respondView[HomeAction_Admin]()
    }
  }
}
</pre></div>
</div>
<p>Использование дополнительных не автоматических маршрутов выглядит утомительно, однако
это более безопасно относительно типов (typesafe).</p>
<p>Вы также можете использовать `` String`` указать местоположение шаблона:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_NormalUser&quot;</span><span class="p">)</span>
<span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_Moderator&quot;</span><span class="p">)</span>
<span class="n">respondView</span><span class="p">(</span><span class="s">&quot;mypackage/HomeAction_Admin&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id11">
<h3>Компонент<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h3>
<p>Компоненты позволяют создавать переиспользуемое поведение и могут быть включены
во множество представлений. Концептуально компонент очень близок к контроллеру, но:</p>
<ul class="simple">
<li>Не имеет маршрутов, поэтому отсутствует метод <code class="docutils literal"><span class="pre">execute</span></code>.</li>
<li>Компонент не отправляет ответ сервера, он просто выполняет шаблонизацию фрагмента.
Поэтому внутри компонента, вместо вызовов <code class="docutils literal"><span class="pre">respondXXX</span></code>, необходимо использовать <code class="docutils literal"><span class="pre">renderXXX</span></code>.</li>
<li>Как и контроллеры, компонент может иметь ни одного, одно или множество связанных представлений.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>package mypackage

import xitrum.{FutureAction, Component}
import xitrum.annotation.GET

class CompoWithView extends Component {
  def render() = {
    // Render associated view template, e.g. CompoWithView.jade
    // Note that this is renderView, not respondView!
    renderView()
  }
}

class CompoWithoutView extends Component {
  def render() = {
    &quot;Hello World&quot;
  }
}

@GET(&quot;foo/bar&quot;)
class MyAction extends FutureAction {
  def execute() {
    respondView()
  }
}
</pre></div>
</div>
<p>MyAction.jade:</p>
<div class="highlight-python"><div class="highlight"><pre>- import mypackage._

!= newComponent[CompoWithView]().render()
!= newComponent[CompoWithoutView]().render()
</pre></div>
</div>
</div>
</div>
<span id="document-restful"></span><div class="section" id="restful-apis">
<h2>RESTful APIs<a class="headerlink" href="#restful-apis" title="Ссылка на этот заголовок">¶</a></h2>
<p>Разработка RESTful APIs с использованием Xitrum.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;articles&quot;)
class ArticlesIndex extends Action {
  def execute() {...}
}

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends Action {
  def execute() {...}
}
</pre></div>
</div>
<p>Подобным образом описываются POST, PUT, PATCH, DELETE, и OPTIONS запросы.
Xitrum автоматически обрабатывает HEAD запросы как GET с пустым ответом.</p>
<p>Для HTTP клиентов не поддерживающих PUT и DELETE (например, обычные браузеры), используется метод POST c параметрами <code class="docutils literal"><span class="pre">_method=put</span></code> или <code class="docutils literal"><span class="pre">_method=delete</span></code> внутри тела запроса.</p>
<p>При старте веб приложения, Xitrum сканирует аннотации, создает таблицу маршрутизации
и печатает ее в лог. Из лога понятно какое API приложение поддерживает на данный момент:</p>
<div class="highlight-python"><div class="highlight"><pre>[INFO] Routes:
GET /articles     quickstart.action.ArticlesIndex
GET /articles/:id quickstart.action.ArticlesShow
</pre></div>
</div>
<p>Маршруты (routes) автоматически строятся в духе JAX-RS и Rails. Нет необходимости
объявлять все маршруты в одном месте. Допускается включать одно приложение в другое.
Например, движок блога можно упаковать в JAR файл и подключить его в другое приложение,
после этого у приложения появятся все возможности блога. Маршрутизация осуществляется
в два направления, можно генерировать URL по контроллеру (обратная маршрутизация).
Автоматическое документирование ваших маршрутов можно выполнить используя
<a class="reference external" href="http://swagger.wordnik.com/">Swagger Doc</a>.</p>
<div class="section" id="id1">
<h3>Кэш маршрутов<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h3>
<p>Для более быстро скорости запуска, маршруты кэшируются в файл <code class="docutils literal"><span class="pre">routes.cache</span></code>.
В режиме разработчика, этот файл не используется. В случае изменения зависимостей
содержащих маршруты, необходимо удалить <code class="docutils literal"><span class="pre">routes.cache</span></code>. Этот файл не должен попасть
в ваши систему контроля версий.</p>
</div>
<div class="section" id="id2">
<h3>Очередность маршрутов<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Возможно вам потребуется организовать маршруты в определенном порядке.</p>
<div class="highlight-python"><div class="highlight"><pre>/articles/:id --&gt; ArticlesShow
/articles/new --&gt; ArticlesNew
</pre></div>
</div>
<p>В данном случае необходимо что бы второй маршрут был проверен первым.
Для этих целей нужно использовать аннотацию <code class="docutils literal"><span class="pre">First</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.{GET, First}

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends Action {
  def execute() {...}
}

@First  // This route has higher priority than &quot;ArticlesShow&quot; above
@GET(&quot;articles/new&quot;)
class ArticlesNew extends Action {
  def execute() {...}
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Last</span></code> работает помещает маршрут на обработку последним.</p>
</div>
<div class="section" id="id3">
<h3>Несколько маршрутов для одного контроллера<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;image&quot;, &quot;image/:format&quot;)
class Image extends Action {
  def execute() {
    val format = paramo(&quot;format&quot;).getOrElse(&quot;png&quot;)
    // ...
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>Точка в маршруте<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;, &quot;articles/:id.:format&quot;)
class ArticlesShow extends Action {
  def execute() {
    val id     = param[Int](&quot;id&quot;)
    val format = paramo(&quot;format&quot;).getOrElse(&quot;html&quot;)
    // ...
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>Регулярные выражения в маршруте<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Регулярные выражения могут быть использованы для задания ограничений в маршруте:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">GET</span><span class="p">(</span><span class="s">&quot;articles/:id&lt;[0-9]+&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>Обработка не стандартных маршрутов<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<p>Использование символа <code class="docutils literal"><span class="pre">/</span></code> не допускается в именах параметров. Если есть необходимость в его
использовании вы можете определить маршрут следующим образом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">GET</span><span class="p">(</span><span class="s">&quot;service/:id/proxy/:*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Например, данный маршрут будет обрабатывать запросы:</p>
<div class="highlight-python"><div class="highlight"><pre>/service/123/proxy/http://foo.com/bar
</pre></div>
</div>
<p>Извлечение значение из части <code class="docutils literal"><span class="pre">:*</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>val url = param(&quot;*&quot;)  // Будет &quot;http://foo.com/bar&quot;
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>Ссылка на контроллер<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum пытается быть достаточно безопасным. Не пишите ссылки самостоятельно (в явном виде).
Используйте генератор ссылок:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href={url[ArticlesShow](&quot;id&quot; -&gt; myArticle.id)}&gt;{myArticle.title}&lt;/a&gt;
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>Редирект на контроллер<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p>Читайте подробнее про <a class="reference external" href="http://en.wikipedia.org/wiki/URL_redirection">редирект</a>.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{GET, POST}

@GET(&quot;login&quot;)
class LoginInput extends Action {
  def execute() {...}
}

@POST(&quot;login&quot;)
class DoLogin extends Action {
  def execute() {
    ...
    // After login success
    redirectTo[AdminIndex]()
  }
}

GET(&quot;admin&quot;)
class AdminIndex extends Action {
  def execute() {
    ...
    // Check if the user has not logged in, redirect him to the login page
    redirectTo[LoginInput]()
  }
}
</pre></div>
</div>
<p>Допускается делать редирект на тот же самый контроллер с помощью метода <code class="docutils literal"><span class="pre">redirecToThis()</span></code>.</p>
</div>
<div class="section" id="id10">
<h3>Форвардинг (перенаправление) на контроллер<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h3>
<p>Используйте <code class="docutils literal"><span class="pre">forwardTo[AnotherAction]()</span></code>. <code class="docutils literal"><span class="pre">redirectTo</span></code> заставляет браузер делать новый запрос, в то
время как <code class="docutils literal"><span class="pre">forwardTo</span></code> работает в рамках одного запроса.</p>
</div>
<div class="section" id="ajax">
<h3>Определение Ajax запроса<a class="headerlink" href="#ajax" title="Ссылка на этот заголовок">¶</a></h3>
<p>Используйте <code class="docutils literal"><span class="pre">isAjax</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>// В контроллере
val msg = &quot;A message&quot;
if (isAjax)
  jsRender(&quot;alert(&quot; + jsEscape(msg) + &quot;)&quot;)
else
  respondText(msg)
</pre></div>
</div>
</div>
<div class="section" id="anti-csrf">
<h3>Anti-CSRF<a class="headerlink" href="#anti-csrf" title="Ссылка на этот заголовок">¶</a></h3>
<p>Для запросов отличных от GET Xitrum автоматически защищает приложение от
<a class="reference external" href="http://en.wikipedia.org/wiki/CSRF">Cross-site request forgery</a>  атаки.</p>
<p>Включите в шаблон <code class="docutils literal"><span class="pre">antiCsrfMeta</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
<p>Тогда секция <code class="docutils literal"><span class="pre">&lt;head&gt;</span></code> будет включать в себя csrf-token:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    ...
    &lt;meta name=&quot;csrf-token&quot; content=&quot;5402330e-9916-40d8-a3f4-16b271d583be&quot; /&gt;
    ...
  &lt;/head&gt;
  ...
&lt;/html&gt;
</pre></div>
</div>
<p>Этот токен будет автоматически включен во все Ajax запросы jQuery как заголовок
<code class="docutils literal"><span class="pre">X-CSRF-Token</span></code> если вы подключите <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a>. xitrum.js  подключается вызовом <code class="docutils literal"><span class="pre">jsDefaults</span></code>. Если вы не хотите
использовать <code class="docutils literal"><span class="pre">jsDefaults</span></code>, вы можете подключить xitrum.js следующим образом (или посылать токен самостоятельно):</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script type=&quot;text/javascript&quot; src={url[xitrum.js]}&gt;&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="anticsrfinput-anticsrftoken">
<h3>antiCsrfInput и antiCsrfToken<a class="headerlink" href="#anticsrfinput-anticsrftoken" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum использует CSRF токен из заголовка запроса с именем <code class="docutils literal"><span class="pre">X-CSRF-Token</span></code>. Если заголовок
не установлен, Xitrum берет значение из параметра <code class="docutils literal"><span class="pre">csrf-token</span></code> переданного в теле запроса
(не из URL).</p>
<p>Если вы вручную создаете формы, и не используйте мета тэг и xitrum.js как сказано выше,
то вам нужно использовать методы контроллера <code class="docutils literal"><span class="pre">antiCsrfInput</span></code> или <code class="docutils literal"><span class="pre">antiCsrfToken</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[AdminAddGroup]})
  != antiCsrfInput
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[AdminAddGroup]})
  input(type=&quot;hidden&quot; name=&quot;csrf-token&quot; value={antiCsrfToken})
</pre></div>
</div>
</div>
<div class="section" id="skipcsrfcheck">
<h3>SkipCsrfCheck<a class="headerlink" href="#skipcsrfcheck" title="Ссылка на этот заголовок">¶</a></h3>
<p>Для некоторые API не требуется защита от CSRF атак, в этом случае проще всего
пропустить эту проверку. Для этого дополнительно наследуйте свой контроллер
от трейта xitrum.SkipCsrfCheck:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SkipCsrfCheck}
import xitrum.annotation.POST

trait Api extends Action with SkipCsrfCheck

@POST(&quot;api/positions&quot;)
class LogPositionAPI extends Api {
  def execute() {...}
}

@POST(&quot;api/todos&quot;)
class CreateTodoAPI extends Api {
  def execute() {...}
}
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>Управление маршрутами<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum автоматически собирает маршруты при запуске.
Для управления этими маршрутами используйте
<a class="reference external" href="http://xitrum-framework.github.io/api/3.17/index.html#xitrum.routing.RouteCollection">xitrum.Config.routes</a>.</p>
<p>Например:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Config, Server}

object Boot {
  def main(args: Array[String]) {
    // Вы можете поправить маршруты до запуска сервера
    val routes = Config.routes

    // Удаление маршрутов относящихся к конкретному классу
    routes.removeByClass[MyClass]()

    if (demoVersion) {
      // Удаление маршрутов начинающихся с префикса
      routes.removeByPrefix(&quot;premium/features&quot;)

      // Допустимый вариант
      routes.removeByPrefix(&quot;/premium/features&quot;)
    }

    ...

    Server.start()
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>Получение полных (сырых) данных запроса<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h3>
<p>Обычно когда mime тип запроса не соответствует <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code>,
предполагается что содержимое запроса будет обработано в ручном режиме.</p>
<p>Получение тела запроса в виде строки:</p>
<div class="highlight-python"><div class="highlight"><pre>val body = requestContentString
</pre></div>
</div>
<p>JSON:</p>
<div class="highlight-python"><div class="highlight"><pre>val myJValue = requestContentJValue  // =&gt; JSON4S (http://json4s.org) JValue
val myMap = xitrum.util.SeriDeseri.fromJValue[Map[String, Int]](myJValue)
</pre></div>
</div>
<p>Если вам нужно получить полный доступ к запросу, используйте <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/FullHttpRequest.html">request.getContent</a>. Он возвращает <a class="reference external" href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html">ByteBuf</a>.</p>
</div>
<div class="section" id="api">
<h3>Документирование API<a class="headerlink" href="#api" title="Ссылка на этот заголовок">¶</a></h3>
<p>Из коробки вы можете документировать API и использованием <a class="reference external" href="https://developers.helloreverb.com/swagger/">Swagger</a>.
Добавьте аннотацию <code class="docutils literal"><span class="pre">&#64;Swagger</span></code> к контроллеру который нужно задокументировать
Xitrum генерирует <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/API-Declaration">/xitrum/swagger.json</a>.
Этот файл может быть использован в <a class="reference external" href="https://github.com/wordnik/swagger-ui">Swagger UI</a>
для генерации интерактивной документации.</p>
<p>Xitrum включает Swagger UI, по пути <code class="docutils literal"><span class="pre">/xitrum/swagger-ui</span></code>,
например <a class="reference external" href="http://localhost:8000/xitrum/swagger-ui">http://localhost:8000/xitrum/swagger-ui</a>.</p>
<img alt="_images/swagger.png" src="_images/swagger.png" />
<p>Рассмотрим <a class="reference external" href="https://github.com/xitrum-framework/xitrum-placeholder">пример</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SkipCsrfCheck}
import xitrum.annotation.{GET, Swagger}

@Swagger(
  Swagger.Tags(&quot;image&quot;, &quot;APIs to create images&quot;),
  Swagger.Description(&quot;Dimensions should not be bigger than 2000 x 2000&quot;),
  Swagger.OptStringQuery(&quot;text&quot;, &quot;Text to render on the image, default: Placeholder&quot;),
  Swagger.Produces(&quot;image/png&quot;),
  Swagger.Response(200, &quot;PNG image&quot;),
  Swagger.Response(400, &quot;Width or height is invalid or too big&quot;)
)
trait ImageApi extends Action with SkipCsrfCheck {
  lazy val text = paramo(&quot;text&quot;).getOrElse(&quot;Placeholder&quot;)
}

@GET(&quot;image/:width/:height&quot;)
@Swagger(  // &lt;-- Inherits other info from ImageApi
  Swagger.Summary(&quot;Generate rectangle image&quot;),
  Swagger.IntPath(&quot;width&quot;),
  Swagger.IntPath(&quot;height&quot;)
)
class RectImageApi extends Api {
  def execute {
    val width  = param[Int](&quot;width&quot;)
    val height = param[Int](&quot;height&quot;)
    // ...
  }
}

@GET(&quot;image/:width&quot;)
@Swagger(  // &lt;-- Inherits other info from ImageApi
  Swagger.Summary(&quot;Generate square image&quot;),
  Swagger.IntPath(&quot;width&quot;)
)
class SquareImageApi extends Api {
  def execute {
    val width  = param[Int](&quot;width&quot;)
    // ...
  }
}
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/wordnik/swagger-spec/blob/master/versions/1.2.md">JSON для Swagger</a>
будет генерироваться при доступе <code class="docutils literal"><span class="pre">/xitrum/swagger</span></code>.</p>
<p>Swagger UI использует эту информацию для генерации интерактивной документации к API.</p>
<p>Возможные параметры на подобии Swagger.IntPath определяются шаблоном:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;Тип</span> <span class="pre">переменной&gt;&lt;Тип</span> <span class="pre">параметра&gt;</span></code> (обязательный параметр)</li>
<li><code class="docutils literal"><span class="pre">Opt&lt;Тип</span> <span class="pre">переменной&gt;&lt;Тип</span> <span class="pre">параметра&gt;</span></code> (опциональный параметр)</li>
</ul>
<p>Типы переменных: Byte, Int, Int32, Int64, Long, Number, Float, Double, String, Boolean, Date, DateTime</p>
<p>Типы параметров: Path, Query, Body, Header, Form</p>
<p>Подробнее о <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/Datatypes">типах переменных</a>
и <a class="reference external" href="https://github.com/wordnik/swagger-core/wiki/Parameters">типах параметров</a>.</p>
</div>
</div>
<span id="document-template_engines"></span><div class="section" id="id1">
<h2>Шаблонизация<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Выбранный шаблонизатор используется во время вызова методов <a class="reference internal" href="index.html#document-action_view"><em>renderView, renderFragment,
или respondView</em></a>.</p>
<div class="section" id="id2">
<h3>Настройка<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>В конфигурационном файле <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>, шаблонизатор может быть указан двумя способами:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">template</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">template</span><span class="o">.</span><span class="n">EngineClassName</span>
</pre></div>
</div>
<p>Или:</p>
<div class="highlight-python"><div class="highlight"><pre>template {
  &quot;my.template.EngineClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>По умолчанию используется <a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a> в качестве шаблонизатора.</p>
</div>
<div class="section" id="id3">
<h3>Отключение шаблонизатора<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p>В случае если ваш проект предоставляет просто API, обычно шаблонизатор не требуется. В этом случае
допускается убрать шаблонизатор из проекта что бы сделать его легче. Просто удалите
<code class="docutils literal"><span class="pre">templateEngine</span></code> в config/xitrum.conf.</p>
</div>
<div class="section" id="id4">
<h3>Реализация своего шаблонизатора<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<p>Для реализации своего шаблонизатора, создайте класс реализующий <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/view/TemplateEngine.scala">xitrum.view.TemplateEngine</a>.
После этого укажите имя этого класса в конфигурации config/xitrum.conf.</p>
<p>Пример реализации <a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a>.</p>
</div>
</div>
<span id="document-postback"></span><div class="section" id="postbacks">
<h2>Postbacks<a class="headerlink" href="#postbacks" title="Ссылка на этот заголовок">¶</a></h2>
<p>Клиентами веб приложения могут быть:</p>
<ul class="simple">
<li>другие приложения или устройства: например, RESTful APIs которое широко используется смартфонами, другими веб сайтами</li>
<li>люди: например, интерактивные веб сайты предполагающие сложные взаимодействия</li>
</ul>
<p>Как фреймворк, Xitrum нацелен на создание легких решений для этих задача.
Для решения первой задачи, используются <a class="reference internal" href="index.html#document-restful"><em>RESTful контроллеры</em></a>.
Для решения второй задачи, в том числе существует возможность использовать postback.
Подробнее о технологии postback:</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Postback">http://en.wikipedia.org/wiki/Postback</a></li>
<li><a class="reference external" href="http://nitrogenproject.com/doc/tutorial.html">http://nitrogenproject.com/doc/tutorial.html</a></li>
</ul>
<p>Реализация в Xitrum&#8217;s сделана в стиле <a class="reference external" href="http://nitrogenproject.com/">Nitrogen</a>.</p>
<div class="section" id="id1">
<h3>Шаблон<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h3>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;Welcome to Xitrum&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Форма<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Articles.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.{GET, POST, First}
import xitrum.validator._

@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val id      = param(&quot;id&quot;)
    val article = Article.find(id)
    respondInlineView(
      &lt;h1&gt;{article.title}&lt;/h1&gt;
      &lt;div&gt;{article.body}&lt;/div&gt;
    )
  }
}

@First  // Этот маршрут будет обработан перед &quot;show&quot;
@GET(&quot;articles/new&quot;)
class ArticlesNew extends AppAction {
  def execute() {
    respondInlineView(
      &lt;form data-postback=&quot;submit&quot; action={url[ArticlesCreate]}&gt;
        &lt;label&gt;Title&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;title&quot; class=&quot;required&quot; /&gt;&lt;br /&gt;

        &lt;label&gt;Body&lt;/label&gt;
        &lt;textarea name=&quot;body&quot; class=&quot;required&quot;&gt;&lt;/textarea&gt;&lt;br /&gt;

        &lt;input type=&quot;submit&quot; value=&quot;Save&quot; /&gt;
      &lt;/form&gt;
    )
  }
}

@POST(&quot;articles&quot;)
class ArticlesCreate extends AppAction {
  def execute() {
    val title   = param(&quot;title&quot;)
    val body    = param(&quot;body&quot;)
    val article = Article.save(title, body)

    flash(&quot;Article has been saved.&quot;)
    jsRedirectTo(show, &quot;id&quot; -&gt; article.id)
  }
}
</pre></div>
</div>
<p>При возникновении события <code class="docutils literal"><span class="pre">submit</span></code> формы, состояние формы будет отправлено на сервер в контроллер <code class="docutils literal"><span class="pre">ArticlesCreate</span></code>.</p>
<p>Атрибут <code class="docutils literal"><span class="pre">action</span></code> формы зашифрован. Зашифрованный URL выступает в роли anti-CSRF токена.</p>
</div>
<div class="section" id="id3">
<h3>Другие элементы (не формы)<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p>Postback может быть отправлен для любого элемента, не только для формы.</p>
<p>Вот пример для ссылки:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot; data-postback=&quot;click&quot; action={postbackUrl[LogoutAction]}&gt;Logout&lt;/a&gt;
</pre></div>
</div>
<p>Переход по ссылке выполнит отправку состояния в LogoutAction.</p>
</div>
<div class="section" id="id4">
<h3>Диалог подтверждения<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<p>Отображение диалоговых окон подтверждения:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot; data-postback=&quot;click&quot;
            action={postbackUrl[LogoutAction]}
            data-confirm=&quot;Do you want to logout?&quot;&gt;Logout&lt;/a&gt;
</pre></div>
</div>
<p>В случае отказа от продолжения (при нажатии кнопки &#8220;Cancel&#8221;) postback не будет отправлен.</p>
</div>
<div class="section" id="id5">
<h3>Дополнительные параметры<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>В случае формы вы можете добавлять дополнительные поля <code class="docutils literal"><span class="pre">&lt;input</span> <span class="pre">type=&quot;hidden&quot;...</span></code> для отправки
дополнительных параметров как часть postback.</p>
<p>Для других элементов, вы можете поступать так:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;a href=&quot;#&quot;
   data-postback=&quot;click&quot;
   action={postbackUrl[ArticlesDestroy](&quot;id&quot; -&gt; item.id)}
   data-params=&quot;_method=delete&quot;
   data-confirm={&quot;Do you want to delete %s?&quot;.format(item.name)}&gt;Delete&lt;/a&gt;
</pre></div>
</div>
<p>Или вы можете поместить дополнительные параметры в смежную форму:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;form id=&quot;myform&quot; data-postback=&quot;submit&quot; action={postbackUrl[SiteSearch]}&gt;
  Search:
  &lt;input type=&quot;text&quot; name=&quot;keyword&quot; /&gt;

  &lt;a class=&quot;pagination&quot;
     href=&quot;#&quot;
     data-postback=&quot;click&quot;
     data-form=&quot;#myform&quot;
     action={postbackUrl[SiteSearch](&quot;page&quot; -&gt; page)}&gt;{page}&lt;/a&gt;
&lt;/form&gt;
</pre></div>
</div>
<p>Используйте селектор <code class="docutils literal"><span class="pre">#myform</span></code> для получения формы с дополнительными параметрами.</p>
</div>
<div class="section" id="ajax">
<h3>Отображение анимации во время Ajax загрузки<a class="headerlink" href="#ajax" title="Ссылка на этот заголовок">¶</a></h3>
<p>By default, this animated GIF image is displayed while Ajax is loading:</p>
<img alt="_images/ajax_loading.gif" src="_images/ajax_loading.gif" />
<p>To customize, please call this JS snippet after including <code class="docutils literal"><span class="pre">jsDefaults</span></code> (which includes
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a>)
in your view template:</p>
<div class="highlight-python"><div class="highlight"><pre>// target: The element that triggered the postback
xitrum.ajaxLoading = function(target) {
  // Called when the animation should be displayed when the Ajax postback is being sent.
  var show = function() {
    ...
  };

  // Called when the animation should be stopped after the Ajax postback completes.
  var hide = function() {
    ...
  };

  return {show: show, hide: hide};
};
</pre></div>
</div>
</div>
</div>
<span id="document-xml"></span><div class="section" id="xml">
<h2>XML<a class="headerlink" href="#xml" title="Ссылка на этот заголовок">¶</a></h2>
<p>Scala позволяет использовать XML литералы. Xitrum позволяет использовать такую возможность как своеобразный &#8220;шаблонизатор&#8221;:</p>
<ul class="simple">
<li>Scala проверяет синтаксис XML во время компиляции: представления безопасны относительно типа.</li>
<li>Scala автоматически экранирует XML: представления по умолчанию защищены от <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> атак.</li>
</ul>
<p>Ниже приведены некоторые советы.</p>
<div class="section" id="id1">
<h3>Отключения экранирования XML<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h3>
<p>Используйте <code class="docutils literal"><span class="pre">scala.xml.Unparsed</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.xml.Unparsed

&lt;script&gt;
  {Unparsed(&quot;if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);&quot;)}
&lt;/script&gt;
</pre></div>
</div>
<p>Или <code class="docutils literal"><span class="pre">&lt;xml:unparsed&gt;</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  &lt;xml:unparsed&gt;
    if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);
  &lt;/xml:unparsed&gt;
&lt;/script&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:unparsed&gt;</span></code> не отображается в выводе:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  if (1 &lt; 2) alert(&#39;Xitrum rocks&#39;);
&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Группировка XML элементов<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>&lt;div id=&quot;header&quot;&gt;
  {if (loggedIn)
    &lt;xml:group&gt;
      &lt;b&gt;{username}&lt;/b&gt;
      &lt;a href={url[LogoutAction]}&gt;Logout&lt;/a&gt;
    &lt;/xml:group&gt;
  else
    &lt;xml:group&gt;
      &lt;a href={url[LoginAction]}&gt;Login&lt;/a&gt;
      &lt;a href={url[RegisterAction]}&gt;Register&lt;/a&gt;
    &lt;/xml:group&gt;}
&lt;/div&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;xml:group&gt;</span></code> не будет отображаться в выводе, например в случае пользователя прошедшего аутентификацию:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;div id=&quot;header&quot;&gt;
  &lt;b&gt;My username&lt;/b&gt;
  &lt;a href=&quot;/login&quot;&gt;Logout&lt;/a&gt;
&lt;/div&gt;
</pre></div>
</div>
</div>
<div class="section" id="xhtml">
<h3>Отображение XHTML<a class="headerlink" href="#xhtml" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum отображает представления как XHTML автоматически. Допускается делать
это самостоятельно:</p>
<div class="highlight-python"><div class="highlight"><pre>import scala.xml.Xhtml

val br = &lt;br /&gt;
br.toString            // =&gt; &lt;br&gt;&lt;/br&gt;, some browsers will render this as 2 &lt;br /&gt;s
Xhtml.toXhtml(&lt;br /&gt;)  // =&gt; &quot;&lt;br /&gt;&quot;
</pre></div>
</div>
</div>
</div>
<span id="document-js"></span><div class="section" id="javascript-json">
<h2>JavaScript и JSON<a class="headerlink" href="#javascript-json" title="Ссылка на этот заголовок">¶</a></h2>
<div class="section" id="javascript">
<h3>JavaScript<a class="headerlink" href="#javascript" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum включает jQuery (опционально) с дополнительным набором утильных функций jsXXX.</p>
<div class="section" id="id1">
<h4>Вставка JavaScript фрагментов в представление<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h4>
<p>В контроллере вы можете использовать метод <code class="docutils literal"><span class="pre">jsAddToView</span></code> (множество раз, если необходимо):</p>
<div class="highlight-python"><div class="highlight"><pre>class MyAction extends AppAction {
  def execute() {
    ...
    jsAddToView(&quot;alert(&#39;Hello&#39;)&quot;)
    ...
    jsAddToView(&quot;alert(&#39;Hello again&#39;)&quot;)
    ...
    respondInlineView(&lt;p&gt;My view&lt;/p&gt;)
  }
}
</pre></div>
</div>
<p>В шаблоне метод <code class="docutils literal"><span class="pre">jsForView</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;flash&quot;&gt;{jsFlash}&lt;/div&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>Отправка JavaScript непосредственно (без представления)<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для отправки JavaScript:</p>
<div class="highlight-python"><div class="highlight"><pre>jsRespond(&quot;$(&#39;#error&#39;).html(%s)&quot;.format(jsEscape(&lt;p class=&quot;error&quot;&gt;Could not login.&lt;/p&gt;)))
</pre></div>
</div>
<p>Для редиректа:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">jsRedirectTo</span><span class="p">(</span><span class="s">&quot;http://cntt.tv/&quot;</span><span class="p">)</span>
<span class="n">jsRedirectTo</span><span class="p">[</span><span class="n">LoginAction</span><span class="p">]()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="json">
<h3>JSON<a class="headerlink" href="#json" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum включает <a class="reference external" href="https://github.com/json4s/json4s">JSON4S</a>.
Пожалуйста прочтите документацию проекта о том как считывать и генерировать JSON.</p>
<p>Конвертация case объекта в строку JSON:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri

case class Person(name: String, age: Int, phone: Option[String])
val person1 = Person(&quot;Jack&quot;, 20, None)
val json    = SeriDeseri.toJson(person1)
val person2 = SeriDeseri.fromJson[Person](json)
</pre></div>
</div>
<p>Отправка JSON клиенту:</p>
<div class="highlight-python"><div class="highlight"><pre>val scalaData = List(1, 2, 3)  // Например
respondJson(scalaData)
</pre></div>
</div>
<p>JSON так же полезен для написания конфигурационных файлов со вложенными структурами.
Смотри <a class="reference internal" href="index.html#document-howto"><em>Загрузка конфигурационных файлов</em></a>.</p>
</div>
<div class="section" id="knockout-js">
<h3>Плагин для Knockout.js<a class="headerlink" href="#knockout-js" title="Ссылка на этот заголовок">¶</a></h3>
<p>Смотри <a class="reference external" href="https://github.com/xitrum-framework/xitrum-ko">https://github.com/xitrum-framework/xitrum-ko</a></p>
</div>
</div>
<span id="document-async"></span><div class="section" id="id1">
<h2>Асинхронная обработка запросов<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Основные методы для отправки ответа сервером:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondView</span></code>: при ответе использует шаблон ассоциированный с контроллером</li>
<li><code class="docutils literal"><span class="pre">respondInlineView</span></code>: при ответе использует шаблон переданный как аргумент</li>
<li><code class="docutils literal"><span class="pre">respondText(&quot;hello&quot;)</span></code>: ответ строкой &#8220;plain/text&#8221;</li>
<li><code class="docutils literal"><span class="pre">respondHtml(&quot;&lt;html&gt;...&lt;/html&gt;&quot;)</span></code>: ответ строкой &#8220;text/html&#8221;</li>
<li><code class="docutils literal"><span class="pre">respondJson(List(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>: преобразовать Scala объект в JSON и ответить</li>
<li><code class="docutils literal"><span class="pre">respondJs(&quot;myFunction([1,</span> <span class="pre">2,</span> <span class="pre">3])&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondJsonP(List(1,</span> <span class="pre">2,</span> <span class="pre">3),</span> <span class="pre">&quot;myFunction&quot;)</span></code>: совмещение предыдущих двух</li>
<li><code class="docutils literal"><span class="pre">respondJsonText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondJsonPText(&quot;[1,</span> <span class="pre">2,</span> <span class="pre">3]&quot;,</span> <span class="pre">&quot;myFunction&quot;)</span></code></li>
<li><code class="docutils literal"><span class="pre">respondBinary</span></code>: ответ массивом байт</li>
<li><code class="docutils literal"><span class="pre">respondFile</span></code>: переслать файл с использованием техники <a class="reference external" href="http://www.ibm.com/developerworks/library/j-zerocopy/">zero-copy</a>  (aka send-file)</li>
<li><code class="docutils literal"><span class="pre">respondEventSource(&quot;data&quot;,</span> <span class="pre">&quot;event&quot;)</span></code></li>
</ul>
<p>Xitrum автоматически не осуществляет отправку ответа клиенту. Вы должны явно вызвать один из методов <code class="docutils literal"><span class="pre">respondXXX</span></code>
что бы отправить ответ клиенту. Если вы не вызовете метод``respondXXX``, Xitrum будет поддерживать HTTP соединение,
до тех пор пока не будет вызван метод <code class="docutils literal"><span class="pre">respondXXX</span></code>.</p>
<p>Что бы убедиться что соединение открыто используйте метод <code class="docutils literal"><span class="pre">channel.isOpen</span></code>.
Вы можете использовать добавить слушателя используя метод <code class="docutils literal"><span class="pre">addConnectionClosedListener</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>addConnectionClosedListener {
  // Соединение было закрыто
  // Необходимо освободить ресурсы
}
</pre></div>
</div>
<p>Ввиду асинхронной природы, ответ сервера не посылается немедленно.
<code class="docutils literal"><span class="pre">respondXXX</span></code> возвращает экземпляр <a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html">ChannelFuture</a>.
Его можно использовать для выполнения действий в момент кода ответ будет действительно отправлен.</p>
<p>Например, если вы хотите закрыть подключение сразу после отправки запроса:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.channel.{ChannelFuture, ChannelFutureListener}

val future = respondText(&quot;Hello&quot;)
future.addListener(new ChannelFutureListener {
  def operationComplete(future: ChannelFuture) {
    future.getChannel.close()
  }
})
</pre></div>
</div>
<p>Или проще:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondText</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">addListener</span><span class="p">(</span><span class="n">ChannelFutureListener</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="websocket">
<h3>WebSocket<a class="headerlink" href="#websocket" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import scala.runtime.ScalaRunTime
import xitrum.annotation.WEBSOCKET
import xitrum.{WebSocketAction, WebSocketBinary, WebSocketText, WebSocketPing, WebSocketPong}

@WEBSOCKET(&quot;echo&quot;)
class EchoWebSocketActor extends WebSocketAction {
  def execute() {
    // Here you can extract session data, request headers etc.
    // but do not use respondText, respondView etc.
    // To respond, use respondWebSocketXXX like below.

    log.debug(&quot;onOpen&quot;)

    context.become {
      case WebSocketText(text) =&gt;
        log.info(&quot;onTextMessage: &quot; + text)
        respondWebSocketText(text.toUpperCase)

      case WebSocketBinary(bytes) =&gt;
        log.info(&quot;onBinaryMessage: &quot; + ScalaRunTime.stringOf(bytes))
        respondWebSocketBinary(bytes)

      case WebSocketPing =&gt;
        log.debug(&quot;onPing&quot;)

      case WebSocketPong =&gt;
        log.debug(&quot;onPong&quot;)
    }
  }

  override def postStop() {
    log.debug(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>Актор будет создан при открытии подключения. И остановлен когда:</p>
<ul class="simple">
<li>Соединение будет разорвано</li>
<li>WebSocket закроет подключение</li>
</ul>
<p>Используйте следующие методы для отправки WebSocket сообщений (frame):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondWebSocketText</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketBinary</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketPing</span></code></li>
<li><code class="docutils literal"><span class="pre">respondWebSocketClose</span></code></li>
</ul>
<p>Метод respondWebSocketPong не предусмотрен, потому что Xitrum автоматически отправляет &#8220;pong&#8221; сообщение в ответ на &#8220;ping&#8221;.</p>
<p>Для получения ссылки на контроллер:</p>
<div class="highlight-python"><div class="highlight"><pre>val url = absWebSocketUrl[EchoWebSocketActor]
</pre></div>
</div>
</div>
<div class="section" id="sockjs">
<h3>SockJS<a class="headerlink" href="#sockjs" title="Ссылка на этот заголовок">¶</a></h3>
<p><a class="reference external" href="https://github.com/sockjs/sockjs-client">SockJS</a> предоставляет JavaScript объект
эмитирующий поддержку WebSocket, для браузеров которые не поддерживают этот стандарт.
SockJS пытается использовать WebSocket если он доступен в браузере. В другом случае
будет создан эмитирующий объект.</p>
<p>Если вы хотите использовать WebSocket API во всех браузерах, то следует использовать
SockJS вместо WebSocket.</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script&gt;
  var sock = new SockJS(&#39;http://mydomain.com/path_prefix&#39;);
  sock.onopen = function() {
    console.log(&#39;open&#39;);
  };
  sock.onmessage = function(e) {
    console.log(&#39;message&#39;, e.data);
  };
  sock.onclose = function() {
    console.log(&#39;close&#39;);
  };
&lt;/script&gt;
</pre></div>
</div>
<p>Xitrum включает файл SockJS по умолчанию.
В шаблоне следует написать:</p>
<div class="highlight-python"><div class="highlight"><pre>...
html
  head
    != jsDefaults
...
</pre></div>
</div>
<p>SockJS подразумевает наличие части реализации <a class="reference external" href="https://github.com/sockjs/sockjs-protocol">на сервере</a>.
Xitrum автоматически ее реализует:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, SockJsAction, SockJsText}
import xitrum.annotation.SOCKJS

@SOCKJS(&quot;echo&quot;)
class EchoSockJsActor extends SockJsAction {
  def execute() {
    // To respond, use respondSockJsXXX like below

    log.info(&quot;onOpen&quot;)

    context.become {
      case SockJsText(text) =&gt;
        log.info(&quot;onMessage: &quot; + text)
        respondSockJsText(text)
    }
  }

  override def postStop() {
    log.info(&quot;onClose&quot;)
    super.postStop()
  }
}
</pre></div>
</div>
<p>Актор будет создан при открытии новой SockJS сессии. И остановлен когда сессия будет закрыта.</p>
<p>Для отправки SockJS сообщений используйте методы:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">respondSockJsText</span></code></li>
<li><code class="docutils literal"><span class="pre">respondSockJsClose</span></code></li>
</ul>
<p><a class="reference external" href="https://github.com/sockjs/sockjs-node#various-issues-and-design-considerations">Рекомендации по реализации</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>Обычно использование кук не подходит для SockJS. Если вам нужна авторизация внутри сессии, то
для каждой страницы присвойте токен и используйте его в SockJS сессии, для валидации на серверной стороне.
В сущности это повторение механизма куки для SockJS.
</pre></div>
</div>
<p>Подробнее о настройке кластера SockJS, смотрите раздел <a class="reference internal" href="index.html#document-cluster"><em>Кластерезация с Akka</em></a>.</p>
</div>
<div class="section" id="chunked">
<h3>Chunked ответ<a class="headerlink" href="#chunked" title="Ссылка на этот заголовок">¶</a></h3>
<p>Для отправки <a class="reference external" href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked ответа</a>:</p>
<ol class="arabic simple">
<li>Вызовите метод <code class="docutils literal"><span class="pre">setChunked</span></code></li>
<li>Отправляйте данные методами <code class="docutils literal"><span class="pre">respondXXX</span></code>, столько раз сколько нужно</li>
<li>Последний ответ отправьте методом <code class="docutils literal"><span class="pre">respondLastChunk</span></code></li>
</ol>
<p>Chunked ответы имеют множество применений. Например, когда нужно генерировать большой
документ который не помещается в памяти, вы можете генерировать этот документ частями
и отправлять их последовательно:</p>
<div class="highlight-python"><div class="highlight"><pre>// &quot;Cache-Control&quot; загаловок будет установлен в:
// &quot;no-store, no-cache, must-revalidate, max-age=0&quot;
//
// Важно &quot;Pragma: no-cache&quot; привязывается к запросу, а не к ответу:
// http://palizine.plynt.com/issues/2008Jul/cache-control-attributes/
setChunked()

val generator = new MyCsvGenerator

generator.onFirstLine { line =&gt;
  val future = respondText(header, &quot;text/csv&quot;)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) generator.next()
    }
  }
}

generator.onNextLine { line =&gt;
  val future = respondText(line)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) generator.next()
    }
  })
}

generator.onLastLine { line =&gt;
  val future = respondText(line)
  future.addListener(new ChannelFutureListener {
    def operationComplete(future: ChannelFuture) {
      if (future.isSuccess) respondLastChunk()
    }
  })
}

generator.generate()
</pre></div>
</div>
<p>Замечания:</p>
<ul class="simple">
<li>Заголовки отправляются при первом вызове <code class="docutils literal"><span class="pre">respondXXX</span></code>.</li>
<li>Опционально, вы можете отправить дополнительные заголовки с вызовом метода <code class="docutils literal"><span class="pre">respondLastChunk</span></code></li>
<li><a class="reference internal" href="index.html#document-cache"><em>Кэш страницы и контроллера</em></a> не может быть использован совместно с chunked ответами.</li>
</ul>
<p>Используя chunked ответ вместе с <code class="docutils literal"><span class="pre">ActorAction</span></code>, легко реализовать
<a class="reference external" href="http://www.cubrid.org/blog/dev-platform/faster-web-page-loading-with-facebook-bigpipe/">Facebook BigPipe</a>.</p>
<div class="section" id="iframe">
<h4>Бесконечный iframe<a class="headerlink" href="#iframe" title="Ссылка на этот заголовок">¶</a></h4>
<p>Chunked ответ <a class="reference external" href="http://www.shanison.com/2010/05/10/stop-the-browser-%E2%80%9Cthrobber-of-doom%E2%80%9D-while-loading-comet-forever-iframe/">может быть использован</a>
для реализации <a class="reference external" href="http://en.wikipedia.org/wiki/Comet_%28programming%29">Comet</a>.</p>
<p>Страница которая включает iframe:</p>
<div class="highlight-python"><div class="highlight"><pre>...
&lt;script&gt;
  var functionForForeverIframeSnippetsToCall = function() {...}
&lt;/script&gt;
...
&lt;iframe width=&quot;1&quot; height=&quot;1&quot; src=&quot;path/to/forever/iframe&quot;&gt;&lt;/iframe&gt;
...
</pre></div>
</div>
<p>Контроллер который последовательно отправляет <code class="docutils literal"><span class="pre">&lt;script&gt;</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>// Подготовка к вечному iframe

setChunked()

// Необходимо отправить например &quot;123&quot; для некоторых браузеров
respondText(&quot;&lt;html&gt;&lt;body&gt;123&quot;, &quot;text/html&quot;)

// Большинство клиентов (даже curl!) не выполняют тело &lt;script&gt; немедленно,
// необходимо отправить около 2KB данных что бы обойти эту проблему
for (i &lt;- 1 to 100) respondText(&quot;&lt;script&gt;&lt;/script&gt;\n&quot;)
</pre></div>
</div>
<p>Позднее, когда вам нужно отправить данные браузеру, просто используйте шаблон:</p>
<div class="highlight-python"><div class="highlight"><pre>if (channel.isOpen)
  respondText(&quot;&lt;script&gt;parent.functionForForeverIframeSnippetsToCall()&lt;/script&gt;\n&quot;)
else
  // Соединение было закрыто, необходимо освободить ресурсы
  // Вы можете использовать так же ``addConnectionClosedListener``.
</pre></div>
</div>
</div>
<div class="section" id="event-source">
<h4>Event Source<a class="headerlink" href="#event-source" title="Ссылка на этот заголовок">¶</a></h4>
<p>Смотри <a class="reference external" href="http://dev.w3.org/html5/eventsource/">http://dev.w3.org/html5/eventsource/</a></p>
<p>Event Source ответ, это специальный тип chunked ответа.
Данные должны быть в кодировке UTF-8.</p>
<p>Для ответа в формате event source, используйте метод <code class="docutils literal"><span class="pre">respondEventSource</span></code> столько раз сколько нужно.</p>
<div class="highlight-python"><div class="highlight"><pre>respondEventSource(&quot;data1&quot;, &quot;event1&quot;)  // Имя события &quot;event1&quot;
respondEventSource(&quot;data2&quot;)            // Имя события устанавливается в &quot;message&quot; по умолчанию
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-static"></span><div class="section" id="id1">
<h2>Статичные файлы<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<div class="section" id="id2">
<h3>Отправка статических файлов с диска<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Шаблонная директория Xitrum проекта:</p>
<div class="highlight-python"><div class="highlight"><pre>config
public
  favicon.ico
  robots.txt
  404.html
  500.html
  img
    myimage.png
  css
    mystyle.css
  js
    myscript.js
src
build.sbt
</pre></div>
</div>
<p>Xitrum использует директорию <code class="docutils literal"><span class="pre">public</span></code> для хранения статических файлов.
Для генерации ссылок на статические файлы:</p>
<div class="highlight-python"><div class="highlight"><pre>/img/myimage.png
/css/mystyle.css
/css/mystyle.min.css
</pre></div>
</div>
<p>Используйте шаблон:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={publicUrl(&quot;img/myimage.png&quot;)} /&gt;
</pre></div>
</div>
<p>Для работы с обычными файлами в режиме разработчика и их минимизированными версиями
(например, mystyle.css и mystyle.min.css), используйте шаблон:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={publicUrl(&quot;css&quot;, &quot;mystyle.css&quot;, &quot;mystyle.min.css&quot;)} /&gt;
</pre></div>
</div>
<p>Для отправки файла с диска из контроллера используйте метод <code class="docutils literal"><span class="pre">respondFile</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondFile</span><span class="p">(</span><span class="s">&quot;/absolute/path&quot;</span><span class="p">)</span>
<span class="n">respondFile</span><span class="p">(</span><span class="s">&quot;path/relative/to/the/current/working/directory&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Для оптимизации работы со статическими файлами, вы можете избежать использование
не нужны файлов ограничив их маской (фильтром на основе регулярного выражения).
Если запрос не будет соответствовать регулярному выражению, Xitrum ответит страницей
404 на этот зарос.</p>
<p>Смотри <code class="docutils literal"><span class="pre">pathRegex</span></code> в <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
</div>
<div class="section" id="index-html">
<h3>index.html и обработка отсутствующих маршрутов<a class="headerlink" href="#index-html" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если не существует контроллера для данного URL, например <code class="docutils literal"><span class="pre">/foo/bar</span></code> (или <code class="docutils literal"><span class="pre">/foo/bar/</span></code>),
Xitrum попытается найти подходящий статический файл <code class="docutils literal"><span class="pre">public/foo/bar/index.html</span></code>
(в директории &#8220;public&#8221;). Если файл существует, то он будет отправлен клиенту.</p>
</div>
<div class="section" id="id3">
<h3>404 и 500<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p>404.html и 500.html в директории <code class="docutils literal"><span class="pre">public</span></code> используются когда маршрут не обнаружен или на сервере произошла ошибка.
Пример использования своего собственного обработчика ошибок:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{Error404, Error500}

@Error404
class My404ErrorHandlerAction extends Action {
  def execute() {
    if (isAjax)
      jsRespond(&quot;alert(&quot; + jsEscape(&quot;Not Found&quot;) + &quot;)&quot;)
    else
      renderInlineView(&quot;Not Found&quot;)
  }
}

@Error500
class My500ErrorHandlerAction extends Action {
  def execute() {
    if (isAjax)
      jsRespond(&quot;alert(&quot; + jsEscape(&quot;Internal Server Error&quot;) + &quot;)&quot;)
    else
      renderInlineView(&quot;Internal Server Error&quot;)
  }
}
</pre></div>
</div>
<p>Код ответа устанавливается в 404 или 500 еще до того как код контроллера будет запущен,
соответственно вам не нужно устанавливать его самостоятельно.</p>
</div>
<div class="section" id="webjars">
<h3>Использование файлов ресурсов в соответствии с WebJars<a class="headerlink" href="#webjars" title="Ссылка на этот заголовок">¶</a></h3>
<div class="section" id="id4">
<h4>WebJars<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h4>
<p><a class="reference external" href="http://www.webjars.org/">WebJars</a> предоставляет множество библиотек которые вы можете
объявить как зависимости вашего проекта.</p>
<p>Например, для использования <a class="reference external" href="http://underscorejs.org/">Underscore.js</a>,
достаточно прописать в <code class="docutils literal"><span class="pre">build.sbt</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;org.webjars&quot;</span> <span class="o">%</span> <span class="s">&quot;underscorejs&quot;</span> <span class="o">%</span> <span class="s">&quot;1.6.0-3&quot;</span>
</pre></div>
</div>
<p>После этого, в шаблоне .jade:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">script</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="p">{</span><span class="n">webJarsUrl</span><span class="p">(</span><span class="s">&quot;underscorejs/1.6.0&quot;</span><span class="p">,</span> <span class="s">&quot;underscore.js&quot;</span><span class="p">,</span> <span class="s">&quot;underscore-min.js&quot;</span><span class="p">)})</span>
</pre></div>
</div>
<p>Xitrum будет автоматически использовать <code class="docutils literal"><span class="pre">underscore.js</span></code> в режиме разработчика, и
<code class="docutils literal"><span class="pre">underscore-min.js</span></code> в боевом режиме.</p>
<p>Результат будет таким:</p>
<div class="highlight-python"><div class="highlight"><pre>/webjars/underscorejs/1.6.0/underscore.js?XOKgP8_KIpqz9yUqZ1aVzw
</pre></div>
</div>
<p>Для использования в одного и того же файла во всех режимах:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">script</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="p">{</span><span class="n">webJarsUrl</span><span class="p">(</span><span class="s">&quot;underscorejs/1.6.0/underscore.js&quot;</span><span class="p">)})</span>
</pre></div>
</div>
</div>
<div class="section" id="jar-webjars">
<h4>Хранение файлов ресурсов внутри .jar файла согласно WebJars<a class="headerlink" href="#jar-webjars" title="Ссылка на этот заголовок">¶</a></h4>
<p>Если вы разработчик библиотек и ваша библиотека включает myimage.png, то вы можете
сохранить myimage.png внутри .jar файла. Используя <a class="reference external" href="http://www.webjars.org/">WebJars</a>, например:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">META</span><span class="o">-</span><span class="n">INF</span><span class="o">/</span><span class="n">resources</span><span class="o">/</span><span class="n">webjars</span><span class="o">/</span><span class="n">mylib</span><span class="o">/</span><span class="mf">1.0</span><span class="o">/</span><span class="n">myimage</span><span class="o">.</span><span class="n">png</span>
</pre></div>
</div>
<p>Использование в проекте:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;img src={webJarsUrl(&quot;mylib/1.0/myimage.png&quot;)} /&gt;
</pre></div>
</div>
<p>Во всех режимах URL будет:</p>
<div class="highlight-python"><div class="highlight"><pre>/webjars/mylib/1.0/myimage.png?xyz123
</pre></div>
</div>
</div>
<div class="section" id="classpath">
<h4>Ответ файлом из classpath<a class="headerlink" href="#classpath" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для ответа файлом находящимся внутри classpath (или внутри .jar файла), даже если файл
хранится не по стандарту <a class="reference external" href="http://www.webjars.org/">WebJars</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;path/relative/to/the/classpath/element&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Например:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;akka/actor/Actor.class&quot;</span><span class="p">)</span>
<span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;META-INF/resources/webjars/underscorejs/1.6.0/underscore.js&quot;</span><span class="p">)</span>
<span class="n">respondResource</span><span class="p">(</span><span class="s">&quot;META-INF/resources/webjars/underscorejs/1.6.0/underscore-min.js&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="etag-max-age">
<h3>Кэширование на стороне клиента с ETag и max-age<a class="headerlink" href="#etag-max-age" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum автоматически добавляет <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_ETag">Etag</a> для
статических файлов на диске и в classpath.</p>
<p>ETag для маленьких файлов - MD5 хэш от контента файла. Они кэшируются для последующего использования.
Ключ кэша - <code class="docutils literal"><span class="pre">(путь</span> <span class="pre">до</span> <span class="pre">файла,</span> <span class="pre">время</span> <span class="pre">изменения)</span></code>. Поскольку время изменения на разных серверах
может отличаться, каждый веб сервер в кластере имеет свой собственный ETag кэш.</p>
<p>Для больших файлов, только время изменения используется как ETag. Такая система не совершенна
поскольку идентичные файлы на разных серверах могут иметь различный ETag, но это все равно лучше
чем не использовать ETag вовсе.</p>
<p><code class="docutils literal"><span class="pre">publicUrl</span></code> и <code class="docutils literal"><span class="pre">webJarsUrl</span></code> автоматически добавляют ETag для ссылок. Например:</p>
<div class="highlight-python"><div class="highlight"><pre>webJarsUrl(&quot;jquery/2.1.1/jquery.min.js&quot;)
=&gt; /webjars/jquery/2.1.1/jquery.min.js?0CHJg71ucpG0OlzB-y6-mQ
</pre></div>
</div>
<p>Xitrum так же устанавливает заголовки <code class="docutils literal"><span class="pre">max-age</span></code> и <code class="docutils literal"><span class="pre">Expires</span></code> в значение
<a class="reference external" href="https://developers.google.com/speed/docs/best-practices/caching">1 год</a>.
Не переживайте, браузер все равно получит последнею версию файла. Потому что для
файлов хранящихся на диске, после изменении ссылка на файл меняется, т.к. генерируется с
помощью <code class="docutils literal"><span class="pre">publicUrl</span></code> и <code class="docutils literal"><span class="pre">webJarsUrl</span></code>. Их ETag кэш так же обновляется.</p>
</div>
<div class="section" id="gzip">
<h3>GZIP<a class="headerlink" href="#gzip" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum автоматически сжимает текстовые ответы. Проверяется заголовок <code class="docutils literal"><span class="pre">Content-Type</span></code>
для определения текстового ответа: <code class="docutils literal"><span class="pre">text/html</span></code>, <code class="docutils literal"><span class="pre">xml/application</span></code> и пр.</p>
<p>Xitrum всегда сжимает текстовые файлы, но для динамических ответов с целью
повышения производительности ответы размером меньше 1 килобайта не сжимаются.</p>
</div>
<div class="section" id="id9">
<h3>Кэш на стороне сервера<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h3>
<p>Для избежания загрузки файлов с диска, Xitrum кэширует маленькие файлы
(не только текстовые) в LRU кэше (вытеснение давно неиспользуемых).
Смотри <code class="docutils literal"><span class="pre">small_static_file_size_in_kb</span></code> и <code class="docutils literal"><span class="pre">max_cached_small_static_files</span></code>
в <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
</div>
</div>
<span id="document-flash"></span><div class="section" id="serve-flash-socket-policy-file">
<h2>Serve flash socket policy file<a class="headerlink" href="#serve-flash-socket-policy-file" title="Ссылка на этот заголовок">¶</a></h2>
<p>Read about flash socket policy:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html">http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html</a></li>
<li><a class="reference external" href="http://www.lightsphere.com/dev/articles/flash_socket_policy.html">http://www.lightsphere.com/dev/articles/flash_socket_policy.html</a></li>
</ul>
<p>The protocol to serve flash socket policy file is different from HTTP.
To serve:</p>
<ol class="arabic simple">
<li>Modify <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/flash_socket_policy.xml">config/flash_socket_policy.xml</a> appropriately</li>
<li>Modify <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a> to enable serving the above file</li>
</ol>
</div>
<span id="document-scopes"></span><div class="section" id="id1">
<h2>Запросы, параметры, куки, сессии<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<div class="section" id="id2">
<h3>Запросы<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<div class="section" id="id3">
<h4>Типы параметров<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h4>
<p>Доступны два вида параметров запроса: текстовые параметры и параметры файлы (file upload, бинарные данные)</p>
<p>Текстовые параметры делятся на три вида, каждый имеет тип <code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Seq[String]]</span></code>:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">queryParams</span></code>: параметры после символа ? в ссылке, например: <a class="reference external" href="http://example.com/blah?x=1&amp;y=2">http://example.com/blah?x=1&amp;y=2</a></li>
<li><code class="docutils literal"><span class="pre">bodyTextParams</span></code>: параметры в теле POST запроса</li>
<li><code class="docutils literal"><span class="pre">pathParams</span></code>: параметры в пути запроса, например: <code class="docutils literal"><span class="pre">GET(&quot;articles/:id/:title&quot;)</span></code></li>
</ol>
<p>Параметры собираются воедино в переменной <code class="docutils literal"><span class="pre">textParams</span></code> в следующем порядке
(от 1 к 3, более поздние перекрывают более ранние).</p>
<p><code class="docutils literal"><span class="pre">bodyFileParams</span></code> имеет тип scala.collection.mutable.Map[String, Seq[<a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/multipart/FileUpload.html">FileUpload</a>]].</p>
</div>
<div class="section" id="id4">
<h4>Доступ к параметрам<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h4>
<p>Из контроллера в можете получить доступ к параметрам напрямую, или вы можете использовать
методы доступа.</p>
<p>Для доступа к <code class="docutils literal"><span class="pre">textParams</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">param(&quot;x&quot;)</span></code>: возвращает <code class="docutils literal"><span class="pre">String</span></code>, выбрасывает исключение если x не существует</li>
<li><code class="docutils literal"><span class="pre">paramo(&quot;x&quot;)</span></code>: возвращает <code class="docutils literal"><span class="pre">Option[String]</span></code></li>
<li><code class="docutils literal"><span class="pre">params(&quot;x&quot;)</span></code>: возвращает <code class="docutils literal"><span class="pre">Seq[String]</span></code></li>
</ul>
<p>Вы можете преобразовывать их к другим типам (Int, Long, Fload, Double) автоматически
используя <code class="docutils literal"><span class="pre">param[Int](&quot;x&quot;)</span></code>, <code class="docutils literal"><span class="pre">params[Int](&quot;x&quot;)</span></code> и пр. Для преобразования текстовых параметров к
другим типам, перекройте метод <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala-2.11/xitrum/scope/request/ParamAccess.scala">convertTextParam</a>.</p>
<p>Для параметров файлов: <code class="docutils literal"><span class="pre">param[FileUpload](&quot;x&quot;)</span></code>, <code class="docutils literal"><span class="pre">params[FileUpload](&quot;x&quot;)</span></code> и пр.
Более подробно, смотри <a class="reference internal" href="index.html#document-upload"><em>Загрузка файлов</em></a>.</p>
</div>
<div class="section" id="at">
<h4>&#8220;at&#8221;<a class="headerlink" href="#at" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для передачи данных из контроллера в представление вы можете использовать <code class="docutils literal"><span class="pre">at</span></code>.
Тип <code class="docutils literal"><span class="pre">at</span></code> - <code class="docutils literal"><span class="pre">scala.collection.mutable.HashMap[String,</span> <span class="pre">Any]</span></code>.
Если вы знакомы с Rails, <code class="docutils literal"><span class="pre">at</span></code> это аналог <code class="docutils literal"><span class="pre">&#64;</span></code> из Rails.</p>
<p>Articles.scala</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val (title, body) = ...  // Например, получаем из базы данных
    at(&quot;title&quot;) = title
    respondInlineView(body)
  }
}
</pre></div>
</div>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;{if (at.isDefinedAt(&quot;title&quot;)) &quot;My Site - &quot; + at(&quot;title&quot;) else &quot;My Site&quot;}&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
<div class="section" id="atjson">
<h4>&#8220;atJson&#8221;<a class="headerlink" href="#atjson" title="Ссылка на этот заголовок">¶</a></h4>
<p><code class="docutils literal"><span class="pre">atJson</span></code> - утильный метод который автоматически конвертирует <code class="docutils literal"><span class="pre">at(&quot;key&quot;)</span></code> в JSON.
Метод может быть полезен для передачи моделей напрямую из Scala в JavaScript.</p>
<p><code class="docutils literal"><span class="pre">atJson(&quot;key&quot;)</span></code> эквивалент <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.toJson(at(&quot;key&quot;))</span></code>:</p>
<p>Action.scala</p>
<div class="highlight-python"><div class="highlight"><pre>case class User(login: String, name: String)

...

def execute() {
  at(&quot;user&quot;) = User(&quot;admin&quot;, &quot;Admin&quot;)
  respondView()
}
</pre></div>
</div>
<p>Action.ssp</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;script type=&quot;text/javascript&quot;&gt;
  var user = ${atJson(&quot;user&quot;)};
  alert(user.login);
  alert(user.name);
&lt;/script&gt;
</pre></div>
</div>
</div>
<div class="section" id="requestvar">
<h4>RequestVar<a class="headerlink" href="#requestvar" title="Ссылка на этот заголовок">¶</a></h4>
<p>У <code class="docutils literal"><span class="pre">at</span></code> есть недостаток, он не безопасен относительно типов, т.к. основан на не типизированной коллекции. Если вам нужна большая безопасность, можно использовать идею RequestVar, которая оборачивает <code class="docutils literal"><span class="pre">at</span></code>.</p>
<p>RVar.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.RequestVar

object RVar {
  object title extends RequestVar[String]
}
</pre></div>
</div>
<p>Articles.scala</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;articles/:id&quot;)
class ArticlesShow extends AppAction {
  def execute() {
    val (title, body) = ...  // Get from DB
    RVar.title.set(title)
    respondInlineView(body)
  }
}
</pre></div>
</div>
<p>AppAction.scala</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.view.DocType

trait AppAction extends Action {
  override def layout = DocType.html5(
    &lt;html&gt;
      &lt;head&gt;
        {antiCsrfMeta}
        {xitrumCss}
        {jsDefaults}
        &lt;title&gt;{if (RVar.title.isDefined) &quot;My Site - &quot; + RVar.title.get else &quot;My Site&quot;}&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {renderedView}
        {jsForView}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h3>Куки<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Подробнее о <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie">куки</a>.</p>
<p>Внутри контроллера, используйте <code class="docutils literal"><span class="pre">requestCookies</span></code>, для чтения кук отправленных браузером (тип <code class="docutils literal"><span class="pre">Map[String,</span> <span class="pre">String]</span></code>).</p>
<div class="highlight-python"><div class="highlight"><pre>requestCookies.get(&quot;myCookie&quot;) match {
  case None         =&gt; ...
  case Some(string) =&gt; ...
}
</pre></div>
</div>
<p>Для отправки куки браузеру, создайте экземпляр <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/DefaultCookie.html">DefaultCookie</a> и добавьте его к массиву <code class="docutils literal"><span class="pre">responseCookies</span></code> который хранит все <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/Cookie.html">куки</a>.</p>
<div class="highlight-python"><div class="highlight"><pre>val cookie = new DefaultCookie(&quot;name&quot;, &quot;value&quot;)
cookie.setHttpOnly(true)  // true: JavaScript не может получить доступ к куки
responseCookies.append(cookie)
</pre></div>
</div>
<p>Если вы не укажите путь для через метод <code class="docutils literal"><span class="pre">cookie.setPath(cookiePath)</span></code>, то
будет использован корень сайта как путь (<code class="docutils literal"><span class="pre">xitrum.Config.withBaseUrl(&quot;/&quot;)</span></code>).
Это позволяет избежать случайного дублирования кук.</p>
<p>Что бы удалить куку отправленную браузером, отправить куку с тем же именем и с
временем жизни 0. Браузер посчитает ее истекшей. Для того что бы создать куку
удаляемую при закрытии браузере, установите время жизни в <code class="docutils literal"><span class="pre">Long.MinValue</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cookie</span><span class="o">.</span><span class="n">setMaxAge</span><span class="p">(</span><span class="n">Long</span><span class="o">.</span><span class="n">MinValue</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference external" href="http://mrcoles.com/blog/cookies-max-age-vs-expires/">Internet Explorer не поддерживает &#8220;max-age&#8221;</a>,
но Netty умеет это определять и устанавливает &#8220;max-age&#8221; и &#8220;expires&#8221; должны образом. Не беспокойтесь!</p>
<p>Браузер не отправляет атрибуты куки обратно на сервер. Браузер отправляет
<a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie#Cookie_attributes">только пары имя-значение</a>.</p>
<p>Если вы хотите подписать ваши куки, что бы защититься от подделки, используйте
<code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.toSecureUrlSafeBase64</span></code> и <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri.fromSecureUrlSafeBase64</span></code>.
Подробнее смотри <a class="reference internal" href="index.html#document-howto"><em>Как шифровать данные</em></a>.</p>
<div class="section" id="id9">
<h4>Допустимые символы в куки<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h4>
<p>Вы можете использовать только <a class="reference external" href="http://stackoverflow.com/questions/1969232/allowed-characters-in-cookies">ограниченный набор символов в куки</a>.
Например, если вам нужно передать UTF-8 символы, вы должны закодировать их. Можно использовать, например, <code class="docutils literal"><span class="pre">xitrum.utill.UrlSafeBase64</span></code> или <code class="docutils literal"><span class="pre">xitrum.util.SeriDeseri</span></code>.</p>
<p>Пример записи куки:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.util.CharsetUtil
import xitrum.util.UrlSafeBase64

val value   = &quot;&quot;&quot;{&quot;identity&quot;:&quot;example@gmail.com&quot;,&quot;first_name&quot;:&quot;Alexander&quot;}&quot;&quot;&quot;
val encoded = UrlSafeBase64.noPaddingEncode(value.getBytes(CharsetUtil.UTF_8))
val cookie  = new DefaultCookie(&quot;profile&quot;, encoded)
responseCookies.append(cookie)
</pre></div>
</div>
<p>Чтение куки:</p>
<div class="highlight-python"><div class="highlight"><pre>requestCookies.get(&quot;profile&quot;).foreach { encoded =&gt;
  UrlSafeBase64.autoPaddingDecode(encoded).foreach { bytes =&gt;
    val value = new String(bytes, CharsetUtil.UTF_8)
    println(&quot;profile: &quot; + value)
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id11">
<h3>Сессии<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h3>
<p>Хранение сессии, восстановление, шифрование и прочее выполняются автоматически.</p>
<p>В контроллере, вы можете использовать переменную <code class="docutils literal"><span class="pre">session</span></code>, которая имеет тип
<code class="docutils literal"><span class="pre">scala.collection.mutable.Map[String,</span> <span class="pre">Any]</span></code>. Значения в <code class="docutils literal"><span class="pre">session</span></code> должны быть
сериализуемые.</p>
<p>Например, что бы сохранить что пользователь прошел авторизацию, вы можете сохранить
его имя в сессии:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">session</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">userId</span>
</pre></div>
</div>
<p>Позднее, если вы хотите убедиться что пользователь авторизован, вы просто проверяете
есть ли его имя в сессии:</p>
<div class="highlight-python"><div class="highlight"><pre>if (session.isDefinedAt(&quot;userId&quot;)) println(&quot;This user has logged in&quot;)
</pre></div>
</div>
<p>Хранение идентификатора пользователя и загрузка его из базы данных при каждом запросе
обычно является не плохим решением. В этом случае информация о пользователе обновляется
при каждым запросе (включая изменения в правах доступа).</p>
<div class="section" id="session-clear">
<h4>session.clear()<a class="headerlink" href="#session-clear" title="Ссылка на этот заголовок">¶</a></h4>
<p><a class="reference external" href="http://guides.rubyonrails.org/security.html#session-fixation">Одна строчка кода позволяет защититься от фиксации сессии</a>.</p>
<p>Прочитайте статью по ссылке выше что бы узнать подробнее про эту атаку. Для защиты
от атаки, в контроллере который использует логин пользователя, вызовете <code class="docutils literal"><span class="pre">session.clear()</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>@GET(&quot;login&quot;)
class LoginAction extends Action {
  def execute() {
    ...
    session.clear()  // Сброс сессии прежде чем выполнять какие либо дейтсвияthe session
    session(&quot;userId&quot;) = userId
  }
}
</pre></div>
</div>
<p>Это касается так же контроллера, который выполняет &#8220;выход пользователя&#8221; (log out).</p>
</div>
<div class="section" id="sessionvar">
<h4>SessionVar<a class="headerlink" href="#sessionvar" title="Ссылка на этот заголовок">¶</a></h4>
<p>SessionVar, как и RequestVar, это способ сделать сессию более безопасной.</p>
<p>Например, вы хотите хранить имя пользователя в сессии после того как он прошел авторизацию:</p>
<p>Объявите session var:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.SessionVar

object SVar {
  object username extends SessionVar[String]
}
</pre></div>
</div>
<p>Присвойте значение во время авторизации:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SVar</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
</pre></div>
</div>
<p>Отобразите имя пользователя:</p>
<div class="highlight-python"><div class="highlight"><pre>if (SVar.username.isDefined)
  &lt;em&gt;{SVar.username.get}&lt;/em&gt;
else
  &lt;a href={url[LoginAction]}&gt;Login&lt;/a&gt;
</pre></div>
</div>
<ul class="simple">
<li>Для удаления используйте: <code class="docutils literal"><span class="pre">SVar.username.remove()</span></code></li>
<li>Для сброса всей сессии используйте: <code class="docutils literal"><span class="pre">session.clear()</span></code></li>
</ul>
</div>
<div class="section" id="id13">
<h4>Хранилище сессии<a class="headerlink" href="#id13" title="Ссылка на этот заголовок">¶</a></h4>
<p>Из коробки Xitrum предоставляет 3 простых хранилища.
В файле <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>
есть возможность настроить хранилище сессии:</p>
<p>CookieSessionStore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Хранение сессии на стороне клиента в куках</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">xitrum</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">CookieSessionStore</span>
</pre></div>
</div>
<p>LruSessionStore:</p>
<div class="highlight-python"><div class="highlight"><pre># Простое хранилище на стороне сервера
store {
  &quot;xitrum.local.LruSessionStore&quot; {
    maxElems = 10000
  }
}
</pre></div>
</div>
<p>Если вы запускаете несколько серверов, вы можете использовать
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast для хранения кластеризованных сессии</a>.</p>
<p>Важно, если вы используете CookieSessionStore или Hazelcast, ваши данные должны быть сериализуемыми. Если
ваши данные не подлежат сериализации используйте LruSessionStore.
При использовании LruSessionStore вы можете кластеризовать сессии используя load balancer и sticky sessions.</p>
<p>Эти три типа хранилища сессии обычно покрывают все необходимые случаи. Существует
возможность определить свою реализацию хранилища сессии, используйте наследование от
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/scope/session/SessionStore.scala">SessionStore</a>
или
<a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/scope/session/ServerSessionStore.scala">ServerSessionStore</a> и реализуйте абстрактные методы.</p>
<p>Хранилище может быть объявлено в двух видах:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">store</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">StoreClassName</span>
</pre></div>
</div>
<p>Или:</p>
<div class="highlight-python"><div class="highlight"><pre>store {
  &quot;my.session.StoreClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>Используйте куки когда это возможно, поскольку они более масштабируемы
(сериализуемым и меньше 4KB).
Храните сессии на сервере (в памяти или базе данных) если это необходимо.</p>
<p>Дальнейшее чтение:
<a class="reference external" href="http://www.technicalinfo.net/papers/WebBasedSessionManagement.html">Web Based Session Management - Best practices in managing HTTP-based client sessions</a>.</p>
</div>
</div>
<div class="section" id="object-vs-val">
<h3>object vs. val<a class="headerlink" href="#object-vs-val" title="Ссылка на этот заголовок">¶</a></h3>
<p>Пожалуйста, используйте <code class="docutils literal"><span class="pre">object</span></code> вместо <code class="docutils literal"><span class="pre">val</span></code>.</p>
<p><strong>Не делайте так</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre>object RVar {
  val title    = new RequestVar[String]
  val category = new RequestVar[String]
}

object SVar {
  val username = new SessionVar[String]
  val isAdmin  = new SessionVar[Boolean]
}
</pre></div>
</div>
<p>Приведенный код компилируется но не работает корректно, потому что Vars внутри
себя используют имена классов что бы выполнять поиск. При использовании
<code class="docutils literal"><span class="pre">val</span></code>, <code class="docutils literal"><span class="pre">title</span></code> и <code class="docutils literal"><span class="pre">category</span></code> мы имеем тоже самое имя класса &#8220;xitrum.RequestVar&#8221;.
Одно и тоже как и для <code class="docutils literal"><span class="pre">username</span></code> и <code class="docutils literal"><span class="pre">isAdmin</span></code>.</p>
</div>
</div>
<span id="document-validation"></span><div class="section" id="id1">
<h2>Валидация<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Xitrum включает <a class="reference external" href="http://bassistance.de/jquery-plugins/jquery-plugin-validation/">плагин jQuery Validation</a>
для выполнения валидации на стороне клиента и предоставляет наоборот утильных методов на серверной стороне.</p>
<div class="section" id="id2">
<h3>Стандартные валидаторы<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum предоставляет набор валидаторов из пакета <code class="docutils literal"><span class="pre">xitrum.validator</span></code>.
Интерфейс валидатора:</p>
<div class="highlight-python"><div class="highlight"><pre>check(value): Boolean
message(name, value): Option[String]
exception(name, value)
</pre></div>
</div>
<p>В случае если проверка не проходит, <code class="docutils literal"><span class="pre">message</span></code> возвращает <code class="docutils literal"><span class="pre">Some(error</span> <span class="pre">message)</span></code>,
а <code class="docutils literal"><span class="pre">exception</span></code> выбрасывает <code class="docutils literal"><span class="pre">xitrum.exception.InvalidInput(error</span> <span class="pre">message)</span></code>.</p>
<p>Вы можете использовать валидаторы везде где захотите.</p>
<p>Пример контроллера:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.validator.Required

@POST(&quot;articles&quot;)
class CreateArticle {
  def execute() {
    val title = param(&quot;tite&quot;)
    val body  = param(&quot;body&quot;)
    Required.exception(&quot;Title&quot;, title)
    Required.exception(&quot;Body&quot;,  body)

    // дальнейшая обработка валидных title и body
  }
}
</pre></div>
</div>
<p>Если вы не используете блок <code class="docutils literal"><span class="pre">try</span></code> и <code class="docutils literal"><span class="pre">catch</span></code>, когда валидация не проходит,
Xitrum автоматически обработает исключение и отправит сообщение клиенту. Это удобно
при написании API и когда у вас уже есть проверка на клиенте.</p>
<p>Пример модели:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.validator.Required

case class Article(id: Int = 0, title: String = &quot;&quot;, body: String = &quot;&quot;) {
  def isValid           = Required.check(title)   &amp;&amp;     Required.check(body)
  def validationMessage = Required.message(title) orElse Required.message(body)
}
</pre></div>
</div>
<p>Смотри <a class="reference external" href="https://github.com/xitrum-framework/xitrum/tree/master/src/main/scala/xitrum/validator">пакет xitrum.validator</a>
для получения полного списка стандартных валидаторов.</p>
</div>
<div class="section" id="id3">
<h3>Написание своих валидаторов<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p>Наследуйтесь от <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/validator/Validator.scala">xitrum.validator.Validator</a> для создания своего валидатора. Необходимо реализовать только методы <code class="docutils literal"><span class="pre">check</span></code> и <code class="docutils literal"><span class="pre">message</span></code>.</p>
<p>Так же вы можете использовать библиотеку <a class="reference external" href="http://commons.apache.org/proper/commons-validator/">Commons Validator</a>.</p>
</div>
</div>
<span id="document-upload"></span><div class="section" id="id1">
<h2>Загрузка файлов<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Смотри так же раздел <a class="reference internal" href="index.html#document-scopes"><em>обработка запросов</em></a>.</p>
<p>В вашей форме загрузки файла не забывайте устанавливать <code class="docutils literal"><span class="pre">enctype</span></code> в <code class="docutils literal"><span class="pre">multipart/form-data</span></code>.</p>
<p>MyUpload.scalate:</p>
<div class="highlight-python"><div class="highlight"><pre>form(method=&quot;post&quot; action={url[MyUpload]} enctype=&quot;multipart/form-data&quot;)
  != antiCsrfInput

  label Please select a file:
  input(type=&quot;file&quot; name=&quot;myFile&quot;)

  button(type=&quot;submit&quot;) Upload
</pre></div>
</div>
<p>В контроллере <code class="docutils literal"><span class="pre">MyUpload</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import io.netty.handler.codec.http.multipart.FileUpload

val myFile = param[FileUpload](&quot;myFile&quot;)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">myFile</span></code> это экземпляр <a class="reference external" href="http://netty.io/4.0/api/io/netty/handler/codec/http/multipart/FileUpload.html">FileUpload</a>.
Используйте его методы для получения имени файла, перемещения в директорию и пр.</p>
<p>Маленькие файлы (менее 16 Кб) сохраняются в памяти. Большие файлы сохраняются
в директорию для временных файлов (смотри конфигурацию <code class="docutils literal"><span class="pre">xitrum.request.tmpUploadDir</span></code> в xitrum.conf),
и будут удалены автоматически после закрытия соединения или когда запрос будет отправлен.</p>
<div class="section" id="ajax">
<h3>Ajax загрузка файлов<a class="headerlink" href="#ajax" title="Ссылка на этот заголовок">¶</a></h3>
<p>Доступно множество JavaScript библиотек осуществляющих Ajax загрузку файлов.
Они используют скрытый iframe или flash для отправки <code class="docutils literal"><span class="pre">multipart/form-data</span></code> на сервер.
Если вы не уверены какой параметр использует библиотека в форме для отправки файла, смотрите
лог доступа Xitrum.</p>
</div>
</div>
<span id="document-filter"></span><div class="section" id="id1">
<h2>Фильтры<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<div class="section" id="before-filter">
<h3>Пре-фильтр (before filter)<a class="headerlink" href="#before-filter" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если пре-фильтр отправляет ответ сервера (вызывает respond или forwardTo), то все остальные фильтры и сам контроллер не будет
запущен.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;before_filter&quot;)
class MyAction extends Action {
  beforeFilter {
    log.info(&quot;I run therefore I am&quot;)
  }

  // метод выполнится после всех фильтров
  def execute() {
    respondInlineView(&quot;Пре-фильтр должны быть выполнен, проверьте лог&quot;)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="after-filter">
<h3>Пост-фильтры (after filter)<a class="headerlink" href="#after-filter" title="Ссылка на этот заголовок">¶</a></h3>
<p>Пост-фильтры запускаются после выполнения контроллера.
Они не принимают аргументов и не возвращают значений.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;after_filter&quot;)
class MyAction extends Action {
  afterFilter {
    log.info(&quot;Время запуска &quot; + System.currentTimeMillis())
  }

  def execute() {
    respondText(&quot;Пост-фильтр должен будет запустится, проверьте лог&quot;)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="around-filter">
<h3>Внешние фильтры (around filter)<a class="headerlink" href="#around-filter" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.GET

@GET(&quot;around_filter&quot;)
class MyAction extends Action {
  aroundFilter { action =&gt;
    val begin = System.currentTimeMillis()
    action()
    val end   = System.currentTimeMillis()
    val dt    = end - begin
    log.info(s&quot;Контролер выполнялся $dt [ms]&quot;)
  }

  def execute() {
    respondText(&quot;Внешний фильтр должен выполниться, проверьте лог&quot;)
  }
}
</pre></div>
</div>
<p>Если внешних фильтров будет несколько, они будут вложены друг в друга.</p>
</div>
<div class="section" id="id2">
<h3>Порядок выполнения фильтров<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<ul class="simple">
<li>Вначале выполняются пре-фильтры, затем внешние фильтры, и последними выполняются пост-фильтры.</li>
<li>Если пре-фильтр возвращает false, остальные фильтры (включая внешние и пост-фильтры) не будут запущены.</li>
<li>Пост-фильтры выполняются, в том числе, если хотя бы один из внешних фильтров выполнился.</li>
<li>Если внешний фильтр не вызывает <code class="docutils literal"><span class="pre">action</span></code>, вложенные внешние фильтры не будут выполнены.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>before1 -true-&gt; before2 -true-&gt; +--------------------+ --&gt; after1 --&gt; after2
                                | around1 (1 of 2)   |
                                |   around2 (1 of 2) |
                                |     action         |
                                |   around2 (2 of 2) |
                                | around1 (2 of 2)   |
                                +--------------------+
</pre></div>
</div>
</div>
</div>
<span id="document-cache"></span><div class="section" id="id1">
<h2>Кэш на стороне сервера<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Так же смотри главу про <a class="reference internal" href="index.html#document-cluster"><em>кластеризацию</em></a>.</p>
<p>Xitrum предоставляет широкие возможности для кэширования на стороне клиента и сервера.
На уровне веб сервера, маленькие файлы кэшируются в памяти, большие отправляются по
технологии zero copy. Скорость отдачи статических файлов сравнима с
<a class="reference external" href="https://gist.github.com/3293596">Nginx</a>.
На уровне фреймворка вы можете использовать кэш страницы, кэш контроллера или объектный кэш в
стиле Rails.
Xitrum придерживается <a class="reference external" href="http://code.google.com/speed/page-speed/docs/rules_intro.html">рекомендации Google</a>.</p>
<p>Для динамического контента, если контент не меняется после создания (как в случае статического
файла), вы можете установить необходимые заголовки для агрессивного кэширования. В этом
случае используйте метод <code class="docutils literal"><span class="pre">setClientCacheAggressively()</span></code> в контроллере.</p>
<p>Иногда требуется запретить кэширование на стороне клиента. В этом случае используйте
<code class="docutils literal"><span class="pre">setNoClientCache()</span></code> в контроллере.</p>
<p>Кэширование на стороне сервера более подробно рассматривается ниже.</p>
<div class="section" id="id2">
<h3>Кэширование страницы или контроллера<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action
import xitrum.annotation.{GET, CacheActionMinute, CachePageMinute}

@GET(&quot;articles&quot;)
@CachePageMinute(1)
class ArticlesIndex extends Action {
  def execute() {
    ...
  }
}

@GET(&quot;articles/:id&quot;)
@CacheActionMinute(1)
class ArticlesShow extends Action {
  def execute() {
    ...
  }
}
</pre></div>
</div>
<p>Термин &#8220;кэш страницы&#8221; и &#8220;кэш контроллера&#8221; позаимствован из
<a class="reference external" href="http://guides.rubyonrails.org/caching_with_rails.html">Ruby on Rails</a>.</p>
<p>Последовательность обработки запроса следующая:
(1) запрос -&gt; (2) пре-фильтры -&gt; (3) метод execute контроллера -&gt; (4) ответ</p>
<p>После первого запроса, Xitrum закеширует ответ на указанный период времени.
<code class="docutils literal"><span class="pre">&#64;CachePageMinute(1)</span></code> или <code class="docutils literal"><span class="pre">&#64;CacheActionMinute(1)</span></code> задают время кэша равное одной минуте.
Xitrum кэширует страницы только в случае если ответ имеет статус &#8220;200 OK&#8221;. Например, ответ
со статусом &#8220;500 Internal Server Error&#8221; или &#8220;302 Found&#8221; (redirect) не будет помещен в кэш.</p>
<p>В случае запросов к тому же контроллеру, если кэш еще не устарел, Xitrum в качестве
ответа будет использовать значение из кэша:</p>
<ul class="simple">
<li>Для кэша страницы, последовательность обработки (1) -&gt; (4).</li>
<li>Для кэша контроллера, последовательность обработки (1) -&gt; (2) -&gt; (4), или просто (1) -&gt; (2)
если пре-фильтр вернет значение &#8220;false&#8221;.</li>
</ul>
<p>Единственное различие: для кэша страницы пре-фильтры не запускаются.</p>
<p>Обычно, кэш страницы используется когда один и тот же ответ подходит для всех пользователей.
Кэш контроллера используется когда вам нужно использовать пре-фильтр как защиту, например
для проверки авторизации пользователя:</p>
<ul class="simple">
<li>Если пользователь прошел авторизацию, он может получать кэшированный ответ.</li>
<li>Если нет, отправить пользователя на страницу авторизации.</li>
</ul>
</div>
<div class="section" id="id3">
<h3>Кэш объект<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p>Кэширующие методы предоставляются объектом <code class="docutils literal"><span class="pre">xitrum.Config.xitrum.cache</span></code>, наследником
<a class="reference external" href="http://xitrum-framework.github.io/api/3.17/index.html#xitrum.Cache">xitrum.Cache</a>.</p>
<p>Без указания TTL (времени жизни):</p>
<ul class="simple">
<li>put(key, value)</li>
</ul>
<p>С указанием TTL:</p>
<ul class="simple">
<li>putSecond(key, value, seconds)</li>
<li>putMinute(key, value, minutes)</li>
<li>putHour(key, value, hours)</li>
<li>putDay(key, value, days)</li>
</ul>
<p>Обновление кэша только в случае отсутствия значения:</p>
<ul class="simple">
<li>putIfAbsent(key, value)</li>
<li>putIfAbsentSecond(key, value, seconds)</li>
<li>putIfAbsentMinute(key, value, minutes)</li>
<li>putIfAbsentHour(key, value, hours)</li>
<li>putIfAbsentDay(key, value, days)</li>
</ul>
</div>
<div class="section" id="id4">
<h3>Удаление кэша<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<p>Удаление кэша страницы или контроллера:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">removeAction</span><span class="p">[</span><span class="n">MyAction</span><span class="p">]</span>
</pre></div>
</div>
<p>Удаление объектного кэша:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>Удаление всех ключей начинающихся с префикса:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">removePrefix</span><span class="p">(</span><span class="n">keyPrefix</span><span class="p">)</span>
</pre></div>
</div>
<p>При использовании <code class="docutils literal"><span class="pre">removePrefix</span></code>, вы можете организовать иерархический кэш. Например, вы можете
создавать кэш связанной со статьей, а когда статья изменится просто удалите весь кэш статьи.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Config.xitrum.cache

// Кэш с префиксом
val prefix = &quot;articles/&quot; + article.id
cache.put(prefix + &quot;/likes&quot;, likes)
cache.put(prefix + &quot;/comments&quot;, comments)

// Позднее, очистка кэша
cache.remove(prefix)
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>Конфигурация<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вы можете использовать свою реализацию кэша.</p>
<p>В файле <a class="reference external" href="https://github.com/xitrum-framework/xitrum-new/blob/master/config/xitrum.conf">config/xitrum.conf</a>,
вы можете настроить кэш двумя способами:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cache</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">EngineClassName</span>
</pre></div>
</div>
<p>Или:</p>
<div class="highlight-python"><div class="highlight"><pre>cache {
  &quot;my.cache.EngineClassName&quot; {
    option1 = value1
    option2 = value2
  }
}
</pre></div>
</div>
<p>Xitrum предоставляет реализацию по умолчанию:</p>
<div class="highlight-python"><div class="highlight"><pre>cache {
  # Simple in-memory cache
  &quot;xitrum.local.LruCache&quot; {
    maxElems = 10000
  }
}
</pre></div>
</div>
<p>Если вы используете кластер, вы можете использовать <a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast</a>.</p>
<p>Для создания своей реализации кэша, реализуйте интерфейс <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/Cache.scala">interface</a>
<code class="docutils literal"><span class="pre">xitrum.Cache</span></code>.</p>
</div>
<div class="section" id="id6">
<h3>Как работает кэш<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вход:</p>
<div class="highlight-python"><div class="highlight"><pre>               ответ контроллера
               должен быть в кэше
запрос         и кэш существует?
-------------------------+---------------НЕТ--------------&gt;
                         |
&lt;---------ДА-------------+
  ответ из кэша
</pre></div>
</div>
<p>Выход:</p>
<div class="highlight-python"><div class="highlight"><pre>               ответ контроллера
               должен быть помещен в кэш
               кэш не существует?                     ответ
&lt;---------НЕТ------------+---------------------------------
                         |
&lt;---------ДА-------------+
  сохранить ответ в кэше
</pre></div>
</div>
</div>
<div class="section" id="xitrum-util-locallrucache">
<h3>xitrum.util.LocalLruCache<a class="headerlink" href="#xitrum-util-locallrucache" title="Ссылка на этот заголовок">¶</a></h3>
<p>Этот кэш переиспользуется всеми компонентами Xitrum. Если вам нужен отдельный небольшой
кэш, вы можете использовать <code class="docutils literal"><span class="pre">xitrum.util.LocalLruCache</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.LocalLruCache

// LRU (Least Recently Used) кэш содержит до 1000 элементов.
// Ключи и значения имеет тип String.
val cache = LocalLruCache[String, String](1000)
</pre></div>
</div>
<p>Переменная  <code class="docutils literal"><span class="pre">cache</span></code> имеет тип <a class="reference external" href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html">java.util.LinkedHashMap</a>. Вы можете использовать методы из <code class="docutils literal"><span class="pre">LinkedHashMap</span></code>.</p>
</div>
</div>
<span id="document-i18n"></span><div class="section" id="id1">
<h2>Интернационализация<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для интернационализации используется GNU gettext. В отличии от других программ, gettext поддерживает множественные
числа.</p>
<img alt="_images/poedit.png" src="_images/poedit.png" />
<div class="section" id="id2">
<h3>Используйте интернационализированные сообщения непосредственно в коде<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.Action</span></code> наследуется от <code class="docutils literal"><span class="pre">xitrum.I18n</span></code> и предоставляет методы:</p>
<div class="highlight-python"><div class="highlight"><pre>t(&quot;Message&quot;)
tc(&quot;Context&quot;, &quot;Message&quot;)

t(&quot;Hello %s&quot;).format(&quot;World&quot;)

// 1$ and 2$ are placeholders
t(&quot;%1$s says hello to %2$s, then %2$s says hello back to %1$s&quot;).format(&quot;Bill&quot;, &quot;Hillary&quot;)

// {0} and {1} are placeholders
java.text.MessageFormat.format(t(&quot;{0} says hello to {1}, then {1} says hello back to {0}&quot;), &quot;Bill&quot;, &quot;Hillary&quot;)

t(&quot;%,.3f&quot;).format(1234.5678)                                // =&gt; 1,234.568
t(&quot;%,.3f&quot;).formatLocal(java.util.Locale.FRENCH, 1234.5678)  // =&gt; 1 234,568
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>// Above, you explicitly specify locale.
// If you want to implicitly use locale of the current action:
// when English =&gt; 1,234.568, when French =&gt; 1 234,568
t(&quot;%,.3f&quot;, 1234.5678)
</pre></div>
</div>
<p>В других местах, вам нужно передать текущий контроллер что бы использовать <code class="docutils literal"><span class="pre">t</span></code> и <code class="docutils literal"><span class="pre">tc</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>// В контроллере
respondText(MyModel.hello(this))

// В модели
import xitrum.I18n
object MyModel {
  def hello(i18n: I18n) = i18n.t(&quot;Hello World&quot;)
}
</pre></div>
</div>
</div>
<div class="section" id="pot">
<h3>Извлечение сообщений в pot файл<a class="headerlink" href="#pot" title="Ссылка на этот заголовок">¶</a></h3>
<p>Создайте пустой i18n.pot файл в корневой директории проекта, скомпилируйте проект.</p>
<div class="highlight-python"><div class="highlight"><pre>sbt/sbt clean
rm i18n.pot
touch i18n.pot
sbt/sbt compile
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span></code> удалит все .class файлы, тем самым принудит SBT выполнить компиляцию всего проекта.
Поскольку после <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span></code>, SBT выполняет обновление всех <a class="reference internal" href="index.html#document-deps"><em>зависимостей</em></a>,
вы можете ускорить процесс выполнив команду <code class="docutils literal"><span class="pre">find</span> <span class="pre">target</span> <span class="pre">-name</span> <span class="pre">*.class</span> <span class="pre">-delete</span></code>, которая удалит
все .class файлы в директории <code class="docutils literal"><span class="pre">target</span></code>.</p>
<p>После компиляции, i18n.pot будет заполнен сообщениями извлеченными из исходного кода. Такое поведение реализуется
через <a class="reference external" href="http://www.scala-lang.org/node/140">плагин для компилятора Scala</a>.</p>
<p>Единственный недостаток этого метода в том что сообщения извлекаются только из
исходного кода Scala. Если у вас используются java файлы, вам придется добавить сообщения
самостоятельно через командную строку используя интерфейс <code class="docutils literal"><span class="pre">xgettext</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>xgettext -kt -ktc:1c,2 -ktn:1,2 -ktcn:1c,2,3 -o i18n_java.pot --from-code=UTF-8 $(find src/main/java -name &quot;*.java&quot;)
</pre></div>
</div>
<p>Затем вам необходимо объединить i18n_java.pot и i18n.pot.</p>
</div>
<div class="section" id="po">
<h3>Где сохранять po файлы<a class="headerlink" href="#po" title="Ссылка на этот заголовок">¶</a></h3>
<p>i18n.pot это шаблонный файл. Вы должны перевести его и сохранить как &lt;язык&gt;.po.</p>
<p>Xitrum отслеживает директорию <code class="docutils literal"><span class="pre">i18n</span></code> в classpath.
Файлы &lt;язык&gt;.po  из этой директории загружаются во время работы приложения,
Xitrum автоматически перезагружает эти файлы если они изменились.</p>
<div class="highlight-python"><div class="highlight"><pre>src
  main
    scala
    view
    resources
      i18n
        ja.po
        vi.po
        ...
</pre></div>
</div>
<p>Используйте <a class="reference external" href="http://www.poedit.net/">Poedit</a> для редактирования po файлов.
Вы можете использовать его для добавления новых pot файлов в po файл.</p>
<img alt="_images/update_from_pot.png" src="_images/update_from_pot.png" />
<p>Вы можете поставлять po файлы в составе JAR. Xitrum  автоматически объединит их
при запуске.</p>
<div class="highlight-python"><div class="highlight"><pre>mylib.jar
  i18n
    ja.po
    vi.po
        ...

another.jar
  i18n
    ja.po
    vi.po
        ...
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>Выбор языка<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<ul class="simple">
<li>Для выбор языка согласно заголовку запроса <code class="docutils literal"><span class="pre">Accept-Language</span></code>,
используйте метод <code class="docutils literal"><span class="pre">browserLanguages</span></code>. Результат выбора определяется согласно приоритету
браузера.</li>
<li>Язык по умолчанию устанавливается &#8220;en&#8221;. Для смены текущего языка используйте присвоение переменной <code class="docutils literal"><span class="pre">language</span></code>.
Например, для русского языка <code class="docutils literal"><span class="pre">language</span> <span class="pre">=</span> <span class="pre">&quot;ru&quot;</span></code>.</li>
<li>Для выбора подходящего языка из доступных, используйте вызов
<code class="docutils literal"><span class="pre">autosetLanguage(availableLanguages)</span></code>, где
<code class="docutils literal"><span class="pre">availableLanguages</span></code> список доступных языков из директории
<code class="docutils literal"><span class="pre">resources/i18n</span></code> и JAR файлов.
Если подходящего языка нет, будет установлен язык &#8220;en&#8221;.</li>
<li>Для получения текущего языка используйте <code class="docutils literal"><span class="pre">language</span></code>.</li>
</ul>
<p>В контроллере обычно объявляют пре-фильтр для установки языка:</p>
<div class="highlight-python"><div class="highlight"><pre>beforeFilter {
  val lango: Option[String] = yourMethodToGetUserPreferenceLanguageInSession()
  lango match {
    case None       =&gt; autosetLanguage(Locale.forLanguageTag(&quot;ja&quot;), Locale.forLanguageTag(&quot;vi&quot;))
    case Some(lang) =&gt; language = lang
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>Валидационные сообщения<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<p>Плагин jQuery Validation предоставляет возможности для <a class="reference external" href="https://github.com/jzaefferer/jquery-validation/tree/master/src/localization">интернационализации сообщений</a>.
Xitrum автоматически подключает файл с сообщениями подходящими для данного языка.</p>
<p>На стороне сервера для стандартных валидаторов из пакета <code class="docutils literal"><span class="pre">xitrum.validator</span></code> Xitrum предоставляет переводы.</p>
</div>
<div class="section" id="id6">
<h3>Множественные числа<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tn</span><span class="p">(</span><span class="s">&quot;Message&quot;</span><span class="p">,</span> <span class="s">&quot;Plural form&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">tcn</span><span class="p">(</span><span class="s">&quot;Context&quot;</span><span class="p">,</span> <span class="s">&quot;Message&quot;</span><span class="p">,</span> <span class="s">&quot;Plural form&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Xitrum может работать с множественными числами представленными ниже:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.gnu.org/software/gettext/manual/html_node/Plural-forms.html#Plural-forms">What are plural forms</a></li>
<li><a class="reference external" href="http://www.gnu.org/software/gettext/manual/html_node/Translating-plural-forms.html#Translating-plural-forms">Translating plural forms</a></li>
</ul>
<p>Шаблон множественных чисел может быть одним из:</p>
<div class="highlight-python"><div class="highlight"><pre>nplurals=1; plural=0
nplurals=2; plural=n != 1
nplurals=2; plural=n&gt;1
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2
nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2
nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 &gt; 0 &amp;&amp; n%100 &lt; 20)) ? 1 : 2
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=3; plural=(n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2
nplurals=3; plural=n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2
nplurals=4; plural=n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3
</pre></div>
</div>
</div>
</div>
<span id="document-log"></span><div class="section" id="id1">
<h2>Логирование<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<div class="section" id="xitrum-log">
<h3>Использование объекта xitrum.Log<a class="headerlink" href="#xitrum-log" title="Ссылка на этот заголовок">¶</a></h3>
<p>Везде вы можете использовать напрямую:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;My debug msg&quot;</span><span class="p">)</span>
<span class="n">xitrum</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;My info msg&quot;</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Использование трейта xitrum.Log<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если вам важно сообщать дополнительную информацию о том какой класс генерирует
информационные сообщения, используйте наследование он xitrum.Log</p>
<div class="highlight-python"><div class="highlight"><pre>package my_package
import xitrum.Log

object MyModel extends Log {
  log.debug(&quot;My debug msg&quot;)
  log.info(&quot;My info msg&quot;)
  ...
}
</pre></div>
</div>
<p>В файле log/xitrum.log вы увидите сообщение <code class="docutils literal"><span class="pre">MyModel</span></code>.</p>
<p>Контролеры Xitrum наследуют xitrum.Log и предоставляют метод <code class="docutils literal"><span class="pre">log</span></code>.
В любом контроллере вы можете писать:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>Проверка уровня логирования<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p><code class="docutils literal"><span class="pre">xitrum.Log</span></code> основан на <a class="reference external" href="http://slf4s.org/">SLF4S</a> (<a class="reference external" href="http://slf4s.org/api/1.7.7/">API</a>),
который в свою очередь на <a class="reference external" href="http://www.slf4j.org/">SLF4J</a>.</p>
<p>Обычно, перед выполнением сложных вычислений которые будут отправлены в лог, выполняют
проверку уровня логирования что бы избежать не нужных вычислений.</p>
<p><a class="reference external" href="https://github.com/mattroberts297/slf4s/blob/master/src/main/scala/org/slf4s/Logger.scala">SLF4S автоматически выполняет эти проверки</a>,
поэтому нет нужды их выполнять самому.</p>
<p>До Xitrum 3.13+:</p>
<div class="highlight-python"><div class="highlight"><pre>if (log.isTraceEnabled) {
  val result = heavyCalculation()
  log.trace(&quot;Output: {}&quot;, result)
}
</pre></div>
</div>
<p>Теперь:</p>
<div class="highlight-python"><div class="highlight"><pre>log.trace(s&quot;Output: #{heavyCalculation()}&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>Настройка уровня и способов логирования<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>В build.sbt есть строчка:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;ch.qos.logback&quot;</span> <span class="o">%</span> <span class="s">&quot;logback-classic&quot;</span> <span class="o">%</span> <span class="s">&quot;1.1.2&quot;</span>
</pre></div>
</div>
<p>Что означает использовать <a class="reference external" href="http://logback.qos.ch/">Logback</a>.
Конфигурационный файл Logback - <code class="docutils literal"><span class="pre">config/logback.xml</span></code>.</p>
<p>Вы можете заменить Logback любой другой реализацией <a class="reference external" href="http://www.slf4j.org/">SLF4J</a>.</p>
</div>
<div class="section" id="fluentd">
<h3>Использование Fluentd<a class="headerlink" href="#fluentd" title="Ссылка на этот заголовок">¶</a></h3>
<p><a class="reference external" href="http://www.fluentd.org/">Fluentd</a> очень популярная система сбора логов. Вы можете
настроить Logback так что бы отправлять логи (возможно из нескольких мест) на Fluentd сервер.</p>
<p>Первое, добавьте библиотеку <a class="reference external" href="https://github.com/sndyuk/logback-more-appenders">logback-more-appenders</a>
в ваш проект:</p>
<div class="highlight-python"><div class="highlight"><pre>libraryDependencies += &quot;org.fluentd&quot; % &quot;fluent-logger&quot; % &quot;0.2.11&quot;

resolvers += &quot;Logback more appenders&quot; at &quot;http://sndyuk.github.com/maven&quot;

libraryDependencies += &quot;com.sndyuk&quot; % &quot;logback-more-appenders&quot; % &quot;1.1.0&quot;
</pre></div>
</div>
<p>Затем исправьте конфигурацию <code class="docutils literal"><span class="pre">config/logback.xml</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>...

&lt;appender name=&quot;FLUENT&quot; class=&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;&gt;
  &lt;tag&gt;mytag&lt;/tag&gt;
  &lt;label&gt;mylabel&lt;/label&gt;
  &lt;remoteHost&gt;localhost&lt;/remoteHost&gt;
  &lt;port&gt;24224&lt;/port&gt;
  &lt;maxQueueSize&gt;20000&lt;/maxQueueSize&gt;  &lt;!-- Позволяет экономить память если сервер выключен --&gt;
&lt;/appender&gt;

&lt;root level=&quot;DEBUG&quot;&gt;
  &lt;appender-ref ref=&quot;FLUENT&quot;/&gt;
  &lt;appender-ref ref=&quot;OTHER_APPENDER&quot;/&gt;
&lt;/root&gt;

...
</pre></div>
</div>
</div>
</div>
<span id="document-deploy"></span><div class="section" id="id1">
<h2>Развертывание на сервере<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Вы можете запустить Xitrum напрямую:</p>
<div class="highlight-python"><div class="highlight"><pre>Браузер ------ экземпляр Xitrum сервера
</pre></div>
</div>
<p>Или добавить балансировщик нагрузки (например, HAProxy), или обратный прокси сервер (например, Apache или Nginx):</p>
<div class="highlight-python"><div class="highlight"><pre>Браузер ------ Балансировщик/Прокси -+---- экземпляр Xitrum сервера
                                     +---- экземпляр Xitrum сервера
</pre></div>
</div>
<div class="section" id="id2">
<h3>Сборка<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Используйте команду <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">xitrum-package</span></code> для подготовки директории <code class="docutils literal"><span class="pre">target/xitrum</span></code>, которая
может быть развернута на сервере:</p>
<div class="highlight-python"><div class="highlight"><pre>target/xitrum
  config
    [config files]
  public
    [static public files]
  lib
    [dependencies and packaged project file]
  script
    runner
    runner.bat
    scalive
    scalive.jar
    scalive.bat
</pre></div>
</div>
</div>
<div class="section" id="xitrum-package">
<h3>Сборка и xitrum-package<a class="headerlink" href="#xitrum-package" title="Ссылка на этот заголовок">¶</a></h3>
<p>По умолчанию команда <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">xitrum-package</span></code> копирует директории
<code class="docutils literal"><span class="pre">config</span></code>, <code class="docutils literal"><span class="pre">public</span></code>, и <code class="docutils literal"><span class="pre">script</span></code> в <code class="docutils literal"><span class="pre">target/xitrum</span></code>. Если необходимо
дополнительно копировать какие-то директории или файлы измените <code class="docutils literal"><span class="pre">build.sbt</span></code>
следующим образом:</p>
<div class="highlight-python"><div class="highlight"><pre>XitrumPackage.copy(&quot;config&quot;, &quot;public, &quot;script&quot;, &quot;doc/README.txt&quot;, &quot;etc.&quot;)
</pre></div>
</div>
<p>Подробнее смотри <a class="reference external" href="https://github.com/xitrum-framework/xitrum-package">xitrum-package</a>.</p>
</div>
<div class="section" id="scala-jvm">
<h3>Подключение Scala консоли к запущенному JVM процессу<a class="headerlink" href="#scala-jvm" title="Ссылка на этот заголовок">¶</a></h3>
<p>В боевом режиме, при определенной настройке, допускается использовать
<a class="reference external" href="https://github.com/xitrum-framework/scalive">Scalive</a> для подключения
Scala консоли к работающему JVM процессу для живой отладки.</p>
<p>Запустите <code class="docutils literal"><span class="pre">scalive</span></code> из директории script:</p>
<div class="highlight-python"><div class="highlight"><pre>script
  runner
  runner.bat
  scalive
  scalive.jar
  scalive.bat
</pre></div>
</div>
</div>
<div class="section" id="oracle-jdk-centos-ubuntu">
<h3>Установка Oracle JDK на CentOS или Ubuntu<a class="headerlink" href="#oracle-jdk-centos-ubuntu" title="Ссылка на этот заголовок">¶</a></h3>
<p>Приведенная информация размещена здесь для удобства. Вы можете установить Java используя
пакетный менеджер.</p>
<p>Проверьте установленные альтернативы:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --list java
</pre></div>
</div>
<p>Пример вывода:</p>
<div class="highlight-python"><div class="highlight"><pre>/usr/lib/jvm/jdk1.7.0_15/bin/java
/usr/lib/jvm/jdk1.7.0_25/bin/java
</pre></div>
</div>
<p>Определите ваше окружение (32 бита или 64 бита):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">init</span>
</pre></div>
</div>
<p>Пример вывода:</p>
<div class="highlight-python"><div class="highlight"><pre>/sbin/init: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x4efe732752ed9f8cc491de1c8a271eb7f4144a5c, stripped
</pre></div>
</div>
<p>Скачайте JDK по ссылке <a class="reference external" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">Oracle</a>.
<a class="reference external" href="http://stackoverflow.com/questions/10268583/how-to-automate-download-and-instalation-of-java-jdk-on-linux">Обходной путь</a> для загрузки jdk без браузера:</p>
<div class="highlight-python"><div class="highlight"><pre>wget --no-cookies --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/7u45-b18/jdk-7u45-linux-x64.tar.gz&quot;
</pre></div>
</div>
<p>Распакуйте и переместите в подходящею папку:</p>
<div class="highlight-python"><div class="highlight"><pre>tar -xzvf jdk-7u45-linux-x64.tar.gz
sudo mv jdk1.7.0_45 /usr/lib/jvm/jdk1.7.0_45
</pre></div>
</div>
<p>Зарегистрируйте как альтернативу:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/java&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javac&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javap&quot; &quot;javap&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javap&quot; 1
sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/lib/jvm/jdk1.7.0_45/bin/javaws&quot; 1
</pre></div>
</div>
<p>Установите как активную альтернативу:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --config java
</pre></div>
</div>
<p>Пример вывода:</p>
<div class="highlight-python"><div class="highlight"><pre>There are 3 choices for the alternative java (providing /usr/bin/java).

  Selection    Path                               Priority   Status
------------------------------------------------------------
* 0            /usr/lib/jvm/jdk1.7.0_25/bin/java   50001     auto mode
  1            /usr/lib/jvm/jdk1.7.0_15/bin/java   50000     manual mode
  2            /usr/lib/jvm/jdk1.7.0_25/bin/java   50001     manual mode
  3            /usr/lib/jvm/jdk1.7.0_45/bin/java   1         manual mode

Press enter to keep the current choice[*], or type selection number: 3
update-alternatives: using /usr/lib/jvm/jdk1.7.0_45/bin/java to provide /usr/bin/java (java) in manual mode
</pre></div>
</div>
<p>Проверьте версию:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">java</span> <span class="o">-</span><span class="n">version</span>
</pre></div>
</div>
<p>Пример вывода:</p>
<div class="highlight-python"><div class="highlight"><pre>java version &quot;1.7.0_45&quot;
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
</pre></div>
</div>
<p>Установите альтернативы так же для:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo update-alternatives --config javac
sudo update-alternatives --config javap
sudo update-alternatives --config javaws
</pre></div>
</div>
</div>
<div class="section" id="xitrum">
<h3>Запускайте Xitrum в боевом режиме когда система запускается<a class="headerlink" href="#xitrum" title="Ссылка на этот заголовок">¶</a></h3>
<p>Скрипт <code class="docutils literal"><span class="pre">script/runner</span></code> (для <a href="#id5"><span class="problematic" id="id6">*</span></a>nix) и <code class="docutils literal"><span class="pre">script/runner.bat</span></code> (для Windows) запускает
сервер в боевом окружении используя указанный объект как <code class="docutils literal"><span class="pre">main</span></code> класс.</p>
<div class="highlight-python"><div class="highlight"><pre>script/runner quickstart.Boot
</pre></div>
</div>
<p>Вы можете улучшить <code class="docutils literal"><span class="pre">runner</span></code> (или <code class="docutils literal"><span class="pre">runner.bat</span></code>)
<a class="reference external" href="http://www.oracle.com/technetwork/java/hotspotfaq-138619.html">настроив JVM</a>.
Так же смотри <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
<p>Для запуска Xitrum в фоновом режиме при старте Linux системы проще всего добавить строчку в <code class="docutils literal"><span class="pre">/etc/rc.local</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>su - user_foo_bar -c /path/to/the/runner/script/above &amp;
</pre></div>
</div>
<p>Кроме того можно использовать утилиту <a class="reference external" href="http://cr.yp.to/daemontools.html">daemontools</a>. Для установки на CentOS, смотри <a class="reference external" href="http://whomwah.com/2008/11/04/installing-daemontools-on-centos5-x86_64/">инструкцию</a>.</p>
<p>Или используйте <a class="reference external" href="http://supervisord.org/">Supervisord</a>.
Пример <code class="docutils literal"><span class="pre">/etc/supervisord.conf</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>[program:my_app]
directory=/path/to/my_app
command=/path/to/my_app/script/runner quickstart.Boot
autostart=true
autorestart=true
startsecs=3
user=my_user
redirect_stderr=true
stdout_logfile=/path/to/my_app/log/stdout.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=7
stdout_capture_maxbytes=1MB
stdout_events_enabled=false
environment=PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/opt/aws/bin:~/bin
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>Настройка портов<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum слушает порт 8000 и 4430 по умолчанию.
Вы можете изменить эти порты в конфигурации <code class="docutils literal"><span class="pre">config/xitrum.conf</span></code>.</p>
<p>Вы можете обновить <code class="docutils literal"><span class="pre">/etc/sysconfig/iptables</span></code> для перенаправления портов
80 на 8000 и 443 на 4430:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo su - root
chmod 700 /etc/sysconfig/iptables
iptables-restore &lt; /etc/sysconfig/iptables
iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8000
iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 4430
iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 80 -j REDIRECT --to-ports 8000
iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 443 -j REDIRECT --to-ports 4430
iptables-save -c &gt; /etc/sysconfig/iptables
chmod 644 /etc/sysconfig/iptables
</pre></div>
</div>
<p>Конечно в данном примере предполагается что эти порты свободны. Если на них работает Apache
остановите его командой:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo /etc/init.d/httpd stop
sudo chkconfig httpd off
</pre></div>
</div>
<p>Смотри так же:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.frozentux.net/iptables-tutorial/chunkyhtml/">Iptables</a></li>
</ul>
</div>
<div class="section" id="linux">
<h3>Настройка Linux для обработки большого числа подключений<a class="headerlink" href="#linux" title="Ссылка на этот заголовок">¶</a></h3>
<p>Важно: <a class="reference external" href="https://groups.google.com/forum/#!topic/spray-user/S-SNR2m0BWU">JDK страдает серьезной проблемой производительности IO (NIO) на Mac</a>.</p>
<p>Смотри так же:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.basho.com/riak/latest/ops/tuning/linux/">Linux Performance Tuning (Riak)</a></li>
<li><a class="reference external" href="http://docs.basho.com/riak/latest/ops/tuning/aws/">AWS Performance Tuning (Riak)</a></li>
<li><a class="reference external" href="http://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/">Ipsysctl tutorial</a></li>
<li><a class="reference external" href="http://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/tcpvariables.html">TCP variables</a></li>
</ul>
<div class="section" id="id9">
<h4>Увеличьте лимит открытых файлов<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h4>
<p>Каждое подключение рассматривается операционной системой как открытый файл.
По умолчанию максимальное количество открытых файлов 1024.
Для увеличения этого лимита, исправьте /etc/security/limits.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>*  soft  nofile  1024000
*  hard  nofile  1024000
</pre></div>
</div>
<p>Нужно заново зайти в систему что бы этот конфигурация подействовала.
Убедитесь что лимит изменился <code class="docutils literal"><span class="pre">ulimit</span> <span class="pre">-n</span></code>.</p>
</div>
<div class="section" id="id10">
<h4>Оптимизация ядра<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h4>
<p>Согласно
<a class="reference external" href="http://www.metabrew.com/article/a-million-user-comet-application-with-mochiweb-part-1">A Million-user Comet Application with Mochiweb</a>,
измените /etc/sysctl.conf:</p>
<div class="highlight-python"><div class="highlight"><pre># General gigabit tuning
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216

# This gives the kernel more memory for TCP
# which you need with many (100k+) open socket connections
net.ipv4.tcp_mem = 50576 64768 98152

# Backlog
net.core.netdev_max_backlog = 2048
net.core.somaxconn = 1024
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_syncookies = 1

# If you run clients
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 10
</pre></div>
</div>
<p>Выполните <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">sysctl</span> <span class="pre">-p</span></code> что бы применить изменения. Перезагрузка не требуется,
теперь ваше ядро способно обработать гораздо больше подключений.</p>
</div>
<div class="section" id="backlog">
<h4>Замечание об использовании backlog<a class="headerlink" href="#backlog" title="Ссылка на этот заголовок">¶</a></h4>
<p>TCP выполняет 3 рукопожатия (handshake) для установки соединения.
Когда удаленный клиент устанавливает подключение к серверу, он отправляет
SYN пакет, а сервер отвечает SYN-ACK, затем клиент посылает ACK пакет и
соединение устанавливается. Xitrum получает соединение после
того как оно было полностью установлено.</p>
<p>Согласно статье
<a class="reference external" href="https://sites.google.com/site/beingroot/articles/apache/socket-backlog-tuning-for-apache">Socket backlog tuning for Apache</a>, таймаут подключение случается когда SYN пакет теряется. Это происходит потому что
очередь backlog переполняется подключениями посылающими SYN-ACK медленным клиентам.</p>
<p>Согласно
<a class="reference external" href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/configtuning-kernel-limits.html">FreeBSD Handbook</a>,
значение 128 обычно слишком мало для обработки подключений на высоко нагруженных серверах. Для
таких окружений, рекомендуется увеличить это значение до 1024 или даже выше. Это так же
способствует в предотвращении атак Denial of Service (DoS).</p>
<p>Размер backlog для Xitrum установлен в 1024 (memcached так же использует это значение),
но вам так же нужно изменить ядро как показано ниже.</p>
<p>Для проверки конфигурации backlog:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cat</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">net</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">somaxconn</span>
</pre></div>
</div>
<p>Или:</p>
<div class="highlight-python"><div class="highlight"><pre>sysctl net.core.somaxconn
</pre></div>
</div>
<p>Для установки нового значения используйте:</p>
<div class="highlight-python"><div class="highlight"><pre>sudo sysctl -w net.core.somaxconn=1024
</pre></div>
</div>
</div>
</div>
<div class="section" id="haproxy">
<h3>HAProxy<a class="headerlink" href="#haproxy" title="Ссылка на этот заголовок">¶</a></h3>
<p>Смотри <a class="reference external" href="https://github.com/sockjs/sockjs-node/blob/master/examples/haproxy.cfg">пример</a> настройки HAProxy для SockJS.</p>
<div class="highlight-python"><div class="highlight"><pre>defaults
    mode http
    timeout connect 10s
    timeout client  10h  # Set to long time to avoid WebSocket connections being closed when there&#39;s no network activity
    timeout server  10h  # Set to long time to avoid ERR_INCOMPLETE_CHUNKED_ENCODING on Chrome

frontend xitrum_with_discourse
    bind 0.0.0.0:80

    option forwardfor

    acl is_discourse path_beg /forum
    use_backend discourse if is_discourse
    default_backend xitrum

backend xitrum
    server srv_xitrum 127.0.0.1:8000

backend discourse
    server srv_discourse 127.0.0.1:3000
</pre></div>
</div>
<p>В этом <a class="reference external" href="http://serverfault.com/questions/165883/is-there-a-way-to-add-more-backend-server-to-haproxy-without-restarting-haproxy">обсуждении</a> предлагается способ настройки HAProxy который позволяет перезагружать конфигурационные файлы без перезапуска сервера.</p>
<p>HAProxy гораздо проще в использовании чем Nginx. Он подходи Xitrum поскольку как сказано <a class="reference internal" href="index.html#document-cache"><em>в секции про кэширование</em></a>, Xitrum отдает статические файлы
<a class="reference external" href="https://gist.github.com/3293596">очень быстро</a>. Вам не нужна возможность отдачи статики в Nginx.</p>
</div>
<div class="section" id="nginx">
<h3>Nginx<a class="headerlink" href="#nginx" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если вы используете WebSocket или SockJS в Xitrum и Nginx 1.2, то вам следует
установить дополнительный модуль <a class="reference external" href="https://github.com/yaoweibin/nginx_tcp_proxy_module">nginx_tcp_proxy_module</a>.
Nginx 1.3+ поддерживает WebSocket из коробки.</p>
<p>Nginx по умолчанию использует протокол HTTP 1.0. Если ваш сервер возвращает
chunked response, вам нужно использовать протокол HTTP 1.1, пример:</p>
<div class="highlight-python"><div class="highlight"><pre>location / {
  proxy_http_version 1.1;
  proxy_set_header Connection &quot;&quot;;
  proxy_pass http://127.0.0.1:8000;
}
</pre></div>
</div>
<p>Как <a class="reference external" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive">сказано в документации</a> к http keepalive, вам следует установить proxy_set_header Connection &#8220;&#8221;;</p>
</div>
<div class="section" id="heroku">
<h3>Развертывание в Heroku<a class="headerlink" href="#heroku" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum может быть запущен на <a class="reference external" href="https://www.heroku.com/">Heroku</a>.</p>
<div class="section" id="id16">
<h4>Зарегистрируйтесь и создайте репозиторий<a class="headerlink" href="#id16" title="Ссылка на этот заголовок">¶</a></h4>
<p>Следуя <a class="reference external" href="https://devcenter.heroku.com/articles/quickstart">официальной документации</a>,
зарегистрируйтесь и создайте git репозиторий.</p>
</div>
<div class="section" id="procfile">
<h4>Создание Procfile<a class="headerlink" href="#procfile" title="Ссылка на этот заголовок">¶</a></h4>
<p>Создайте Procfile и сохраните его в корневой директории. Heroku читает этот файл
при старте.</p>
<div class="highlight-python"><div class="highlight"><pre>web: target/xitrum/script/runner &lt;YOUR_PACKAGE.YOUR_MAIN_CLASS&gt; $PORT
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h4>Изменения порта<a class="headerlink" href="#id18" title="Ссылка на этот заголовок">¶</a></h4>
<p>Поскольку Heroku назначает порт автоматически, используйте код:</p>
<p>config/xitrum.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>port {
  http              = ${PORT}
  # https             = 4430
  # flashSocketPolicy = 8430  # flash_socket_policy.xml will be returned
}
</pre></div>
</div>
<p><a class="reference external" href="https://addons.heroku.com/ssl">Поддержка SSL</a>.</p>
</div>
<div class="section" id="id19">
<h4>Уровень логирования<a class="headerlink" href="#id19" title="Ссылка на этот заголовок">¶</a></h4>
<p>config/logback.xml:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;root level=&quot;INFO&quot;&gt;
  &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
&lt;/root&gt;
</pre></div>
</div>
<p>Просмотр логов в Heroku:</p>
<div class="highlight-python"><div class="highlight"><pre>heroku logs -tail
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h4>Создание алиаса для <code class="docutils literal"><span class="pre">xitrum-package</span></code><a class="headerlink" href="#id20" title="Ссылка на этот заголовок">¶</a></h4>
<p>Во время развертывания, Heroky выполняет <code class="docutils literal"><span class="pre">sbt/sbt</span> <span class="pre">clean</span> <span class="pre">compile</span> <span class="pre">stage</span></code>.
Поэтому вам нужно добавить алиас для <code class="docutils literal"><span class="pre">xitrum-package</span></code>.</p>
<p>build.sbt:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">addCommandAlias</span><span class="p">(</span><span class="s">&quot;stage&quot;</span><span class="p">,</span> <span class="s">&quot;;xitrum-package&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4>Развертывание на Heroku<a class="headerlink" href="#id21" title="Ссылка на этот заголовок">¶</a></h4>
<p>Процесс развертывания запускается автоматически после git push.</p>
<div class="highlight-python"><div class="highlight"><pre>git push heroku master
</pre></div>
</div>
<p>Смотри также <a class="reference external" href="https://devcenter.heroku.com/articles/getting-started-with-scala">официальная документация по языку Scala</a>.</p>
</div>
</div>
</div>
<span id="document-cluster"></span><div class="section" id="akka-and-hazelcast">
<h2>Масштабирование вместе с Akka and Hazelcast<a class="headerlink" href="#akka-and-hazelcast" title="Ссылка на этот заголовок">¶</a></h2>
<p>Xitrum спроектирован с расчетом на работу нескольких экземпляров приложения за
балансировщиком нагрузки или прокси сервером:</p>
<div class="highlight-python"><div class="highlight"><pre>                                        / экземпляр Xitrum 1
Балансировщик нагрузки/Прокси сервер ---- экземпляр Xitrum 2
                                        \ экземпляр Xitrum 3
</pre></div>
</div>
<p>Кэш, сессии и SockJS сессии могут быть кластеризованы из коробки благодаря использованию
<a class="reference external" href="http://akka.io/">Akka</a> и <a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">Hazelcast</a>.</p>
<p>Совместно с Hazelcast, экземпляр Xitrum становится одновременно кэширующим сервером. Вам не нужна
дополнительная сущность вроде Memcache.</p>
<p>Смотри конфигурацию <code class="docutils literal"><span class="pre">config/akka.conf</span></code>, <a class="reference external" href="http://akka.io/docs/">Akka doc</a> и
<a class="reference external" href="http://hazelcast.org/documentation/">Hazelcast doc</a> что бы узнать как настроить
Akka и Hazelcast для кластеризации.</p>
<p>Важно: Сессию вы может так же хранить <a class="reference internal" href="index.html#document-scopes"><em>внутри куки</em></a>.</p>
</div>
<span id="document-handler"></span><div class="section" id="netty-handlers">
<h2>Netty handlers<a class="headerlink" href="#netty-handlers" title="Ссылка на этот заголовок">¶</a></h2>
<p>This chapter is advanced, you don&#8217;t have to know to use Xitrum normally. To
understand, you must have knowlege about <a class="reference external" href="http://netty.io/">Netty</a>.</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Rack_(Web_server_interface)">Rack</a>,
<a class="reference external" href="http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a>, and
<a class="reference external" href="http://en.wikipedia.org/wiki/PSGI">PSGI</a> have middleware architecture.
Xitrum is based on <a class="reference external" href="http://netty.io/">Netty</a> which has the same thing called
handlers. You can create additional handlers and customize the channel pipeline
of handlers. Doing this, you can maximize server performance for your specific
use case.</p>
<p>This chaper describes:</p>
<ul class="simple">
<li>Netty handler architecture</li>
<li>Handlers that Xitrum provides and their default order</li>
<li>How to create and use custom handler</li>
</ul>
<div class="section" id="netty-handler-architecture">
<h3>Netty handler architecture<a class="headerlink" href="#netty-handler-architecture" title="Ссылка на этот заголовок">¶</a></h3>
<p>For each connection, there is a channel pipeline to handle the IO data.
A channel pipeline is a series of handlers. There are 2 types of handlers:</p>
<ul class="simple">
<li>Inbound: the request direction client -&gt; server</li>
<li>Outbound: the response direction server -&gt; client</li>
</ul>
<p>Please see the doc of <a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html">ChannelPipeline</a>
for more information.</p>
<div class="highlight-python"><div class="highlight"><pre>                                               I/O Request
                                          via Channel or
                                      ChannelHandlerContext
                                                    |
+---------------------------------------------------+---------------+
|                           ChannelPipeline         |               |
|                                                  \|/              |
|    +---------------------+            +-----------+----------+    |
|    | Inbound Handler  N  |            | Outbound Handler  1  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
|               |                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  .               |
|               .                                   .               |
| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
|        [ method call]                       [method call]         |
|               .                                   .               |
|               .                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
|               |                                  \|/              |
|    +----------+----------+            +-----------+----------+    |
|    | Inbound Handler  1  |            | Outbound Handler  M  |    |
|    +----------+----------+            +-----------+----------+    |
|              /|\                                  |               |
+---------------+-----------------------------------+---------------+
                |                                  \|/
+---------------+-----------------------------------+---------------+
|               |                                   |               |
|       [ Socket.read() ]                    [ Socket.write() ]     |
|                                                                   |
|  Netty Internal I/O Threads (Transport Implementation)            |
+-------------------------------------------------------------------+
</pre></div>
</div>
</div>
<div class="section" id="custom-handlers">
<h3>Custom handlers<a class="headerlink" href="#custom-handlers" title="Ссылка на этот заголовок">¶</a></h3>
<p>When starting Xitrum server, you can pass in your own
<a class="reference external" href="http://netty.io/4.0/api/io/netty/channel/ChannelInitializer.html">ChannelInitializer</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Server

object Boot {
  def main(args: Array[String]) {
    Server.start(myChannelInitializer)
  }
}
</pre></div>
</div>
<p>For HTTPS server, Xitrum will automatically prepend SSL handler to the pipeline.
You can reuse Xitrum handlers in your pipeline.</p>
</div>
<div class="section" id="xitrum-default-handlers">
<h3>Xitrum default handlers<a class="headerlink" href="#xitrum-default-handlers" title="Ссылка на этот заголовок">¶</a></h3>
<p>See <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/handler/DefaultHttpChannelInitializer.scala">xitrum.handler.DefaultHttpChannelInitializer</a>.</p>
<p>Sharable handlers (same instances are shared among many connections) are put in
<code class="docutils literal"><span class="pre">DefaultHttpChannelInitializer</span></code> object above so that they can be easily picked
up by apps that want to use custom pipeline. Those apps may only want a subset
of default handlers.</p>
<p>For example, when an app uses its own dispatcher (not Xitrum&#8217;s routing/dispatcher)
and only needs Xitrum&#8217;s fast static file serving, it may use only these handlers:</p>
<p>Inbound:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HttpRequestDecoder</span></code></li>
<li><code class="docutils literal"><span class="pre">PublicFileServer</span></code></li>
<li>Its own dispatcher</li>
</ul>
<p>Outbound:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HttpResponseEncoder</span></code></li>
<li><code class="docutils literal"><span class="pre">ChunkedWriteHandler</span></code></li>
<li><code class="docutils literal"><span class="pre">XSendFile</span></code></li>
</ul>
</div>
</div>
<span id="document-metrics"></span><div class="section" id="id1">
<h2>Метрики<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Xitrum собирает информацию об использовании памяти, CPU и информацию об использовании
контроллеров каждой ноды вашего Akka кластера. Эти данные публикуются в JSON формате.
Xitrum так же позволяет публиковать ваши метрики.</p>
<p>Эти метрики базируются на библиотеке <a class="reference external" href="http://metrics.dropwizard.io/3.1.0/">Coda Hale Metrics</a>.</p>
<div class="section" id="id2">
<h3>Агрегирование метрик<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<div class="section" id="cpu">
<h4>Память и CPU<a class="headerlink" href="#cpu" title="Ссылка на этот заголовок">¶</a></h4>
<p>Информация по памяти и CPU собирается с помощью
<a class="reference external" href="http://doc.akka.io/api/akka/2.3.0/index.html#akka.cluster.NodeMetrics">NodeMetrics</a>
системы актров каждой ноды.</p>
<p>Память:</p>
<img alt="_images/metrics_heapmemory.png" src="_images/metrics_heapmemory.png" />
<p>CPU: Количество процессоров и средняя загрузка</p>
<img alt="_images/metrics_cpu.png" src="_images/metrics_cpu.png" />
</div>
<div class="section" id="id3">
<h4>Метрики контроллера<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h4>
<p>Xitrum собирает состояния выполнения каждого контроллера в формате
<a class="reference external" href="http://metrics.dropwizard.io/3.1.0/getting-started/#histograms">гистограммы</a>.
Вы можете узнать сколько раз контроллер запускался, время выполнения для
не асинхронных запросов.</p>
<img alt="_images/metrics_action_count.png" src="_images/metrics_action_count.png" />
<p>Последнее время выполнения конкретного контроллера:</p>
<img alt="_images/metrics_action_time.png" src="_images/metrics_action_time.png" />
</div>
<div class="section" id="id5">
<h4>Дополнительные метрики<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h4>
<p>Дополнительные метрики вы можете собирать самостоятельно. Подробнее про использование читайте
<a class="reference external" href="http://metrics.dropwizard.io/3.1.0/">Coda Hale Metrics</a> и
<a class="reference external" href="https://github.com/erikvanoosten/metrics-scala">реализация на Scala</a>. Используйте
пакет <code class="docutils literal"><span class="pre">xitru.Metrics</span></code>, в нем <code class="docutils literal"><span class="pre">gauge</span></code>, <code class="docutils literal"><span class="pre">counter</span></code>, <code class="docutils literal"><span class="pre">meter</span></code>, <code class="docutils literal"><span class="pre">timer</span></code> и <code class="docutils literal"><span class="pre">histogram</span></code>.</p>
<p>Пример таймера:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.{Action, Metrics}
import xitrum.annotation.GET

object MyAction {
  lazy val myTimer = Metrics.timer(&quot;myTimer&quot;)
}

@GET(&quot;my/action&quot;)
class MyAction extends Action {
  import MyAction._

  def execute() {
    myTimer.time {
      // Задача время выполнения которой вы хотите замерить
      ...
    }
    ...
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h3>Публикация метрик<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum публикует последние значения метрики в JSON формате через определенный интервал времени.
Этот интервал имеет не постоянное значение и может меняться.</p>
<p>Информация о памяти:</p>
<div class="highlight-python"><div class="highlight"><pre>{
  &quot;TYPE&quot;      : &quot;heapMemory&quot;,
  &quot;SYSTEM&quot;    : akka.actor.Address.system,
  &quot;HOST&quot;      : akka.actor.Address.host,
  &quot;PORT&quot;      : akka.actor.Address.port,
  &quot;HASH&quot;      : akka.actor.Address.hashCode,
  &quot;TIMESTAMP&quot; : akka.cluster.NodeMetrics.timestamp,
  &quot;USED&quot;      : Number as byte,
  &quot;COMMITTED&quot; : Number as byte,
  &quot;MAX&quot;       : Number as byte
}
</pre></div>
</div>
<p>Информация о CPU:</p>
<div class="highlight-python"><div class="highlight"><pre>{
  &quot;TYPE&quot;              : &quot;cpu&quot;,
  &quot;SYSTEM&quot;            : akka.actor.Address.system,
  &quot;HOST&quot;              : akka.actor.Address.host,
  &quot;PORT&quot;              : akka.actor.Address.port,
  &quot;HASH&quot;              : akka.actor.Address.hashCode,
  &quot;TIMESTAMP&quot;         : akka.cluster.NodeMetrics.timestamp
  &quot;SYSTEMLOADAVERAGE&quot; : Number,
  &quot;CPUCOMBINED&quot;       : Number,
  &quot;PROCESSORS&quot;        : Number
}
</pre></div>
</div>
<p>MetricsRegistry использует <a class="reference external" href="http://metrics.dropwizard.io/3.1.0/manual/json/">metrics-json</a> для разбора
JSON файла.</p>
<div class="section" id="xitrum">
<h4>Просмотр метрик через Xitrum<a class="headerlink" href="#xitrum" title="Ссылка на этот заголовок">¶</a></h4>
<p>Xitrum предоставляет стандартный способ просмотра метрик по ссылке <code class="docutils literal"><span class="pre">/xitrum/metrics/viewer?api_key=&lt;смотри</span> <span class="pre">xitrum.conf&gt;</span></code>.
По этой ссылке доступны графики представленные выше.
Графики созданы с использованием <a class="reference external" href="http://d3js.org/">D3.js</a>.</p>
<p>Ссылка может быть сформирована следующим образом:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Config
import xitrum.metrics.XitrumMetricsViewer

url[XitrumMetricsViewer](&quot;api_key&quot; -&gt; Config.xitrum.metrics.get.apiKey)
</pre></div>
</div>
</div>
<div class="section" id="jconsole">
<h4>Jconsole<a class="headerlink" href="#jconsole" title="Ссылка на этот заголовок">¶</a></h4>
<p>Метрики можно просматривать через <code class="docutils literal"><span class="pre">jconsole</span></code> используя <a class="reference external" href="http://metrics.dropwizard.io/3.1.0/getting-started/#reporting-via-jmx">JVM Reporter</a>.</p>
<img alt="_images/metrics_jconsole.png" src="_images/metrics_jconsole.png" />
<p>Запуск:</p>
<div class="highlight-python"><div class="highlight"><pre>import com.codahale.metrics.JmxReporter

object Boot {
  def main(args: Array[String]) {
    Server.start()
    JmxReporter.forRegistry(xitrum.Metrics.registry).build().start()
  }
}
</pre></div>
</div>
<p>Затем используйте <a class="reference external" href="http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">jconsole</a>.</p>
</div>
<div class="section" id="id9">
<h4>Просмотр метрик сторонними средствами<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h4>
<p>Метрики публикуются как ссылка SockJS <code class="docutils literal"><span class="pre">xitrum/metrics/channel</span></code> в формате JSON.
<code class="docutils literal"><span class="pre">jsAddMetricsNameSpace</span></code> - шаблон JavaScript кода который предоставляет Xitrum
для установки соединения.</p>
<p>Реализуйте свой собственный JSON обработчик используя метод <code class="docutils literal"><span class="pre">initMetricsChannel</span></code>.</p>
<p>Пример контроллера:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.annotation.GET
import xitrum.metrics.MetricsViewer

@GET(&quot;my/metrics/viewer&quot;)
class MySubscriber extends MetricsViewer {
  def execute() {
    jsAddMetricsNameSpace(&quot;window&quot;)
    jsAddToView(&quot;&quot;&quot;
      function onValue(json) {
        console.log(json);
      }
      function onClose(){
        console.log(&quot;channel closed&quot;);
      }
      window.initMetricsChannel(onValue, onClose);
    &quot;&quot;&quot;)
    respondView()
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h4>Хранения метрик<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для экономии памяти, Xitrum не хранит старые значения метрик. Если вы хотите хранить эти
значения, вам передается реализовать собственный обработчик.</p>
<p>Например:</p>
<div class="highlight-python"><div class="highlight"><pre>import akka.actor.Actor
import xitrum.metrics.PublisherLookUp

class MySubscriber extends Actor with PublisherLookUp {
  override def preStart() {
    lookUpPublisher()
  }

  def receive = {
    case _ =&gt;
  }

  override def doWithPublisher(globalPublisher: ActorRef) = {
    context.become {
      // When run in multinode environment
      case multinodeMetrics: Set[NodeMetrics] =&gt;
        // Save to DB or write to file.

      // When run in single node environment
      case nodeMetrics: NodeMetrics =&gt;
        // Save to DB or write to file.

      case Publish(registryAsJson) =&gt;
        // Save to DB or write to file.

      case _ =&gt;
    }
  }
}
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-howto"></span><div class="section" id="howto">
<h2>HOWTO<a class="headerlink" href="#howto" title="Ссылка на этот заголовок">¶</a></h2>
<p>Эта глава представляет некоторое число небольших примеров. Каждый пример достаточно
мал что бы писать отдельную главу.</p>
<div class="section" id="id1">
<h3>Авторизация<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вы можете защитить весь сайт или некоторые контроллеры с использованием
<a class="reference external" href="http://en.wikipedia.org/wiki/Basic_access_authentication">basic authentication (базовая аутентификация)</a>.</p>
<p>Важно: Xitrum не поддерживает
<a class="reference external" href="http://en.wikipedia.org/wiki/Digest_access_authentication">digest authentication (цифровая аутентификация)</a>
поскольку она не так безопасна как кажется. Она подвержена <code class="docutils literal"><span class="pre">man-in-the-middle</span></code> атаке.
Для большей безопасности вы должны использовать HTTPS, поддержка которого встроена в Xitrum
(не нужен дополнительный прокси вроде Apache или Nginx).</p>
<div class="section" id="id2">
<h4>Конфигурация для базовой аутентификации<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h4>
<p>В config/xitrum.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>&quot;basicAuth&quot;: {
  &quot;realm&quot;:    &quot;xitrum&quot;,
  &quot;username&quot;: &quot;xitrum&quot;,
  &quot;password&quot;: &quot;xitrum&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>Базовая аутентификация на конкретный контроллер<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.Action

class MyAction extends Action {
  beforeFilter {
    basicAuth(&quot;Realm&quot;) { (username, password) =&gt;
      username == &quot;username&quot; &amp;&amp; password == &quot;password&quot;
    }
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h3>Загрузка конфигурационных файлов<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<div class="section" id="json">
<h4>JSON файл<a class="headerlink" href="#json" title="Ссылка на этот заголовок">¶</a></h4>
<p>JSON подходит для конфигурационных файлов со сложной структурой.</p>
<p>Сохраняйте вашу конфигурацию в директорию &#8220;config&#8221;. Эта директория попадает в classpath
в режиме разработки благодаря build.sbt и в боевом режиме благодаря скрипту запуска script/runner (и script/runner.bat).</p>
<p>myconfig.json:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span>
  <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="s">&quot;God&quot;</span><span class="p">,</span>
  <span class="s">&quot;password&quot;</span><span class="p">:</span> <span class="s">&quot;Does God need a password?&quot;</span><span class="p">,</span>
  <span class="s">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="s">&quot;Eva&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Загрузка:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Loader

case class MyConfig(username: String, password: String, children: Seq[String])
val myConfig = Loader.jsonFromClasspath[MyConfig](&quot;myconfig.json&quot;)
</pre></div>
</div>
<p>Замечания:</p>
<ul class="simple">
<li>Ключи и строки должны быть в двойных кавычках</li>
<li>На данный момент нельзя писать комментарии в JSON файле</li>
</ul>
</div>
<div class="section" id="protperties">
<h4>Файлы свойств (protperties)<a class="headerlink" href="#protperties" title="Ссылка на этот заголовок">¶</a></h4>
<p>Вы можете использовать файлы свойств, но рекомендуется использовать
JSON везде где это возможно. Файлы свойств не безопасны относительно типа, не поддерживают
UTF-8 и не подразумевают вложенность.</p>
<p>myconfig.properties:</p>
<div class="highlight-python"><div class="highlight"><pre>username = God
password = Does God need a password?
children = Adam, Eva
</pre></div>
</div>
<p>Загрузка:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Loader

// Here you get an instance of java.util.Properties
val properties = Loader.propertiesFromClasspath(&quot;myconfig.properties&quot;)
</pre></div>
</div>
</div>
<div class="section" id="typesafe">
<h4>Typesafe конфигурационный файл<a class="headerlink" href="#typesafe" title="Ссылка на этот заголовок">¶</a></h4>
<p>Xitrum включает Akka, которая включает
<a class="reference external" href="https://github.com/typesafehub/config">конфигурационную библиотеку</a> от
<a class="reference external" href="http://typesafe.com/company">Typesafe</a>.
Возможно это самый лучший путь загрузки конфигурационных файлов.</p>
<p>myconfig.conf:</p>
<div class="highlight-python"><div class="highlight"><pre>username = God
password = Does God need a password?
children = [&quot;Adam&quot;, &quot;Eva&quot;]
</pre></div>
</div>
<p>Загрузка:</p>
<div class="highlight-python"><div class="highlight"><pre>import com.typesafe.config.{Config, ConfigFactory}

val config   = ConfigFactory.load(&quot;myconfig.conf&quot;)
val username = config.getString(&quot;username&quot;)
val password = config.getString(&quot;password&quot;)
val children = config.getStringList(&quot;children&quot;)
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h3>Сериализация и десериализация<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
<p>Сериализация <code class="docutils literal"><span class="pre">Array[Byte]</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri
val bytes = SeriDeseri.toBytes(&quot;my serializable object&quot;)
</pre></div>
</div>
<p>Десериализация:</p>
<div class="highlight-python"><div class="highlight"><pre>val option = SeriDeseri.fromBytes[MyType](bytes)  // Option[MyType]
</pre></div>
</div>
<p>Если вы хотите сохранить в файле:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">xitrum.util.Loader</span>
<span class="n">Loader</span><span class="o">.</span><span class="n">bytesToFile</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="s">&quot;myObject.bin&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Чтобы загрузить из файла:</p>
<div class="highlight-python"><div class="highlight"><pre>val bytes = Loader.bytesFromFile(&quot;myObject.bin&quot;)
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>Шифрование данных<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum предоставляет встроенное шифрование:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.Secure

// Array[Byte]
val encrypted = Secure.encrypt(&quot;my data&quot;.getBytes)

// Option[Array[Byte]]
val decrypted = Secure.decrypt(encrypted)
</pre></div>
</div>
<p>Вы можете использовать <code class="docutils literal"><span class="pre">xitrum.util.UrlSafeBase64</span></code> для кодирования и декодирования бинарных данных
в обычную строку.</p>
<div class="highlight-python"><div class="highlight"><pre>// Строка которая может быть использована как URL или в куки
val string = UrlSafeBase64.noPaddingEncode(encrypted)

// Option[Array[Byte]]
val encrypted2 = UrlSafeBase64.autoPaddingDecode(string)
</pre></div>
</div>
<p>Или короче:</p>
<div class="highlight-python"><div class="highlight"><pre>import xitrum.util.SeriDeseri

val mySerializableObject = new MySerializableClass

// String
val encrypted = SeriDeseri.toSecureUrlSafeBase64(mySerializableObject)

// Option[MySerializableClass]
val decrypted = SeriDeseri.fromSecureUrlSafeBase64[MySerializableClass](encrypted)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">SeriDeseri</span></code> использует <a class="reference external" href="https://github.com/twitter/chill">Twitter Chill</a>
для сериализации и десериализации. Ваши данные должны быть сериализуемыми.</p>
<p>Вы можете задать ключ шифрования.</p>
<div class="highlight-python"><div class="highlight"><pre>val encrypted = Secure.encrypt(&quot;my data&quot;.getBytes, &quot;my key&quot;)
val decrypted = Secure.decrypt(encrypted, &quot;my key&quot;)
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>val encrypted = SeriDeseri.toSecureUrlSafeBase64(mySerializableObject, &quot;my key&quot;)
val decrypted = SeriDeseri.fromSecureUrlSafeBase64[MySerializableClass](encrypted, &quot;my key&quot;)
</pre></div>
</div>
<p>Если ключ не указан, то <code class="docutils literal"><span class="pre">secureKey</span></code> из xitrum.conf будет использован.</p>
</div>
<div class="section" id="id9">
<h3>Множество сайтов на одном доменном имени<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h3>
<p>При использовании прокси, например, Nginx, для запуска нескольких сайтов на одном
доменном имени:</p>
<div class="highlight-python"><div class="highlight"><pre>http://example.com/site1/...
http://example.com/site2/...
</pre></div>
</div>
<p>Вы можете указать baseUrl в config/xitrum.conf.</p>
<p>В JS коде, для того что бы использовать корректные ссылки в Ajax запросах, используйте <code class="docutils literal"><span class="pre">withBaseUrl</span></code>
из <a class="reference external" href="https://github.com/xitrum-framework/xitrum/blob/master/src/main/scala/xitrum/js.scala">xitrum.js</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Если текущий сайт имеет baseUrl &quot;site1&quot;, результат будет:</span>
<span class="c"># /site1/path/to/my/action</span>
<span class="n">xitrum</span><span class="o">.</span><span class="n">withBaseUrl</span><span class="p">(</span><span class="s">&#39;/path/to/my/action&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="markdown-html">
<h3>Преобразование разметки (markdown) в HTML<a class="headerlink" href="#markdown-html" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если ваш проект использует <a class="reference internal" href="index.html#document-template_engines"><em>шаблонизатор Scalate</em></a>,
тогда:</p>
<div class="highlight-python"><div class="highlight"><pre>import org.fusesource.scalamd.Markdown
val html = Markdown(&quot;input&quot;)
</pre></div>
</div>
<p>В другом случае, вам нужно добавить зависимость в build.sbt:</p>
<div class="highlight-python"><div class="highlight"><pre>libraryDependencies += &quot;org.fusesource.scalamd&quot; %% &quot;scalamd&quot; % &quot;1.6&quot;
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>Мониторинг изменений файлов<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h3>
<p>Вы можете зарегистрировать слушателя изменений файлов и директорий
<a class="reference external" href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/StandardWatchEventKinds.html">StandardWatchEventKinds</a>.</p>
<div class="highlight-python"><div class="highlight"><pre>import java.nio.file.Paths
import xitrum.util.FileMonitor

val target = Paths.get(&quot;absolute_path_or_path_relative_to_application_directory&quot;).toAbsolutePath
FileMonitor.monitor(FileMonitor.MODIFY, target, { path =&gt;
  // Do some callback with path
  println(s&quot;File modified: $path&quot;)

  // And stop monitoring if necessary
  FileMonitor.unmonitor(FileMonitor.MODIFY, target)
})
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">FileMonitor</span></code> внутри себя использует
<a class="reference external" href="https://github.com/lloydmeta/schwatcher">Schwatcher</a>.</p>
</div>
<div class="section" id="id11">
<h3>Временные директории<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h3>
<p>По умолчанию Xitrum использует директорию <code class="docutils literal"><span class="pre">tmp</span></code> в текущем (рабочем) каталоге
для хранения генерируемых файлов Scalate, больших загружаемых и других файлов
(настраивается опцией <code class="docutils literal"><span class="pre">tmpDir</span></code> в xitrum.conf).</p>
<p>Получение пути временной директории:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xitrum</span><span class="o">.</span><span class="n">Config</span><span class="o">.</span><span class="n">xitrum</span><span class="o">.</span><span class="n">tmpDir</span><span class="o">.</span><span class="n">getAbsolutePath</span>
</pre></div>
</div>
<p>Создание нового файла или каталога во временной директории:</p>
<div class="highlight-python"><div class="highlight"><pre>val file = new java.io.File(xitrum.Config.xitrum.tmpDir, &quot;myfile&quot;)

val dir = new java.io.File(xitrum.Config.xitrum.tmpDir, &quot;mydir&quot;)
dir.mkdirs()
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>Потоковые видео<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h3>
<p>Существует несколько способов транслировать потоковое видео. Наиболее простой:</p>
<ul class="simple">
<li>На сервере хранить interleaved .mp4 видео файлы, пользователь сможет просматривать
их в в процессе загрузки.</li>
<li>Использовать HTTP сервер который поддерживает
<a class="reference external" href="http://en.wikipedia.org/wiki/Byte_serving">range requests</a> (например, Xitrum),
тогда пользователи смогут проматывать воспроизведение во время загрузки.</li>
</ul>
<p>Вы можете использовать <a class="reference external" href="http://gpac.wp.mines-telecom.fr/mp4box/">MP4Box</a> для генерации
interleaved .mp4 с блоками по 500 milliseconds:</p>
<div class="highlight-python"><div class="highlight"><pre>MP4Box -inter 500 movie.mp4
</pre></div>
</div>
</div>
</div>
<span id="document-deps"></span><div class="section" id="id1">
<h2>Зависимости<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<div class="section" id="id2">
<h3>Библиотеки<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>Xitrum использует некоторые библиотеки. Вы можете использовать их напрямую
если захотите.</p>
<img alt="_images/deps.png" src="_images/deps.png" />
<p>Главные зависимости:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.scala-lang.org/">Scala</a>:
Xitrum написан на языке программирования Scala.</li>
<li><a class="reference external" href="https://netty.io/">Netty</a>:
В качестве асинхронного HTTP(S) сервера.
Многие возможности Xitrum используют Netty,
например WebSocket и zero copy.</li>
<li><a class="reference external" href="http://akka.io/">Akka</a>:
Для SockJS. Akka зависит от <a class="reference external" href="https://github.com/typesafehub/config">Typesafe Config</a>,
который так же используется в Xitrum.</li>
</ul>
<p>Другие зависимости:</p>
<ul class="simple">
<li><a class="reference external" href="http://commons.apache.org/lang/">Commons Lang</a>:
Для экранирования JSON данных.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/glokka">Glokka</a>:
Для кластеризация акторов SockJS.</li>
<li><a class="reference external" href="https://github.com/json4s/json4s">JSON4S</a>:
Для разбора и генерации JSON данных. JSON4S зависит от
<a class="reference external" href="http://paranamer.codehaus.org/">Paranamer</a>.</li>
<li><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Rhino">Rhino</a>:
В Scalate для компиляции CoffeeScript в JavaScript.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/sclasner">Sclasner</a>:
Для поиска HTTP маршрутов в контроллерах, .class и .jar файлах.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/scaposer">Scaposer</a>:
Для интернационализации.</li>
<li><a class="reference external" href="https://github.com/twitter/chill">Twitter Chill</a>:
Для сериализации и десериализации куки и сессий.
Chill базируется на <a class="reference external" href="http://code.google.com/p/kryo/">Kryo</a>.</li>
<li><a class="reference external" href="http://slf4s.org/">SLF4S</a>, <a class="reference external" href="http://logback.qos.ch/">Logback</a>:
Для логирования.</li>
</ul>
<p><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">Шаблон пустого проекта Xitrum</a>
включает утилиты:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/scala-xgettext">scala-xgettext</a>:
<a class="reference internal" href="index.html#document-i18n"><em>Извелечение сообщений</em></a> из .scala файлов во время компиляции.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-package">xitrum-package</a>:
Для <a class="reference internal" href="index.html#document-deploy"><em>подготовки проекта к развертыванию</em></a> на сервере.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/scalive">Scalive</a>:
Для подключения Scala консоли к JVM процессу для живой отладки.</li>
</ul>
</div>
<div class="section" id="id3">
<h3>Связанные проекты<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p>Демо проекты:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">xitrum-new</a>:
Шаблон пустого проекта Xitrum.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-demos">xitrum-demos</a>:
Демонстрационный проект возможностей Xitrum.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-placeholder">xitrum-placeholder</a>:
Демонстрационный проекта RESTful API который возвращает изображения.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/comy">comy</a>:
Демонстрационный проект: короткие ссылки.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-multimodule-demo">xitrum-multimodule-demo</a>:
Пример мульти модульного <a class="reference external" href="http://www.scala-sbt.org/">SBT</a> проекта.</li>
</ul>
<p>Проекты:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-scalate">xitrum-scalate</a>:
Стандартный шаблонизатор для Xitrum, подключенный в
<a class="reference external" href="https://github.com/xitrum-framework/xitrum-new">шаблонном проекте</a>.
Вы можете заменить его другим шаблонизатором, или вообще убрать если вам
не нужен шаблонизатор. Он зависит от
<a class="reference external" href="http://scalate.fusesource.org/">Scalate</a> и
<a class="reference external" href="https://github.com/chirino/scalamd">Scalamd</a>.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-hazelcast">xitrum-hazelcast</a>:
Для кластеризации кэша и сессии на стороне сервера.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-ko">xitrum-ko</a>:
Предоставляет дополнительные возможности для <a class="reference external" href="http://knockoutjs.com/">Knockoutjs</a>.</li>
</ul>
<p>Другие проекты:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-doc">xitrum-doc</a>:
Исходный код <a class="reference external" href="http://xitrum-framework.github.io/guide.html">учебника Xitrum</a>.</li>
<li><a class="reference external" href="https://github.com/xitrum-framework/xitrum-framework.github.io">xitrum-hp</a>:
Исходный код <a class="reference external" href="http://xitrum-framework.github.io/">домашней страниц Xitrum</a>.</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html#document-index">Оглавление</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro">Введение</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Возможности</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">Авторы</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-tutorial">Как начать</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum">Создание пустого проекта Xitrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Запуск</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#eclipse">Импорт проекта в Eclipse</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#intellij">Импорт проекта в IntelliJ</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">Автоматическая перезагрузка</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#ide">Запуск в IDE</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id6">Запуск в SBT</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dcevm">DCEVM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">Список игнорируемых файлов</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-action_view">Контроллеры и представления</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#normal-action">Стандартный контроллер (normal action)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#futureaction">FutureAction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#actor-action">Актор контроллер (actor action)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Отправка ответа клиенту</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Шаблонизация</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#currentaction">currentAction и приведение типов</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id4">Mustache</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#coffeescript">CoffeeScript</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#layout">Макет (Layout)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id6">Макет в отдельном файле</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#respondview">Использование макета непосредственно в respondView</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">Внутренние представления</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">Фрагменты</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">Использование шаблона смежного контроллера</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id10">Один контроллер - много представлений</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id11">Компонент</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-restful">RESTful APIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">Кэш маршрутов</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Очередность маршрутов</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Несколько маршрутов для одного контроллера</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Точка в маршруте</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">Регулярные выражения в маршруте</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">Обработка не стандартных маршрутов</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">Ссылка на контроллер</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">Редирект на контроллер</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">Форвардинг (перенаправление) на контроллер</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax">Определение Ajax запроса</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#anti-csrf">Anti-CSRF</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#anticsrfinput-anticsrftoken">antiCsrfInput и antiCsrfToken</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#skipcsrfcheck">SkipCsrfCheck</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id11">Управление маршрутами</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id12">Получение полных (сырых) данных запроса</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#api">Документирование API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-template_engines">Шаблонизация</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Настройка</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Отключение шаблонизатора</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Реализация своего шаблонизатора</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-postback">Postbacks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">Шаблон</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Форма</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Другие элементы (не формы)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Диалог подтверждения</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">Дополнительные параметры</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax">Отображение анимации во время Ajax загрузки</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-xml">XML</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">Отключения экранирования XML</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Группировка XML элементов</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xhtml">Отображение XHTML</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-js">JavaScript и JSON</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#javascript">JavaScript</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id1">Вставка JavaScript фрагментов в представление</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id2">Отправка JavaScript непосредственно (без представления)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#json">JSON</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#knockout-js">Плагин для Knockout.js</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-async">Асинхронная обработка запросов</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#websocket">WebSocket</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#sockjs">SockJS</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#chunked">Chunked ответ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#iframe">Бесконечный iframe</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#event-source">Event Source</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-static">Статичные файлы</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Отправка статических файлов с диска</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#index-html">index.html и обработка отсутствующих маршрутов</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">404 и 500</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#webjars">Использование файлов ресурсов в соответствии с WebJars</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id4">WebJars</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#jar-webjars">Хранение файлов ресурсов внутри .jar файла согласно WebJars</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#classpath">Ответ файлом из classpath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#etag-max-age">Кэширование на стороне клиента с ETag и max-age</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#gzip">GZIP</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">Кэш на стороне сервера</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-flash">Serve flash socket policy file</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-scopes">Запросы, параметры, куки, сессии</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Запросы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">Типы параметров</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id4">Доступ к параметрам</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#at">&#8220;at&#8221;</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#atjson">&#8220;atJson&#8221;</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#requestvar">RequestVar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">Куки</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">Допустимые символы в куки</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id11">Сессии</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#session-clear">session.clear()</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sessionvar">SessionVar</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id13">Хранилище сессии</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#object-vs-val">object vs. val</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-validation">Валидация</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Стандартные валидаторы</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Написание своих валидаторов</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-upload">Загрузка файлов</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#ajax">Ajax загрузка файлов</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-filter">Фильтры</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#before-filter">Пре-фильтр (before filter)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#after-filter">Пост-фильтры (after filter)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#around-filter">Внешние фильтры (around filter)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Порядок выполнения фильтров</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cache">Кэш на стороне сервера</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Кэширование страницы или контроллера</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Кэш объект</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Удаление кэша</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">Конфигурация</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">Как работает кэш</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-util-locallrucache">xitrum.util.LocalLruCache</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-i18n">Интернационализация</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Используйте интернационализированные сообщения непосредственно в коде</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#pot">Извлечение сообщений в pot файл</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#po">Где сохранять po файлы</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Выбор языка</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Валидационные сообщения</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id6">Множественные числа</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-log">Логирование</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-log">Использование объекта xitrum.Log</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Использование трейта xitrum.Log</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Проверка уровня логирования</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">Настройка уровня и способов логирования</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#fluentd">Использование Fluentd</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deploy">Развертывание на сервере</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Сборка</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-package">Сборка и xitrum-package</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#scala-jvm">Подключение Scala консоли к запущенному JVM процессу</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#oracle-jdk-centos-ubuntu">Установка Oracle JDK на CentOS или Ubuntu</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum">Запускайте Xitrum в боевом режиме когда система запускается</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">Настройка портов</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#linux">Настройка Linux для обработки большого числа подключений</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">Увеличьте лимит открытых файлов</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id10">Оптимизация ядра</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#backlog">Замечание об использовании backlog</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#haproxy">HAProxy</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nginx">Nginx</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#heroku">Развертывание в Heroku</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id16">Зарегистрируйтесь и создайте репозиторий</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#procfile">Создание Procfile</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id18">Изменения порта</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id19">Уровень логирования</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id20">Создание алиаса для <code class="docutils literal"><span class="pre">xitrum-package</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id21">Развертывание на Heroku</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cluster">Масштабирование вместе с Akka and Hazelcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-handler">Netty handlers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#netty-handler-architecture">Netty handler architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#custom-handlers">Custom handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#xitrum-default-handlers">Xitrum default handlers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-metrics">Метрики</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Агрегирование метрик</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#cpu">Память и CPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">Метрики контроллера</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id5">Дополнительные метрики</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">Публикация метрик</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#xitrum">Просмотр метрик через Xitrum</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#jconsole">Jconsole</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id9">Просмотр метрик сторонними средствами</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id10">Хранения метрик</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-howto">HOWTO</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id1">Авторизация</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id2">Конфигурация для базовой аутентификации</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">Базовая аутентификация на конкретный контроллер</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Загрузка конфигурационных файлов</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#json">JSON файл</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#protperties">Файлы свойств (protperties)</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#typesafe">Typesafe конфигурационный файл</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id7">Сериализация и десериализация</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id8">Шифрование данных</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id9">Множество сайтов на одном доменном имени</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#markdown-html">Преобразование разметки (markdown) в HTML</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id10">Мониторинг изменений файлов</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id11">Временные директории</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id12">Потоковые видео</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deps">Зависимости</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Библиотеки</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">Связанные проекты</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">Документация Xitrum Scala Web Framework Guide 3.28.6</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, Ngoc Dao.
      Создано с помощью <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>
